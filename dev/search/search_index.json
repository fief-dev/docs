{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What is Fief?","text":"<p>Fief is an open-source platform to manage users and authentication in your applications. Our goal is to help you manage users and security in a matter of minutes, not days. Key features:</p> <ul> <li>Pre-built login and registration pages</li> <li>Users management dashboard</li> <li>SDK for the most popular languages and frameworks</li> <li>Integrations for the most popular no-code tools</li> </ul>"},{"location":"#self-hosted","title":"Self-hosted","text":"<p>Fief is fully open-source and usable for free. You can host it on the server or cloud of your choice!</p>"},{"location":"#project-roadmap","title":"Project roadmap","text":"<p>Fief is a young project and still has many features to implement and room for improvements!</p>"},{"location":"#what-we-have-now","title":"What we have now?","text":"<ul> <li> User registration</li> <li> User authentication using OAuth2 and OpenID Connect protocols</li> <li> Social authentication (Google, Facebook...)</li> <li> Email verification</li> <li> Forgot password process</li> <li> Built-in user profile pages for account management</li> <li> Customizable authentication pages</li> <li> Customizable transactional emails</li> <li> Bring your own database</li> <li> Event webhooks</li> <li> Custom user fields</li> <li> Roles and permissions access control</li> <li> Official Docker image for self-hosting</li> <li> Official Python client with FastAPI and Flask integrations</li> <li> Official Node.js Express integration</li> <li> Official Next.js integration</li> <li> Official JavaScript client with browser and React integrations</li> <li> Admin dashboard</li> <li> ID Token encryption support</li> <li> PKCE support</li> </ul>"},{"location":"#what-well-have-in-the-future","title":"What we'll have in the future?","text":"<ul> <li> 2FA authentication with authenticator apps and U2F keys</li> <li> User invitation process</li> <li> Custom API scopes</li> <li> User groups management</li> </ul> <p>...and more \ud83d\ude80</p> <p>View the project backlog</p>"},{"location":"migration/","title":"Migrate to 0.28+","text":"<p>Starting Fief 0.28.0, we removed the multiple workspaces feature, which was more suited for our discontinued cloud environment rather than a self-hosting approach.</p> <p>As such, if you were hosting a Fief instance before 0.28.0, you'll need to perform a few operations to migrate data and be compatible with the new versions.</p> <p>If you're a new user of Fief, this is not for you</p> <p>This migration procedure only concerns users who ran an instance before version 0.28.0.</p>"},{"location":"migration/#how-it-worked-before","title":"How it worked before?","text":"<p>Basically, we had a \"main\" database which was responsible to \"map\" each workspaces to a \"sub-database\". If you look at the database you defined, you'll see the following tables:</p> <ul> <li><code>admin_api_key</code></li> <li><code>admin_session_tokens</code></li> <li><code>alembic_version</code></li> <li><code>workspace_users</code></li> <li><code>workspaces</code></li> </ul> <p>If you look inside <code>workspaces</code>, you'll see the definition of the workspace in your Fief instance:</p> id created_at updated_at name domain database_type database_host database_port database_username database_password database_name alembic_revision database_ssl_mode users_count database_use_schema database_table_prefix 08e952f1-8a79-4672-99f8-ea6919cd4692 2022-04-17 09:15:20.066176+00 2024-02-09 00:06:00.415373+00 My workspace fief.mydomain.com NULL NULL NULL NULL NULL NULL 6c06c7d908a7 NULL 1194 false fief_ <p>The ID of your workspace, here <code>08e952f1-8a79-4672-99f8-ea6919cd4692</code> is important: it'll determine the location of the actual workspace data in your DB.</p>"},{"location":"migration/#migrate-data","title":"Migrate data","text":""},{"location":"migration/#im-using-postgresql","title":"I'm using PostgreSQL","text":"<p>With PostgreSQL, each workspace has its own schema, named after their ID. What we'll do here is to move all the tables from the schema to the main schema, <code>public</code>.</p> <p>Here is a query to do so. We assume the schema is named <code>08e952f1-8a79-4672-99f8-ea6919cd4692</code>. Don't forget to modify it with your actual workspace ID.</p> <pre><code>DO\n$$\nDECLARE\n    table_name text;\nBEGIN\n    FOR table_name IN (SELECT tablename FROM pg_tables WHERE schemaname = '08e952f1-8a79-4672-99f8-ea6919cd4692')\n    LOOP\n        EXECUTE format('ALTER TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".%I SET SCHEMA public', table_name);\n    END LOOP;\nEND;\n$$;\n</code></pre>"},{"location":"migration/#im-using-mysql","title":"I'm using MySQL","text":"<p>With MySQL, we created databases for each workspace, named after their ID. What we'll do here is to move all the tables to the main database.</p> <p>We assume the workspace database is named <code>08e952f1-8a79-4672-99f8-ea6919cd4692</code> and your main database, <code>my_database</code>. Don't forget to modify it with your actual values.</p> <pre><code>RENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_alembic_version TO my_database.fief_alembic_version;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_audit_logs TO my_database.fief_audit_logs;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_authorization_codes TO my_database.fief_authorization_codes;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_clients TO my_database.fief_clients;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_email_domains TO my_database.fief_email_domains;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_email_templates TO my_database.fief_email_templates;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_email_verifications TO my_database.fief_email_verifications;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_grants TO my_database.fief_grants;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_login_sessions TO my_database.fief_login_sessions;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_oauth_accounts TO my_database.fief_oauth_accounts;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_oauth_providers TO my_database.fief_oauth_providers;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_oauth_sessions TO my_database.fief_oauth_sessions;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_permissions TO my_database.fief_permissions;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_refresh_tokens TO my_database.fief_refresh_tokens;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_registration_sessions TO my_database.fief_registration_sessions;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_roles TO my_database.fief_roles;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_roles_permissions TO my_database.fief_roles_permissions;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_session_tokens TO my_database.fief_session_tokens;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_tenants TO my_database.fief_tenants;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_tenants_oauth_providers TO my_database.fief_tenants_oauth_providers;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_themes TO my_database.fief_themes;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_user_field_values TO my_database.fief_user_field_values;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_user_fields TO my_database.fief_user_fields;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_user_permissions TO my_database.fief_user_permissions;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_user_roles TO my_database.fief_user_roles;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_users TO my_database.fief_users;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_webhook_logs TO my_database.fief_webhook_logs;\nRENAME TABLE \"08e952f1-8a79-4672-99f8-ea6919cd4692\".fief_webhooks TO my_database.fief_webhooks;\n</code></pre>"},{"location":"migration/#im-using-sqlite","title":"I'm using SQLite","text":"<p>SQLite stores database in a file. By default, on our Docker image, those files are located in <code>/data/db</code>. The main database is called <code>fief.db</code> and each workspace has a database file named after their ID.</p> <p>What we'll do is to simply rename your workspace database so it matches the main one. We assume the workspace database is named <code>08e952f1-8a79-4672-99f8-ea6919cd4692</code> and your main database, <code>fief.db</code>. Don't forget to modify it with your actual values.</p> <pre><code>mv fief.db fief.db.bak  # Backup the old database\nmv 08e952f1-8a79-4672-99f8-ea6919cd4692 fief.db\n</code></pre>"},{"location":"migration/#fief-cloud","title":"Fief Cloud","text":"<p>For Fief Cloud users, we've created a dedicated tool to export your data: https://exporter.fief.dev</p> <p>Only compatible with PostgreSQL</p> <p>The exported data will only be importable into a PostgreSQL database, so you'll need to use PostgreSQL when running your Fief instance.</p>"},{"location":"migration/#1-export-your-data","title":"1. Export your data","text":"<p>The exporter tool will connect to your Fief's account to show you the list of your workspaces. Select the workspace you want to export and click on Export data. Your SQL dump will be downloaded automatically.</p> <p></p>"},{"location":"migration/#2-import-it-in-your-instance","title":"2. Import it in your instance","text":"<p>The resulting file is a valid PostgreSQL dump. You can directly import it in your database using <code>psql</code>:</p> <pre><code>psql -h localhost -p 5432 -U fief -d fief &lt; ~/fief_dump_Example.sql\n</code></pre> <p>Make sure to adapt your host, port, username and database to your own database server.</p>"},{"location":"migration/#3-set-your-encryption-key","title":"3. Set your encryption key","text":"<p>Some values in the database are encrypted using the Fernet algorithm. You'll find your encryption key at the top of your dump file:</p> <pre><code>head -n1 ~/fief_dump_Example.sql\n</code></pre> <pre><code>-- ENCRYPTION_KEY=YourEncryptionKeyValue\n</code></pre> <p>You should set this value as <code>ENCRYPTION_KEY</code> in your environment variables.</p>"},{"location":"migration/#next-steps","title":"Next steps","text":"<p>On the next startup, the new version of Fief will automatically upgrade the schema while keeping your existing data.</p>"},{"location":"migration/#admin-user","title":"Admin user","text":"<p>Admin permissions are now directly controlled by a specific role on your instance. Thus, you'll need to grant it to your user account. You can do so using the Fief CLI:</p> <pre><code>fief grant-admin-role anne@bretagne.duchy\n</code></pre>"},{"location":"migration/#admin-api-keys","title":"Admin API keys","text":"<p>Please note that Admin API Keys are not migrated. You'll need to create them again and update the token in your API calls accordingly.</p>"},{"location":"migration/#cleanup-old-tables","title":"Cleanup old tables","text":"<p>After checking that everything works correctly, you can safely delete the following tables:</p> <ul> <li><code>admin_api_key</code></li> <li><code>admin_session_tokens</code></li> <li><code>alembic_version</code></li> <li><code>workspace_users</code></li> <li><code>workspaces</code></li> </ul>"},{"location":"migration/#what-if-i-had-multiple-workspaces","title":"What if I had multiple workspaces?","text":"<p>Unfortunately, if you have multiple workspaces, you'll need to run one instance per workspace.</p> <p>From our experience, this was in most cases not really useful and you probably better rely on the Tenants.</p>"},{"location":"migration/#ive-problems-migrating","title":"I've problems migrating \ud83d\ude1e","text":"<p>If you encounter problems or if something is not clear, ask us on the GitHub Discussions forum. We're here to help!</p>"},{"location":"telemetry/","title":"Telemetry","text":"<p>To better understand how Fief is used and improve the project, we collect some analytics on your instances.</p> <p>This data is collected and analyzed on PostHog, on the European data center.</p>"},{"location":"telemetry/#what-we-collect","title":"What we collect?","text":"<p>We collect analytics information about:</p> <ul> <li>The server:<ul> <li>Its version</li> <li>The type of database used (PostgreSQL, MySQL or SQLite)</li> <li>If it runs on localhost</li> <li>The number of users</li> </ul> </li> <li>The admin dashboard:<ul> <li>Page views</li> <li>Page clicks interactions</li> <li>Browser language and version</li> </ul> </li> </ul> <p>The server will push this data every hour to our analytics.</p>"},{"location":"telemetry/#what-we-do-not-collect","title":"What we do not collect?","text":"<p>We do not collect:</p> <ul> <li>Your self-hosted server host</li> <li>Data about your users</li> <li>Analytics data on the authentication pages (login, register, forgot password...)</li> </ul>"},{"location":"telemetry/#opt-out-telemetry","title":"Opt-out telemetry","text":"<p>If you don't wish to send analytics data when deploying your Fief server, you can set the environment variable <code>TELEMETRY_ENABLED</code> to <code>False</code>.</p>"},{"location":"telemetry/#can-i-see-the-source-code-for-this","title":"Can I see the source code for this?","text":"<p>For sure! The interesting parts for telemetry are:</p> <ul> <li><code>fief/services/posthog.py</code></li> <li><code>fief/tasks/heartbeat.py</code></li> <li><code>fief/scheduler.py</code></li> <li><code>fief/templates/admin/base.html</code></li> </ul>"},{"location":"user-journey/","title":"User journey","text":"<p>In this section, we'll highlight the main features and actions your users will be presented while authenticating with Fief.</p>"},{"location":"user-journey/#registration","title":"Registration","text":"<p>When a user visits your application for the first time, they'll need to register, i.e. create an account on your Fief's tenant.</p> <p>They'll need to fill a form with the following information:</p> <ul> <li>Their email address</li> <li>A password</li> <li>The custom User Fields you configured on your instance.</li> </ul> <p></p> <p>Password strength validation</p> <p>Fief has a built-in algorithm to compute the strength of a password. Only passwords that are at least scored as Acceptable are accepted.</p> <p>When the user has successfully filled the form, they'll need to verify their email address.</p>"},{"location":"user-journey/#social-registration","title":"Social registration","text":"<p>If you configured OAuth Providers, users may be able to register using their social account, like Google or Facebook. They will be taken through the external provider authentication process before being redirected to the registration form to fill their details.</p> <p></p> <p>Sign in with... and Sign up with... doesn't have the same behavior</p> <p>It's important to bear in mind that the social buttons doesn't have the same behavior if they are used from the register or login page. When used from the registration page, they will go through the registration process. If they already had an account, they will get an error stating that their email address is already registered.</p>"},{"location":"user-journey/#login","title":"Login","text":"<p>When a user comes back to your application, they'll need to login again to their account. They'll need to fill the form with their email address and password.</p> <p></p> <p>Once done, they will be redirected to your application, on the redirect URI you specified.</p> <p>Email verification</p> <p>It may happen that an existing account has an unverified email. If so, the user must pass an email verification process, as explained below, to complete login.</p>"},{"location":"user-journey/#social-login","title":"Social login","text":"<p>If you configured OAuth Providers, and if they used it during registration, users will be able to login using their social account, like Google or Facebook. They will be taken through the external provider authentication process before being redirected to your application.</p> <p>Sign in with... and Sign up with... doesn't have the same behavior</p> <p>It's important to bear in mind that the social buttons doesn't have the same behavior if they are used from the register or login page. When used from the login page, Fief will check if an account linked to this social account exists. If not, they will get an error stating that such account does not exist.</p>"},{"location":"user-journey/#email-verification","title":"Email verification","text":"<p>Email verification is crucial to make sure the user has correctly entered their address and that they actually own it. They will automatically receive an email on their inbox with a verification code. Users will need to input this code in the form to verify their address.</p> <p></p> <p>Once done, they will be redirected to your application, on the redirect URI you specified.</p>"},{"location":"user-journey/#forgot-password","title":"Forgot password","text":"<p>It (often) happens that user forget the password they used to register. To solve this situtation, Fief has the classic forgot password mechanism. First, the user needs to input the email address of their account.</p> <p></p> <p>Then, they receive an email on their inbox with a link to reset their password.</p> <p>This form is always successful</p> <p>Even if the user input an email address that does not exist on the tenant, they will be presented with a success message. This is a security measure to avoid malicious users to enumerate existing accounts.</p> <p></p> <p>Password strength validation</p> <p>Fief has a built-in algorithm to compute the strength of a password. Only passwords that are at least scored as Acceptable are accepted.</p> <p>Once done, they are redirected to the login page.</p>"},{"location":"user-journey/#user-dashboard","title":"User dashboard","text":"<p>Fief has built-in account management pages allowing users to manage their information. It's directly accessing from the Base URL of your tenant, e.g. <code>https://fief.mydomain.com</code>.</p>"},{"location":"user-journey/#change-email-address","title":"Change email address","text":"<p>Users can change their email address. To do this, from the Profile section, they can click on the Change button. A form will show up where they can input their new email address and confirm their password.</p> <p></p> <p>To confirm the change, they'll need to verify the email address, in a similar way to what we explain in the Email verification section. This new email address is not saved until the verification process is done.</p>"},{"location":"user-journey/#update-profile","title":"Update profile","text":"<p>If you configured custom User Fields on your instance, users will be able to update them from this page.</p> <p></p>"},{"location":"user-journey/#change-password","title":"Change password","text":"<p>Users can change their password. To do this, from the Password section, they can confirm their old password and input their new one, with a confirmation.</p> <p>Password strength validation</p> <p>Fief has a built-in algorithm to compute the strength of a password. Only passwords that are at least scored as Acceptable are accepted.</p> <p></p>"},{"location":"user-journey/#back-to-application","title":"Back to application","text":"<p>If you configured the Application URL on your tenant, a button is displayed so the user can go back to your application.</p>"},{"location":"api/","title":"Admin API","text":"<p>Fief exposes a REST API allowing you to manage almost everything in your instance programmatically.</p> <p>Clients not available</p> <p>For the time being, we do not provide any official client for this API. However, it's quite simple so it should fairly easy to integrate with your favorite HTTP client.</p>"},{"location":"api/#base-url","title":"Base URL","text":"<p>The Admin API lives under the <code>/admin/api</code> path of your instance:</p> <pre><code>https://fief.mydomain.com/admin/api\n</code></pre>"},{"location":"api/#authentication","title":"Authentication","text":"<p>To authenticate your API requests, you'll need to generate an API Key.</p> <p>Then, you need to pass it as a <code>Bearer</code> credential in the <code>Authorization</code> header.</p> <p>Example</p> <pre><code>curl \\\n-X GET \\\n-H \"Authorization: Bearer ${FIEF_API_KEY}\" \\\nhttps://fief.mydomain.com/admin/api/users/\n</code></pre>"},{"location":"api/#openapi-swagger","title":"OpenAPI &amp; Swagger","text":"<p>The Admin API is documented with OpenAPI and usable interactively with Swagger. It lives under the <code>/admin/api/docs</code> path of your instance:</p> <pre><code>https://fief.mydomain.com/admin/api/docs\n</code></pre>"},{"location":"api/webhooks/events/","title":"Webhook events","text":"<p>You'll find here the supported list of Webhook events and their associated data structure.</p>"},{"location":"api/webhooks/events/#client","title":"Client","text":""},{"location":"api/webhooks/events/#clientcreated","title":"<code>client.created</code>","text":"<p>Occurs whenever a Client is created.</p>"},{"location":"api/webhooks/events/#clientupdated","title":"<code>client.updated</code>","text":"<p>Occurs whenever a Client is updated.</p>"},{"location":"api/webhooks/events/#clientdeleted","title":"<code>client.deleted</code>","text":"<p>Occurs whenever a Client is deleted.</p>"},{"location":"api/webhooks/events/#email-template","title":"Email template","text":""},{"location":"api/webhooks/events/#email_templatecreated","title":"<code>email_template.created</code>","text":"<p>Occurs whenever an Email Template is updated.</p>"},{"location":"api/webhooks/events/#oauth-provider","title":"OAuth Provider","text":""},{"location":"api/webhooks/events/#oauth_providercreated","title":"<code>oauth_provider.created</code>","text":"<p>Occurs whenever an OAuth Provider is created.</p>"},{"location":"api/webhooks/events/#oauth_providerupdated","title":"<code>oauth_provider.updated</code>","text":"<p>Occurs whenever an OAuth Provider is updated.</p>"},{"location":"api/webhooks/events/#oauth_providerdeleted","title":"<code>oauth_provider.deleted</code>","text":"<p>Occurs whenever an OAuth Provider is deleted.</p>"},{"location":"api/webhooks/events/#permission","title":"Permission","text":""},{"location":"api/webhooks/events/#permissioncreated","title":"<code>permission.created</code>","text":"<p>Occurs whenever a Permission is created.</p>"},{"location":"api/webhooks/events/#permissionupdated","title":"<code>permission.updated</code>","text":"<p>Occurs whenever a Permission is updated.</p>"},{"location":"api/webhooks/events/#permissiondeleted","title":"<code>permission.deleted</code>","text":"<p>Occurs whenever a Permission is deleted.</p>"},{"location":"api/webhooks/events/#role","title":"Role","text":""},{"location":"api/webhooks/events/#rolecreated","title":"<code>role.created</code>","text":"<p>Occurs whenever a Role is created.</p>"},{"location":"api/webhooks/events/#roleupdated","title":"<code>role.updated</code>","text":"<p>Occurs whenever a Role is updated.</p>"},{"location":"api/webhooks/events/#roledeleted","title":"<code>role.deleted</code>","text":"<p>Occurs whenever a Role is deleted.</p>"},{"location":"api/webhooks/events/#tenant","title":"Tenant","text":""},{"location":"api/webhooks/events/#tenantcreated","title":"<code>tenant.created</code>","text":"<p>Occurs whenever a Tenant is created.</p>"},{"location":"api/webhooks/events/#tenantupdated","title":"<code>tenant.updated</code>","text":"<p>Occurs whenever a Tenant is updated.</p>"},{"location":"api/webhooks/events/#tenantdeleted","title":"<code>tenant.deleted</code>","text":"<p>Occurs whenever a Tenant is deleted.</p>"},{"location":"api/webhooks/events/#user","title":"User","text":""},{"location":"api/webhooks/events/#usercreated","title":"<code>user.created</code>","text":"<p>Occurs whenever a User is created.</p>"},{"location":"api/webhooks/events/#userupdated","title":"<code>user.updated</code>","text":"<p>Occurs whenever a User is updated.</p>"},{"location":"api/webhooks/events/#userdeleted","title":"<code>user.deleted</code>","text":"<p>Occurs whenever a User is deleted.</p>"},{"location":"api/webhooks/events/#userforgot_password_requested","title":"<code>user.forgot_password_requested</code>","text":"<p>Occurs whenever a User requested to reset their password.</p>"},{"location":"api/webhooks/events/#userpassword_reset","title":"<code>user.password_reset</code>","text":"<p>Occurs whenever a User successfully reset their password.</p>"},{"location":"api/webhooks/events/#user-field","title":"User field","text":""},{"location":"api/webhooks/events/#user_fieldcreated","title":"<code>user_field.created</code>","text":"<p>Occurs whenever a User Field is created.</p>"},{"location":"api/webhooks/events/#user_fieldupdated","title":"<code>user_field.updated</code>","text":"<p>Occurs whenever a User Field is updated.</p>"},{"location":"api/webhooks/events/#user_fielddeleted","title":"<code>user_field.deleted</code>","text":"<p>Occurs whenever a User Field is deleted.</p>"},{"location":"api/webhooks/events/#access-control","title":"Access control","text":""},{"location":"api/webhooks/events/#user_permissioncreated","title":"<code>user_permission.created</code>","text":"<p>Occurs whenever a Permission is granted to a User.</p>"},{"location":"api/webhooks/events/#user_permissiondeleted","title":"<code>user_permission.deleted</code>","text":"<p>Occurs whenever a Permission is revoked from a User.</p>"},{"location":"api/webhooks/events/#user_rolecreated","title":"<code>user_role.created</code>","text":"<p>Occurs whenever a Role is granted to a User.</p>"},{"location":"api/webhooks/events/#user_roledeleted","title":"<code>user_role.deleted</code>","text":"<p>Occurs whenever a Role is revoked from a User.</p>"},{"location":"api/webhooks/guide/","title":"Webhooks integration guide","text":"<p>You'll find in this guide insights and guidelines to integrate webhooks in your application.</p> <p>What is a Webhook?</p> <p>A Webhook is a way for your application to be notified automatically when something happens on your instance.</p> <p>For example, you can configure a Webhook so your application get a notification when a new user registers. This way, you can run your own business logic, like add the user to a mailing list or a marketing tool.</p> <p>Technically, it works with HTTP requests: Fief will make requests to the URL you give it with the relevant data for the event. On your side, you'll need to accept this request and implement the logic you need accordingly.</p>"},{"location":"api/webhooks/guide/#configure-your-webhook","title":"Configure your Webhook","text":"<p>You can create and manage your Webhooks from the admin dashboard. You can read more about it here.</p> <p>They can also be created programmatically using the Admin API, with the <code>/admin/api/webhooks/</code> endpoints.</p> <p>During local development, use a tunnel like Ngrok</p> <p>When developing on your local machine, your server served on <code>localhost</code> is not accessible by Fief on the internet.</p> <p>To ease testing, you can use a tunnel like Ngrok to tunnel your local machine to the internet. You'll get a dedicated URL you can give to Fief so you receive webhook requests directly on your local server.</p>"},{"location":"api/webhooks/guide/#how-webhooks-work","title":"How Webhooks work?","text":"<p>Webhooks are a common technique in web applications to trigger logic and workflows across different applications and processes.</p> <p>They generally work with standard HTTP requests. When an event happens on a service <code>A</code>, thi service will perform an HTTP request to a service <code>B</code> that wants to know about this event. The payload of this request usually consists of a JSON object with information about the event.</p> <p>This approach is performant and easy-to-use because service <code>B</code> only needs to expose an HTTP endpoint and wait for incoming requests. It doesn't need to poll service <code>A</code> to check if something happened.</p> <pre><code>flowchart LR\n    EVENT{{Something happens}}\n    FIEF[Fief]\n    APP[Your app]\n    EVENT -.-&gt; FIEF\n    FIEF -- HTTP --&gt; APP</code></pre>"},{"location":"api/webhooks/guide/#webhooks-security","title":"Webhooks security","text":"<p>As you may have guessed, accepting webhooks involves to expose a public HTTP endpoint on the internet. Since this could be easily guessed by malicious users, they could very well send false events to your application!</p> <p>So, how do we know if a webhook event truly comes for Fief? Several techniques exist, but we chose to implement a signature approach. Basically, we take the payload, i.e. the JSON data of the event and hash it using a cryptography algorithm (<code>HMAC-SHA256</code>) with a secret. This secret is the one you get when you create your Webhook.</p> <p>Then, this signature is sent in the headers of the HTTP request we make to your application. This way, using the same technique, you can compute the very same signature: if they match, it means it's a legitimate request from Fief. If not, this is a malicious request that you should reject \ud83e\udd28</p> <pre><code>flowchart LR\n    subgraph FIEF [Fief]\n        PAYLOAD_FIEF[Payload]\n    end\n    subgraph HTTP [HTTP Request]\n        PAYLOAD_HTTP[Payload]\n        SIG_HTTP[Fief's signature]\n    end\n    subgraph APP [Your app]\n        SIG_APP[Computed signature]\n    end\n    PAYLOAD_FIEF -.-&gt; PAYLOAD_HTTP\n    PAYLOAD_FIEF -. HMAC-SHA256 + Secret .-&gt; SIG_HTTP\n    PAYLOAD_HTTP -. HMAC-SHA256 + Secret .-&gt; SIG_APP\n    SIG_HTTP &lt;-- Do they match? --&gt; SIG_APP</code></pre> <p>Besides this mechanism, Fief adds a timestamp to the request headers. It protects us from replay attacks, where a malicious user could repeat a request they have intercepted before. All we need to do is to reject requests that have a too old timestamp. And to make sure the timestamp is not tampered, it's contatenated to the payload before generating the signature.</p> <pre><code>flowchart LR\n    subgraph FIEF [Fief]\n        PAYLOAD_FIEF[Payload]\n        TIMESTAMP_FIEF[Timestamp]\n        PAYLOAD_TIMESTAMP_FIEF[Payload + Timestamp]\n    end\n    subgraph HTTP [HTTP Request]\n        PAYLOAD_HTTP[Payload]\n        TIMESTAMP_HTTP[Timestamp]\n        SIG_HTTP[Fief's signature]\n    end\n    subgraph APP [Your app]\n        PAYLOAD_TIMESTAMP_APP[Payload + Timestamp]\n        SIG_APP[Computed signature]\n    end\n    PAYLOAD_FIEF -.-&gt; PAYLOAD_TIMESTAMP_FIEF\n    TIMESTAMP_FIEF -.-&gt; PAYLOAD_TIMESTAMP_FIEF\n    PAYLOAD_TIMESTAMP_FIEF -. HMAC-SHA256 + Secret .-&gt; SIG_HTTP\n\n    PAYLOAD_FIEF -.-&gt; PAYLOAD_HTTP\n    TIMESTAMP_FIEF -.-&gt; TIMESTAMP_HTTP\n\n    PAYLOAD_HTTP -.-&gt; PAYLOAD_TIMESTAMP_APP\n    TIMESTAMP_HTTP -.-&gt; PAYLOAD_TIMESTAMP_APP\n\n    PAYLOAD_TIMESTAMP_APP -. HMAC-SHA256 + Secret .-&gt; SIG_APP\n    SIG_HTTP &lt;-- Do they match? --&gt; SIG_APP\n\n    TIMESTAMP_HTTP -- Not too old? --&gt; APP</code></pre>"},{"location":"api/webhooks/guide/#request-specification","title":"Request specification","text":"<p>A Fief's webhook request is a standard HTTP POST request with a JSON payload.</p>"},{"location":"api/webhooks/guide/#headers","title":"Headers","text":""},{"location":"api/webhooks/guide/#x-fief-webhook-timestamp","title":"<code>X-Fief-Webhook-Timestamp</code>","text":"<p>The timestamp at which the request was issued. You shouldn't accept requests older than 5 minutes.</p>"},{"location":"api/webhooks/guide/#x-fief-webhook-signature","title":"<code>X-Fief-Webhook-Signature</code>","text":"<p>The HMAC-SHA256 signature. It's computed by concatenating:</p> <ul> <li>The timestamp</li> <li>The character <code>.</code></li> <li>The raw JSON payload as string</li> </ul> <p>The resulting string is then used to compute an HMAC with the SHA256 hash function and your webhook secret. The result is serialized as an hexadecimal string.</p>"},{"location":"api/webhooks/guide/#json-payload","title":"JSON payload","text":"<p>The payload consists of a JSON object with two keys:</p> <ul> <li><code>event</code>: the name of the event that triggered the webhook</li> <li><code>data</code>: the corresponding data of the event. Usually, it's a representation of the object that has been created, updated or deleted in database.</li> </ul> <p>Example</p> <pre><code>{\n    \"type\": \"user.created\",\n    \"data\": {\n        \"id\": \"de168e87-8b37-4f01-9e02-f7e5244f0be8\"\n        \"email\": \"anne@bretagne.duchy\",\n        \"is_active\": true,\n        \"is_superuser\": false,\n        \"is_verified\": false,\n        \"fields\": {\n            \"first_name\": \"Anne\",\n            \"last_name\": \"De Bretagne\"\n        },\n        \"tenant_id\": \"4c124fb0-048e-448d-b2e7-6ba1bb03ec1\",\n        \"tenant\": {\n            \"id\": \"4c124fb0-048e-448d-b2e7-6ba1bb03ec1\",\n            \"name\": \"Bretagne Duchy\",\n            \"default\": true,\n            \"slug\": \"\",\n            \"registration_allowed\": true,\n            \"theme_id\": null,\n            \"logo_url\": null\n        }\n    }\n}\n</code></pre>"},{"location":"api/webhooks/guide/#response","title":"Response","text":"<p>Your server should return a response with a status in the 200-range.</p>"},{"location":"api/webhooks/guide/#retries","title":"Retries","text":"<p>If your server is unreachable or if it doesn't return a response with a success status code, Fief will try to send again the event 4 times, waiting exponentially more each time.</p> <ul> <li>Attempt 1</li> <li>(wait 15 seconds) Attempt 2</li> <li>(wait 60 seconds) Attempt 3</li> <li>(wait 120 seconds) Attempt 4</li> <li>(wait 240 seconds) Attempt 5</li> </ul> <p>Each attempt is logged, so you can check why the delivery has gone wrong.</p>"},{"location":"api/webhooks/guide/#code-samples","title":"Code samples","text":""},{"location":"api/webhooks/guide/#fastapi","title":"FastAPI","text":"app.py<pre><code>import hmac\nimport json\nimport time\nfrom hashlib import sha256\n\nfrom fastapi import FastAPI, HTTPException, Request, status\n\napp = FastAPI()\n\nSECRET = \"YOUR_WEBHOOK_SECRET\"  # (1)!\n\n\n@app.post(\"/webhook-endpoint\")\nasync def webhook_endpoint(request: Request):\n    timestamp = request.headers.get(\"X-Fief-Webhook-Timestamp\")\n    signature = request.headers.get(\"X-Fief-Webhook-Signature\")\n    payload = (await request.body()).decode(\"utf-8\")  # (2)!\n\n    # Check if timestamp and signature are there\n    if timestamp is None or signature is None:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)\n\n    # Check if timestamp is not older than 5 minutes\n    if int(time.time()) - int(timestamp) &gt; 5 * 60:\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)\n\n    # Compute signature\n    message = f\"{timestamp}.{payload}\"\n    hash = hmac.new(\n        SECRET.encode(\"utf-8\"),\n        msg=message.encode(\"utf-8\"),\n        digestmod=sha256,\n    )\n    computed_signature = hash.hexdigest()\n\n    # Check if the signatures match\n    if not hmac.compare_digest(signature, computed_signature):\n        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED)\n\n    # Good to go!\n    data = json.loads(payload)\n    print(data)\n</code></pre> <ol> <li> <p>Your Webhook secret</p> <p>Don't forget to replace this with your own Webhook secret: this is how you'll be able to compute the proper signature.</p> <p>For security, you should set it in an environment variable so it doesn't get committed with your code.</p> </li> <li> <p>Retrieve the raw payload</p> <p>It's important that you retrieve the raw payload instead of the parsed representation returned by your framework.</p> <p>Otherwise, we can't be sure we have the exact same string representation that were used when computing the original signature.</p> </li> </ol>"},{"location":"api/webhooks/guide/#whats-next","title":"What's next?","text":"<p>You can now receive notifications directly from Fief in your application! We can't wait to see the clever integrations and workflows you'll build.</p> <p>To have more details about the different events and their structure, be sure to check the Webhook events documentation.</p>"},{"location":"configure/","title":"Admin dashboard","text":"<p>The admin dashboard is the interface where you'll be able to manage your Fief instance and configuration.</p> <p></p> <p>The left menu lets you access to the most important aspects of Fief:</p> <ul> <li>Tenants</li> <li>Clients</li> <li>OAuth Providers</li> <li>Users</li> <li>User fields</li> <li>Access control</li> <li>Customization<ul> <li>Themes</li> <li>Email templates</li> </ul> </li> <li>API Keys</li> </ul>"},{"location":"configure/access-control/","title":"Access control","text":"<p>This is where you'll see and manage the permissions and roles of your instance.</p> <p>What are permissions and roles?</p> <p>Permissions are a way to list the actions a user will be allowed to perform in your application. For example, if you have a resource in your application called Castle, we can define the permissions Read Castle and Create Castle.</p> <p>Then, those permissions can be assigned to users. You'll then be able to control this list of permissions in your app to determine if the current user is able to perform the action they request.</p> <p>Assigning permissions directly to users can be tedious and error-prone. To help with this, Fief also supports the concept of Roles. A role consists of a set of permissions. Following our previous example, we can imagine to have the roles Castle Visitor, which only have the Read Castle permission and a Castle Manager role, which have both Read Castle and Create Castle permissions.</p> <p>Those roles can also be assigned to users. Then, they'll be automatically granted with the set of associated permissions. The good thing is that if you modify a role to add or remove permissions, it'll be automatically be passed on every users with this role. Said another way, it's a way to easily organize and assign permissions.</p>"},{"location":"configure/access-control/#permissions","title":"Permissions","text":"<p>The first item in the menu is the permissions page, showing you a list of all your permissions.</p> <p></p>"},{"location":"configure/access-control/#create-a-new-permission","title":"Create a new permission","text":"<p>To create a new permission, fill the fields above the list: the name and the codename of your permission. The codename is what will be used to identify your permission in the access tokens. It must be unique across your instance.</p> <p></p> <p>Submit the form by clicking on Create Permission. The newly created permission will appear in the list.</p> <p>Naming your permissions</p> <p>You are completely free to choose the name and codenames you wish for your permissions. However, we suggest you to establish a convention so it'll be easy for you and your teams to remember them.</p> <p>Typically, you'll have a common set of actions (read, create, update, delete...) for each resources (Post, Product, Meeting...) in your app. A common practice is to prefix the codename with the name of the resource and append the corresponding action: <code>post:read</code>, <code>post:create</code>, <code>post:update</code>...</p>"},{"location":"configure/access-control/#delete-a-permission","title":"Delete a permission","text":"<p>If one of your permission is not useful anymore, you can delete it by clicking on the Delete button in the list.</p> <p></p> <p>The permission will be removed from all the associated roles and users</p> <p>When you delete a permission, it'll be removed from all the roles associated to this permission and all the users who were granted this permission. Before deleting it, make sure you don't need it anymore in your application.</p>"},{"location":"configure/access-control/#roles","title":"Roles","text":"<p>The second item in the menu is the roles page, showing you a list of all your roles.</p> <p></p>"},{"location":"configure/access-control/#create-a-new-role","title":"Create a new role","text":"<p>You can create a new role by clicking the Create Role button. A modal will open where you'll be able to input its name, if it's granted by default and its list of associated permissions.</p> <p></p>"},{"location":"configure/access-control/#edit-an-existing-role","title":"Edit an existing role","text":"<p>If you click on one of the role in the list, you'll see its details on the right. You'll be able to edit its name, granted by default option and associated permissions.</p> <p></p> <p>Permissions are automatically propagated to users with this role</p> <p>If you add or remove a permission from a role, the permissions of the users having this role will also be updated accordingly.</p>"},{"location":"configure/access-control/#delete-a-role","title":"Delete a role","text":"<p>If one of your role is not useful anymore, you can delete it by clicking on it on the list and click on the Delete button on the right.</p> <p></p> <p>The role will be removed from all the associated users</p> <p>When you delete a role, it'll be removed from all the users who were granted this role. Before deleting it, make sure you don't need it anymore in your application.</p>"},{"location":"configure/access-control/#granted-by-default","title":"Granted by default","text":"<p>When you mark a role as Granted by default, it'll be automatically assigned to new users upon their registration. It's especially useful if you need your users to be able to perform basic actions directly on signup.</p>"},{"location":"configure/api-keys/","title":"API Keys","text":"<p>This is where you'll see and manage the api keys of your instance.</p> <p>What is an API key?</p> <p>An API key is a secret token that'll allow you to make authenticated requests to the Fief Admin API.</p> <p>It'll be useful if you need, for example, to manage tenants or clients programmatically from your own application.</p> <p>Keep it secret and safe</p> <p>An API key gives complete accesss to your instance data. Keep it somewhere safe and don't share it with anyone.</p> <p></p>"},{"location":"configure/api-keys/#create-a-new-api-key","title":"Create a new API Key","text":"<p>To create a new API Key, click on the Create API Key button. A modal will open where you'll be able to input the name of the API Key. Choose a name that'll help you remember where and how it's used.</p> <p></p> <p>When you submit the form, a new modal will open with the actual API key token. For security reasons, it'll be shown only once. Copy and paste it somewhere safe before closing the modal.</p> <p></p>"},{"location":"configure/api-keys/#delete-an-api-key","title":"Delete an API Key","text":"<p>If one of your API Key is not useful anymore, you can delete it by clicking on the Delete button in the list.</p> <p></p>"},{"location":"configure/clients/","title":"Clients","text":"<p>This is where you'll see and manage the clients of your instance.</p> <p>What is a client?</p> <p>A client is a central part of the OAuth2 protocol. It's the definition of an application authorized to request for access tokens and user information on Fief. In other words, your application will need one of those client to be able to authenticate users from your Fief instance.</p> <p>Each client has a Client ID and a Client Secret. Those values are used during OAuth2 authentification to recognize the client.</p> <p>Each instance comes with one client, tied to the default tenant.</p> <p></p>"},{"location":"configure/clients/#view-client-details","title":"View client details","text":"<p>If you click on one of the client in the list, you'll see its details on the right. Especially, you'll be able to copy its ID and Secret by using the clipboard buttons.</p> <p></p>"},{"location":"configure/clients/#create-a-new-client","title":"Create a new client","text":"<p>You can create a new client by clicking the Create Client button. A modal will open where you'll be able to input its name, if it's a first-party, its type, its redirect URIs and its associated tenant.</p> <p></p> <p>When should I create a new client?</p> <p>If you have several applications authenticating to your Fief instance, you should consider creating new clients. Typically, if you have both a web and a mobile application, it's usually a good idea to have a client for each one.</p> <p>This way, it's easier to track down where the tokens come from and mitigates the risk of compromising data if one of the application has a security breach.</p>"},{"location":"configure/clients/#edit-an-existing-client","title":"Edit an existing client","text":"<p>You can edit an existing client by opening its details and click on the Edit Client button. A modal will open where you'll be able to change its name, if it's a first-party its type and its redirect URIs.</p> <p></p>"},{"location":"configure/clients/#delete-a-client","title":"Delete a client","text":"<p>If one your client is not useful anymore, you can delete it by clicking on it on the list and click on the Delete button on the right.</p> <p></p> <p>Applications using this client won't be able to authenticate users anymore</p> <p>Since your applications need a Client ID and Secret to authenticate users, be sure you don't need this client anymore before deleting it.</p>"},{"location":"configure/clients/#first-party-clients","title":"First-party clients","text":"<p>You probably noticed that your first client has a first-party badge. It means that this client is intended to be used by your own, official application.</p> <p>In this context, when users log in to your application, the traditional OAuth2 consent screen is bypassed. Since you are the developer of the application, it makes sense to not ask the user for their consent to use their data on the same application!</p> <p>For third-party applications, like developers from another company who want to integrate your API in their product, you'll provide them a client without this first-party flag. In this context, we want the user consent to be explicit.</p>"},{"location":"configure/clients/#client-type","title":"Client type","text":"<p>OAuth2 protocol defines two types of clients, depending on the context they will be used.</p> <ul> <li>Confidential: clients where we can guarantee the safety of the client secret. It's suitable for server-based applications like Python or Node.js web applications.</li> <li>Public: clients where the client secret would be exposed to the end-user. It's the case for browser-based JavaScript applications and mobile applications.</li> </ul>"},{"location":"configure/clients/#public-clients","title":"Public clients","text":"<p>For public clients, we consider that the client secret can never be safe. It's indeed fairly easy to find it in the JavaScript source code or in the application package. Therefore, it's recommended to not use it at all in your application.</p> <p>Fief will allow public clients to make token request without the client secret. However, it'll require a PKCE challenge for maximum security.</p>"},{"location":"configure/clients/#redirect-uris","title":"Redirect URIs","text":"<p>During an OAuth2 authentication flow, after the user has successfully logged in, Fief will redirect them to your application with a temporary code. At that point, your application will use this temporary code to obtain a valid token.</p> <p>For security reasons, Fief won't allow the user to be redirected to any URI. Instead, you have to explicitly allow every URI you'll need in your applications.</p> <p>For HTTP URIs, they need to use the <code>https</code> scheme; <code>http</code> URL are not allowed. The only exception to this rule is <code>localhost</code>, which can be in <code>http</code> for local development purposes.</p>"},{"location":"configure/clients/#authorization-code-and-tokens-lifetime","title":"Authorization code and tokens lifetime","text":"<p>Authorization codes are temporary codes generated during the OAuth2 authentication flow. Access tokens, ID tokens and refresh tokens are generated after a successful OAuth2 authentication flow.</p> <p>You can customize the lifetime of each one them by clicking on the Lifetimes tab from a client's details.</p> <p></p> <p>Make sure you know what're you doing</p> <p>The default values provided should be enough for most applications and give a good balance between usability and security. Please make sure you understand all the consequences before modifying those values.</p>"},{"location":"configure/oauth-providers/","title":"OAuth Providers","text":"<p>This is where you'll see and manage the OAuth Providers of your instance.</p> <p>What is an OAuth Provider?</p> <p>An OAuth Provider is an external service allowing your users to quickly authenticate to your application by using their existing account on this service. If you used buttons like Sign in with Google or Sign up with Facebook before, you probably understand what it means!</p> <p></p> <p>Basically, since most people already have an account on big social networks or websites like Google, Facebook, Discord or Microsoft, they can use it to sign in to your service without having to create yet another account with yet another password.</p> <p>With Fief, you can easily add those authentication methods to your instance. Corresponding buttons will be shown on the login and registration pages.</p> <p></p>"},{"location":"configure/oauth-providers/#create-a-new-oauth-provider","title":"Create a new OAuth Provider","text":"<p>You can create a new OAuth Provider by clicking the Create OAuth Provider button. A modal will open where you'll be able to input its different properties.</p> <p>You can choose the Provider from the list of available providers, a custom name and scopes.</p> <p>The most important part is the Client ID and Client Secret: it allows to uniquely identify your application on the OAuth Provider. That's why you need to \"declare\" it beforehand on their service. We provide guidelines on how to create and configure a client on the OAuth Providers we support.</p> <p></p> <p>Don't forget to enable it on your tenant</p> <p>OAuth Providers are enabled per tenant, so you can finely customize which authentication methods can be used on each one. To do so, edit your tenant and enable the OAuth Provider.</p>"},{"location":"configure/oauth-providers/#edit-an-existing-oauth-provider","title":"Edit an existing OAuth Provider","text":"<p>If you click on one of the OAuth Provider in the list, you'll see its details on the right and be able to change its properties.</p> <p></p>"},{"location":"configure/oauth-providers/#delete-an-existing-oauth-provider","title":"Delete an existing OAuth Provider","text":"<p>If one of your OAuth Provider is not useful anymore, you can delete it: click on the one you want to delete in the list and click on the Delete button.</p> <p></p> <p>Associated OAuth accounts will be deleted as well</p> <p>When you delete a provider, the associated OAuth accounts will be deleted as well. The associated users won't be deleted, but they will have to sign in with another method.</p>"},{"location":"configure/oauth-providers/#scopes","title":"Scopes","text":"<p>For each OAuth Providers you define, you'll be able to specify the list of scopes you want to ask when the user authenticates to the external service.</p> <p>Those scopes tell the actions and data your application will be able to interact with on the external service API. For example, you might ask to get access to the Google Calendar of the user so your application can automatically add meetings to their agenda.</p> <p>Each provider has its own list of scopes, corresponding to specific parts of the API.</p> <p>Fief already asks for basic scopes</p> <p>If you just want to authenticate users and nothing more, you can leave the scopes list empty. Fief takes care of asking for the scopes needed to authenticate the user and get their basic profile.</p>"},{"location":"configure/oauth-providers/#supported-oauth-providers","title":"Supported OAuth Providers","text":"<p>Currently, Fief supports the following OAuth Providers. You'll find below steps to configure your application integration on those platforms.</p>"},{"location":"configure/oauth-providers/#discord","title":"Discord","text":"<ul> <li>Go to: https://discord.com/developers/applications</li> <li>Click on New Application and type the name of your application/website.</li> <li>Go to the OAuth2 menu on the left.</li> <li>Copy the Client ID and paste it into Fief.</li> <li>Click on Reset Secret to generate a new client secret. Copy and paste it into Fief.</li> <li>Below, add your Redirect URI.</li> </ul> <p>What is my Redirect URI?</p> <p>For security purposes, OAuth2 protocol requires the redirect URI to be declared upfront. Since Fief will handle OAuth2 authentication for you, the redirect URI will target the Fief server.</p> <p>If your instance URL is https://fief.mydomain.com, your redirect URI will be:</p> <pre><code>https://fief.mydomain.com/oauth/callback\n</code></pre> <p>This URL is common for every tenants. So you don't have to worry about it if you add new tenants, Fief will handle it automatically.</p> <p></p>"},{"location":"configure/oauth-providers/#facebook","title":"Facebook","text":"<ul> <li>Go to: https://developers.facebook.com/apps/create/</li> <li>Select Consumer as app type.</li> <li>In Display name, type the name of your application/website.</li> <li>When the application is created, click on Add product in the left menu and in the Facebook Login box, click Set up.</li> <li>You don't need to go through the quickstart, just click on Settings in the left menu, right under Facebook Login.</li> <li>Add your Redirect URI in the field Valid OAuth Redirect URIs.</li> <li>You can find your Client ID and Client Secret (called App ID and App secret here) in the Settings \u27a1\ufe0f Basic menu. Copy and paste it into Fief.</li> </ul> <p>What is my Redirect URI?</p> <p>For security purposes, OAuth2 protocol requires the redirect URI to be declared upfront. Since Fief will handle OAuth2 authentication for you, the redirect URI will target the Fief server.</p> <p>If your instance URL is https://fief.mydomain.com, your redirect URI will be:</p> <pre><code>https://fief.mydomain.com/oauth/callback\n</code></pre> <p>This URL is common for every tenants. So you don't have to worry about it if you add new tenants, Fief will handle it automatically.</p> <p> </p> <p>Live mode</p> <p>By default, Facebook apps are in development mode, so only you can use it. When you're ready to go in production, click on Live toggle on top. Facebook will require you to provide a link to a Privacy Policy and will manually review your app.</p>"},{"location":"configure/oauth-providers/#github","title":"GitHub","text":"<ul> <li>Go to: https://github.com/settings/apps/new</li> <li>In GitHub App name, type the name of your application/website.</li> <li>In Homepage URL, type the URL of your application/website.</li> <li>In Callback URL, add your Redirect URI.</li> <li>Ensure Expire user authorization tokens and Request user authorization (OAuth) during installation are checked.</li> <li>By default Webhook is enabled. If use GitHub just for authenticating users, you can disable it.</li> <li>In the User permissions list, make sure Email addresses has Read-only access.</li> <li>Finally, at the bottom, select Any account to make your app available to any user.</li> <li>On the app settings, copy the Client ID and paste it into Fief.</li> <li>Click on Generate a new client secret. Copy and paste it into Fief.</li> </ul> <p>What is my Redirect URI?</p> <p>For security purposes, OAuth2 protocol requires the redirect URI to be declared upfront. Since Fief will handle OAuth2 authentication for you, the redirect URI will target the Fief server.</p> <p>If your instance URL is https://fief.mydomain.com, your redirect URI will be:</p> <pre><code>https://fief.mydomain.com/oauth/callback\n</code></pre> <p>This URL is common for every tenants. So you don't have to worry about it if you add new tenants, Fief will handle it automatically.</p> <p></p>"},{"location":"configure/oauth-providers/#google","title":"Google","text":"<ul> <li>Go to: https://console.cloud.google.com/apis/credentials/oauthclient</li> <li>If it's the first time you go to the Google Cloud Console, you'll have to create a new project.</li> <li>If you never did it before, you'll be asked to configure your consent screen. Click on Configure consent screen.</li> <li>Select External as User Type.</li> <li>In App name, type the name of your application/website.</li> <li>In User support email, type your support email address.</li> <li>You can provide a logo and links to your legal terms.</li> <li>In Authorized domains, add the top-level domain of your Fief instance, e.g. mydomain.com.</li> <li>In Developer contact information, type your developer email address.</li> <li>In Scopes, click on Add or remove scopes and select the three following scopes:<ul> <li><code>/auth/userinfo.email</code></li> <li><code>/auth/userinfo.profile</code></li> <li><code>openid</code></li> </ul> </li> <li>In Test users, you can add your own email address and the ones of your colleagues. While the app has not been approved, only those emails will be allowed to use it.</li> <li>Once done, you can go back to https://console.cloud.google.com/apis/credentials/oauthclient.</li> <li>Choose Web application as Application type.</li> <li>In Name, type a name to recognize this client. For example, Fief Client.</li> <li>In Authorized redirect URIs, add your Redirect URI.</li> <li>Your Client ID and Client Secret will then appear in a modal. Copy and paste them into Fief.</li> <li>If not already, you should enable the People API in your Google Cloud project. Go to https://console.developers.google.com/apis/api/people.googleapis.com/overview and click on Enable.</li> </ul> <p>What is my Redirect URI?</p> <p>For security purposes, OAuth2 protocol requires the redirect URI to be declared upfront. Since Fief will handle OAuth2 authentication for you, the redirect URI will target the Fief server.</p> <p>If your instance URL is https://fief.mydomain.com, your redirect URI will be:</p> <pre><code>https://fief.mydomain.com/oauth/callback\n</code></pre> <p>This URL is common for every tenants. So you don't have to worry about it if you add new tenants, Fief will handle it automatically.</p> <p> </p> <p>Production mode</p> <p>By default, your consent screen is in testing mode, so only the test users can use it. When you're ready to go in production, click on the Publish app button. Google will require you to provide some explanations about what you're doing with the app and manually review it. They are picky, so make sure to add lot of details and videos of how your app works.</p>"},{"location":"configure/oauth-providers/#linkedin","title":"LinkedIn","text":"<ul> <li>Go to: https://www.linkedin.com/developers/apps/new</li> <li>In App name, type the name of your application/website.</li> <li>You need to have a LinkedIn company page associated. If you don't have one, create one before.</li> <li>In App logo, add your application/website logo.</li> <li>In the Auth tab, you can find your Client ID and Client Secret. Copy and paste them into Fief.</li> <li>Below, in Authorized redirect URLs for your app, add your Redirect URI.</li> </ul> <p>What is my Redirect URI?</p> <p>For security purposes, OAuth2 protocol requires the redirect URI to be declared upfront. Since Fief will handle OAuth2 authentication for you, the redirect URI will target the Fief server.</p> <p>If your instance URL is https://fief.mydomain.com, your redirect URI will be:</p> <pre><code>https://fief.mydomain.com/oauth/callback\n</code></pre> <p>This URL is common for every tenants. So you don't have to worry about it if you add new tenants, Fief will handle it automatically.</p> <p></p>"},{"location":"configure/oauth-providers/#microsoft","title":"Microsoft","text":"<ul> <li>Go to: https://portal.azure.com/#view/Microsoft_AAD_RegisteredApps/CreateApplicationBlade/quickStartType~/null/isMSAApp~/true<ul> <li>If you don't have an Azure account, you'll be asked to create one.</li> </ul> </li> <li>In Name, type the name of your application/website.</li> <li>In Supported account types, select Accounts in any organizational directory (Any Azure AD directory - Multitenant) and personal Microsoft accounts (e.g. Skype, Xbox). This will allow any kind of Microsoft users to authenticate.</li> <li>In Redirect URI, add your Redirect URI with the type Web.</li> <li>You can find your Client ID (called Application ID here) in the Overview. Copy and paste them into Fief.</li> <li>Click on Certificates &amp; secrets on the left menu. In the Client secrets tab, click on New client secret.</li> <li>In Description, type a name to recognize this secret. For example, Fief client.</li> <li>In Expires, choose the lifetime duration of this secret. You can choose 24 months.</li> <li>Copy the Value of the client secret. Paste it into Fief.</li> </ul> <p>What is my Redirect URI?</p> <p>For security purposes, OAuth2 protocol requires the redirect URI to be declared upfront. Since Fief will handle OAuth2 authentication for you, the redirect URI will target the Fief server.</p> <p>If your instance URL is https://fief.mydomain.com, your redirect URI will be:</p> <pre><code>https://fief.mydomain.com/oauth/callback\n</code></pre> <p>This URL is common for every tenants. So you don't have to worry about it if you add new tenants, Fief will handle it automatically.</p> <p> </p> <p>Client Secret expires</p> <p>The Client Secret expires after the duration you set when creating it. When it happens, remember to generate a new one and update it in Fief; otherwise, users won't be able to authenticate with their Microsoft account.</p>"},{"location":"configure/oauth-providers/#reddit","title":"Reddit","text":"<ul> <li>Go to: https://www.reddit.com/prefs/apps<ul> <li>The page is bugged and ugly but don't worry, it's normal \ud83d\ude05</li> </ul> </li> <li>Click on the button are you a developer? create an app...</li> <li>In name, type the name of your application/website.</li> <li>Select web app as type.</li> <li>In redirect uri, add your Redirect URI.</li> <li>Your Client ID is right under the name of the application. Copy and paste it into Fief.</li> <li>The field named secret is your Client Secret. Copy and paste it into Fief.</li> </ul> <p>What is my Redirect URI?</p> <p>For security purposes, OAuth2 protocol requires the redirect URI to be declared upfront. Since Fief will handle OAuth2 authentication for you, the redirect URI will target the Fief server.</p> <p>If your instance URL is https://fief.mydomain.com, your redirect URI will be:</p> <pre><code>https://fief.mydomain.com/oauth/callback\n</code></pre> <p>This URL is common for every tenants. So you don't have to worry about it if you add new tenants, Fief will handle it automatically.</p> <p> </p>"},{"location":"configure/oauth-providers/#generic-openid","title":"Generic OpenID","text":"<p>Fief is compatible with any OpenID Connect compliant identity providers. All you need to give is:</p> <ul> <li>The OpenID configuration endpoint. Usually, the path looks like this: https://auth.provider.com/.well-known/openid-configuration.</li> <li>The Client ID and Client Secret.</li> </ul> <p>On the OpenID provider side, don't forget to add your Redirect URI.</p> <p>What is my Redirect URI?</p> <p>For security purposes, OAuth2 protocol requires the redirect URI to be declared upfront. Since Fief will handle OAuth2 authentication for you, the redirect URI will target the Fief server.</p> <p>If your instance URL is https://fief.mydomain.com, your redirect URI will be:</p> <pre><code>https://fief.mydomain.com/oauth/callback\n</code></pre> <p>This URL is common for every tenants. So you don't have to worry about it if you add new tenants, Fief will handle it automatically.</p>"},{"location":"configure/tenants/","title":"Tenants","text":"<p>This is where you'll see and manage the tenants of your instance.</p> <p>What is a tenant?</p> <p>A tenant is a sub-division of your instance. Each client and user is tied to a specific tenant.</p> <p>This is mostly useful if you want to create a product sold in white-label where each of your client has its own space. It allows for example for a user to have several accounts with the same email address inside one instance, but actually tied to different tenants. From a user point-of-view, this is a different application on which they login with different credentials.</p> <p>If you don't plan to do this, that's okay: you'll always use a single tenant in your instance.</p> <p>Each instance has at least one default tenant.</p> <p></p>"},{"location":"configure/tenants/#base-url","title":"Base URL","text":"<p>Each tenant is tied to a base URL: each routes, like login or registration, will be derived from this base. When you integrate Fief in your application, you'll need this base URL.</p> <p>Each instance has one default tenant with a base URL pointing to your root domain, like https://fief.mydomain.com.</p> <p>Other tenants gets a path prefix, like https://fief.mydomain.com/other-tenant.</p> <p>Tip</p> <p>You can copy the base URL directly using the clipboard button in the list.</p>"},{"location":"configure/tenants/#create-a-new-tenant","title":"Create a new tenant","text":"<p>You can create a new tenant by clicking the Create Tenant button. A modal will open where you'll be able to input:</p> <ul> <li>Its name.</li> <li>If user registration is allowed.</li> </ul> <p>The base URL is automatically generated from the name.</p> <p>Optionally, you can also set:</p> <ul> <li>A logo URL that will be shown on the top-left of authentication pages.</li> <li>Your application URL. It's used to show a link going back to your application on the user dashboard.</li> <li>A UI theme to use when users authenticate with this tenant. If left empty, the theme set as default is used.</li> <li>The list of OAuth Providers allowed to be used on this tenant.</li> </ul> <p></p>"},{"location":"configure/tenants/#edit-an-existing-tenant","title":"Edit an existing tenant","text":"<p>If you click on one of the tenant in the list, you'll see its details on the right.</p> <p></p> <p>If you click on the Edit Tenant button, you'll be able to update its properties.</p> <p></p>"},{"location":"configure/tenants/#disable-user-registration","title":"Disable user registration","text":"<p>You can choose to disable user registration on a tenant. To do this, you have to uncheck the Registration allowed checkbox in the tenant details.</p> <p>When registration is disabled, users can't access the registration page and create a new account on this tenant.</p>"},{"location":"configure/tenants/#delete-a-tenant","title":"Delete a tenant","text":"<p>If one your tenant is not useful anymore, you can delete it by clicking on it on the list and click on the Delete button on the right.</p> <p></p> <p>Users and clients will be removed as well</p> <p>When you delete a tenant, all its associated users and clients will be deleted as well. The data won't be recoverable. Be sure of what you're doing!</p>"},{"location":"configure/tenants/#transactional-emails","title":"Transactional emails","text":"<p>Quite often, Fief needs to send emails to your users, like welcome email or forgot password emails. The layout and content of those emails can be customized, as explained in the Email templates section.</p> <p>Of course, those emails need to be sent by a specific email address and name, the From part of an email. By default, they will be sent by the address defined globally on your instance.</p> <p>You can however customize per tenant this in the Email tab of a tenant. Fill the From name and From email with a valid name and email address and click on Update.</p> <p></p>"},{"location":"configure/tenants/#domain-authentication","title":"Domain authentication","text":"<p>To allow the Fief server to send emails on your behalf, you need to authenticate your email domain. For this, you'll have to set some DNS records on your domain registrar.</p> <p>Click on Manage domain authentication to see the list of DNS records you need to set. Once done, click on the Verify button to validate that you correctly set the DNS records.</p> <p></p> <p>This feature is only supported with SendGrid</p> <p>If you self-host your Fief server, please note that only the SendGrid provider supports domain authentication from the admin dashboard. If you use SMTP or Postmark, you should manually authenticate your domain.</p>"},{"location":"configure/user-fields/","title":"User fields","text":"<p>This is where you'll see and manage the custom user fields of your instance.</p> <p>What is a user field?</p> <p>Most of the time, you'll need to store data about your users, e.g., their first and last names, their birthdate, their newsletter preferences, etc. Your application will probably need to have quite a lot of data about them!</p> <p>To help you with this, Fief allows you to create custom user fields. Each one will have a name, an identifier and a type.</p> <p>Each user will have attached its values for those fields. They will be available directly through the ID token or through the <code>/userinfo</code> endpoint.</p> <p></p>"},{"location":"configure/user-fields/#create-a-new-user-field","title":"Create a new user field","text":"<p>You can create a new client by clicking the Create User field button. A modal will open where you'll be able to input its different properties.</p> <p></p>"},{"location":"configure/user-fields/#edit-an-existing-user-field","title":"Edit an existing user field","text":"<p>If you click on one of the user field in the list, you'll see its details on the right and be able to change its properties.</p> <p></p>"},{"location":"configure/user-fields/#delete-an-existing-user-field","title":"Delete an existing user field","text":"<p>If one of your user field is not useful anymore, you can delete it: click on the user field you want to delete in the list and click on the Delete button.</p> <p></p> <p>Associated user values will be deleted as well</p> <p>When you delete a user field, the associated data on the user will also be deleted. Make sure you don't need this information anymore or that you saved it somewhere else before proceeding.</p>"},{"location":"configure/user-fields/#user-field-properties","title":"User field properties","text":"<p>User fields can be configured through their properties.</p>"},{"location":"configure/user-fields/#name","title":"Name","text":"<p>This is the name of your user field. It'll be used as label in the registration form and in the admin dashboard.</p>"},{"location":"configure/user-fields/#slug","title":"Slug","text":"<p>This will be the identifier of the field in the ID token and in API responses.</p> <p>By default, it'll be automatically generated from the name, but you can customize it at will.</p> <p>The slug is unique in an instance</p> <p>Each field should have a unique identifier. If you try to create a new user field with a slug that already exists, an error will be raised.</p>"},{"location":"configure/user-fields/#type","title":"Type","text":"<p>This is probably the most important setting for your user field. It'll determine the type of data you want to store. We currently support n types:</p>"},{"location":"configure/user-fields/#string","title":"String","text":"<p>Common type for textual values. Examples:</p> <ul> <li>A first or last name</li> <li>A company name</li> <li>A tagline</li> </ul> <p>It'll be shown as a simple text input in forms.</p>"},{"location":"configure/user-fields/#integer","title":"Integer","text":"<p>Type to store integer values. Examples:</p> <ul> <li>A reputation score</li> <li>An height</li> <li>An age</li> </ul> <p>It'll be shown as a numeric input in forms.</p>"},{"location":"configure/user-fields/#boolean","title":"Boolean","text":"<p>Type to store boolean values. Examples:</p> <ul> <li>Subscription status to a newsletter</li> <li>Terms consent</li> <li>A validation status</li> </ul> <p>It'll be shown as a checkbox in forms.</p>"},{"location":"configure/user-fields/#choice","title":"Choice","text":"<p>Type accepting a predefined set of values. Examples:</p> <ul> <li>A gender</li> <li>A job sector</li> <li>A level of experience</li> </ul> <p>When selecting this type, you'll be able to configure the allowed choices.</p> <p></p> <p>Each choice consists of two things: the value (<code>A</code>), which is the actual underlying value that will be stored in database and returned in the user data, and the label (<code>Choice A</code>) which will be used to show a user-friendly label in forms and the admin dashboard.</p> <p>It'll be shown as a select menu in forms.</p>"},{"location":"configure/user-fields/#phone-number","title":"Phone number","text":"<p>Type that'll validate if the value is a valid phone number. It shall be formatted with the international country code, <code>+331020405</code>.</p> <p>It'll be shown as a text input in forms.</p>"},{"location":"configure/user-fields/#address","title":"Address","text":"<p>Type that'll display several inputs to validate a full postal address.</p> <p></p>"},{"location":"configure/user-fields/#timezone","title":"Timezone","text":"<p>Type that'll display a list of valid timezones.</p>"},{"location":"configure/user-fields/#default","title":"Default","text":"<p>For some types, you can define a default value.</p> <p>If the field is shown in a form, the field will automatically be pre-filled with this value.</p> <p>If the field is not presented in a form, this value will be automatically assigned to new users when they register.</p>"},{"location":"configure/user-fields/#ask-at-registration","title":"Ask at registration","text":"<p>If checked, the user field will be presented in the user registration form.</p>"},{"location":"configure/user-fields/#ask-at-update","title":"Ask at update","text":"<p>If checked, the user will be able to update its value through the <code>/profile</code> API.</p> <p>Private field</p> <p>In some cases, you need values that can't be set by the user, e.g., an onboarding status or a reputation score.</p> <p>To do this, you can simply uncheck both Ask at registration and Ask at update field.</p> <p>You'll always be able to update this value through the admin dashboard or the Admin API.</p>"},{"location":"configure/user-fields/#required","title":"Required","text":"<p>If checked, the value will have to be filled when presented in forms.</p> <p>Required boolean field</p> <p>You can set a user field of type Boolean as required. In this case, the value must be True.</p> <p>It can be useful for consent checkbox where you need the user to accept the terms before creating its account.</p>"},{"location":"configure/users/","title":"Users","text":"<p>This is where you'll see and manage the users of your instance.</p> <p>What is a user?</p> <p>A user is the fundamental part of your Fief instance: it represents the actual user that'll have access to your application!</p> <p>We store basic information about the user, like its email address and hashed password and take care of verifying its credentials upon login.</p> <p>Every user is tied to a tenant. It means that an individual can have several user accounts on your instance, with the same email address, but tied to a different tenant.</p> <p></p>"},{"location":"configure/users/#create-a-new-user","title":"Create a new user","text":"<p>In some circumstances, you might need to create a user manually from the admin dashboard. You can do so by clicking on the Create User button. A modal will open where you'll be able to input its email address, password and associated tenant.</p> <p>You'll also be able to fill the values for your custom user fields.</p> <p></p> <p>Info</p> <p>User created that way will receive the welcome email, as if they registered themselves.</p>"},{"location":"configure/users/#edit-an-existing-user","title":"Edit an existing user","text":"<p>If you click on one of the user in the list, you'll see its details on the right and be able to update them.</p> <p></p> <p>If you click on the Edit User button, you'll be able to update its properties.</p> <p></p>"},{"location":"configure/users/#delete-a-user","title":"Delete a user","text":"<p>You can delete a user by clicking on it on the list and click on the Delete button on the right.</p> <p></p>"},{"location":"configure/users/#assign-roles-and-permissions-to-a-user","title":"Assign roles and permissions to a user","text":"<p>What are permissions and roles?</p> <p>Permissions are a way to list the actions a user will be allowed to perform in your application. For example, if you have a resource in your application called Castle, we can define the permissions Read Castle and Create Castle.</p> <p>Then, those permissions can be assigned to users. You'll then be able to control this list of permissions in your app to determine if the current user is able to perform the action they request.</p> <p>Assigning permissions directly to users can be tedious and error-prone. To help with this, Fief also supports the concept of Roles. A role consists of a set of permissions. Following our previous example, we can imagine to have the roles Castle Visitor, which only have the Read Castle permission and a Castle Manager role, which have both Read Castle and Create Castle permissions.</p> <p>Those roles can also be assigned to users. Then, they'll be automatically granted with the set of associated permissions. The good thing is that if you modify a role to add or remove permissions, it'll be automatically be passed on every users with this role. Said another way, it's a way to easily organize and assign permissions.</p> <p>Fief allows you to define permissions and roles to determine what your users are allowed to do or not in your application. From the dashboard, you are able to assign permissions and roles to users.</p>"},{"location":"configure/users/#assign-a-role","title":"Assign a role","text":"<p>You can assign a role to a user by clicking on it in the list. It details will open on the right. Click on the Roles tab to see the roles they already have. From here, you can look for roles in the select menu. Click on Add role to assign it to the user.</p> <p></p> <p>Asssociated permissions are automatically granted</p> <p>Of course, when you assign a role to a user, the permissions associated to this role are automatically granted to the user. Nothing more to do!</p>"},{"location":"configure/users/#revoke-a-role","title":"Revoke a role","text":"<p>You can revoke a role from a user by clicking on the trash button in front of the role you want to remove.</p> <p></p> <p>Asssociated permissions are automatically revoked</p> <p>Of course, when you revoke a role from a user, the permissions associated to this role are automatically revoked from this user. Nothing more to do!</p>"},{"location":"configure/users/#assign-a-permission","title":"Assign a permission","text":"<p>You can assign a single permission to a user by clicking on it in the list. It details will open on the right. Click on the Permissions tab to see the permissions they already have. Notice that permissions granted through roles are also displayed, in italic.</p> <p>From here, you can look for permissions in the select menu. Click on Add permission to assign it to the user.</p> <p></p> <p>In general, you should prefer roles</p> <p>Assigning a single permission can be convenient from time-to-time but we generally recommend to assign proper roles, even if they contain only one permission. This way, you can be more future-proof if you find that you actually need to add a new permission: rather than editing every users one by one, you'll only have to update the role once.</p>"},{"location":"configure/users/#revoke-a-permission","title":"Revoke a permission","text":"<p>You can revoke a permission from a user by clicking on the trash button in front of the permission you want to remove.</p> <p></p>"},{"location":"configure/users/#displaying-user-fields","title":"Displaying user fields","text":"<p>By default, every user fields are displayed in the list. You can customize the view by clicking on the button at the left of the Create User button. A menu will show up where you'll be able to show or hide a field by clicking on the eye icon and reorder them by drag-and-drop.</p> <p></p>"},{"location":"configure/users/#create-an-access-token","title":"Create an access token","text":"<p>In some circumstances, like debugging, you might need to impersonate one of your users to better understand what is going on. To help you with this, you can generate an access token directly from the admin dashboard.</p> <p>To do this, click on one of the user in the list. You'll see its details on the right. Then, you can click on Create an access token. A modal will appear asking you on which Client the access token will be tied and what are its allowed scopes. You'll at least need the <code>openid</code> scope, which is filled by default.</p> <p></p> <p>Finally, click on Create to generate the access token. It'll be valid for 1 hour.</p> <p></p> <p>Treat this access token with extreme care</p> <p>This access token gives access to a user account. Don't save it in a file and don't share it online.</p>"},{"location":"configure/webhooks/","title":"Webhooks","text":"<p>This is where you'll see and manage the webhooks of your instance.</p> <p>What is a Webhook?</p> <p>A Webhook is a way for your application to be notified automatically when something happens on your instance.</p> <p>For example, you can configure a Webhook so your application get a notification when a new user registers. This way, you can run your own business logic, like add the user to a mailing list or a marketing tool.</p> <p>Technically, it works with HTTP requests: Fief will make requests to the URL you give it with the relevant data for the event. On your side, you'll need to accept this request and implement the logic you need accordingly.</p> <p></p>"},{"location":"configure/webhooks/#create-a-new-webhook","title":"Create a new Webhook","text":"<p>To create a new Webhook, click on the Create Webhook button. A modal will open where you'll be able to input the URL where you want to receive notifications. Besides, you'll be able to select the events you are interested in.</p> <p></p> <p>When you submit the form, a new modal will open with the Webhook secret. For security reasons, it'll be shown only once. Copy and paste it somewhere safe before closing the modal. You'll need it to properly validate the authenticity of the request.</p> <p></p> <p>Keep it secret and safe</p> <p>The secret is used to sign and authenticate Webhook requests. Keep it somewhere safe and don't share it with anyone.</p> <p>When this is done, Fief will start to send events to your URL. You should now read our Webhook integration guide to understand how to handle it in your application.</p> <p>Integrate Webhooks in my app</p>"},{"location":"configure/webhooks/#edit-an-existing-webhook","title":"Edit an existing Webhook","text":"<p>You can edit an existing Webhook by clicking on it in the list and then click the Edit Webhook button. A modal will open where you'll be able to change its URL and enabled events.</p> <p></p>"},{"location":"configure/webhooks/#regenerate-secret-of-an-existing-webhook","title":"Regenerate secret of an existing Webhook","text":"<p>If you lost your Webhook secret or if it was compromised, you can regenerate it by clicking on the yellow Regenerate secret button. A new modal will open with your new secret. For security reasons, it'll be shown only once. Copy and paste it somewhere safe before closing the modal.</p> <p></p> <p>Keep it secret and safe</p> <p>The secret is used to sign and authenticate Webhook requests. Keep it somewhere safe and don't share it with anyone.</p>"},{"location":"configure/webhooks/#delete-an-existing-webhook","title":"Delete an existing Webhook","text":"<p>If you don't need a Webhook anymore, you can delete it by clicking on it in the list and then click the Delete Webhook button.</p> <p></p>"},{"location":"configure/webhooks/#view-webhook-logs","title":"View Webhook logs","text":"<p>Fief stores a log of each request it makes to your URL. It's useful to make sure your notification is correctly delivered and gives you insights when something goes wrong so you can correct things.</p> <p>You can access the logs of a specific Webhook by clicking on its Logs button in the list.</p> <p></p>"},{"location":"configure/customization/email-templates/","title":"Email templates","text":"<p>Quite often, Fief needs to send emails to your users. More precisely, it will send the following emails:</p> <ul> <li>The Welcome email, after a successful user registration;</li> <li>The Forgot password email, when a user asks to reset its password.</li> </ul> <p>By default, your instance is initialized with basic templates. While they can do the job for getting started, you'll likely want to customize them so it matches your branding.</p> <p>Fief comes with a built-in mechanism to customize email templates, based on Jinja templating language.</p>"},{"location":"configure/customization/email-templates/#base-template","title":"Base template","text":"<p>Fief defines a Base template from which every emails will inherit from. It's useful to define common CSS and blocks that will be reused in every emails.</p> <p>The default template is based on the Mailmason template from Postmark. It comes with a set of CSS rules that plays well with email clients. You can use it as a base or start from scratch, it's up-to-you! The default template comes with the following blocks:</p> eyJ2ZXJzaW9uIjoiMSIsImVuY29kaW5nIjoiYnN0cmluZyIsImNvbXByZXNzZWQiOnRydWUsImVuY29kZWQiOiJ4nM1YWVPjOFx1MDAxMH7nV6Qyr+Cxbok3mOHcXHUwMDE5akLY5dja2lx1MDAxMrZcdTAwMTKb+MJWXHUwMDBlhuK/r+xkY+ckQID4IVx1MDAxNbfU7lb7+/S19bhVq9X1Q6Lqu7W6XHUwMDFhODLw3VT269u5vafSzI8jM1x1MDAwNIv7LO6mTjHT0zrJdr9+LT0sJ1x1MDAwZYdeKlChinRm5v1t7mu1x+K3XHUwMDEyJ1WOllE7UIVDMVSGXCI2mraexVFcdTAwMTFcdTAwMTZcdTAwMDFqU1x1MDAwZTFcdTAwMWNP8LPvJpxWrlx1MDAxOW3JIFPlSG6qXHUwMDA33zrMt6/ah/3gsiPd6Fxm3cFK1JZcdTAwMWZcdTAwMDRN/Vx1MDAxMFxm1yRcdTAwMWSvm1ZGM53GXHUwMDFkdem72jPjYMo+9stiU4HSK427bS9SWTbhXHUwMDEzJ9Lx9UNus+2xdViE3VppXHUwMDE5mDtKqcVtTDkjdn6Vyy38ObFMXHUwMDFkXHUwMDAwoZBMpfQtXHUwMDBl4jRP6UvhZ5dJ3Uqn0zaZRe54jk5llCUyNa+qnNdcdTAwMWYtXHUwMDE2I2pcdTAwMDFBXHUwMDEwgFjkXHUwMDE3peMpnvLbns7nXHUwMDEwbjFcdTAwMGXgMElzlXMyVbxcdTAwMTEhbFxiXHRcdTAwMDfl8vJcdTAwMWOSXHUwMDEzt8DGP9NcdTAwMDX1ZJqMXG5Xz/KbSv556lx1MDAwN1x1MDAxNWCVzt3ElUNcdTAwMDBcdTAwMDBKXHUwMDE5R1RcdTAwMDCEYFx1MDAxOTLwo45cdTAwMTmMukFQ2mKnU2KmsD5tv1x1MDAwMqucsUVYXHUwMDA1jDFcZoSAq4P1tvWre1x0fILgyc1R5t6QNDxBa1x1MDAwNqtcdTAwMWLrPIF1olVcdTAwMDDLpjb5XHUwMDFmr2BcdTAwMDKt0Fx1MDAwNlx1MDAxNseC2lx1MDAwMrHFcMWC2IS9XHUwMDFlrogzi3JEJoKMgYrINDCBYIzaXGJcdTAwMDI+XHUwMDE3mSNbvsC7ZpdcdTAwMWVfXHUwMDBmOsfnR9eNM+Jk7Taqj8bfXHUwMDA04HGMx/G/XG7qtFx1MDAxYZTLrECkvdf4KbNcdTAwMWR5r1x1MDAxZtJBPzmFR6eyVVx1MDAxZs97mslsXHUwMDBlO1x1MDAwNCdrY8dEnlx1MDAxNWIwgVx1MDAxN1x1MDAxMYNgXHUwMDFiXG5cdTAwMDbwyrSYv+Y100Jm3nppYUptme1cdTAwMGZhNNzFp2lBP4BcdTAwMTZizq5ccmfIgG0sXHUwMDE45vTTqLBcZq3Q/LxcdTAwMDStJSziSDf936oo9oT1UIZ+8DDxYlx1MDAwYlx1MDAxOJtMk1R5SroqrdY8UyZssaXzXHSHvcBv51ivO2YhVVx1MDAxN1x1MDAwM3jtm75oPCH0XbcqII7JQppnpier7Ptx6rf9SFx1MDAwNlx1MDAxNzNJvoqatIKKXHUwMDE5zVx1MDAwMtjsi1x1MDAwNNKVyfln9O/FtXCyu+B251x1MDAwNlxyXHUwMDBl8EHPXHUwMDBiN5+ckFhcdTAwMTXJmuqwIMFcdTAwMTY1baiw37PFXHUwMDAyQKzCTopcYlx1MDAwM1xmVfbTTaLnS1utt9FTq0hG2opkqF5E0EC19KvpObGaaS5WM3p9XHUwMDFiibFYRElcIkyfXHUwMDBmbbS6XFwm3lVcdTAwMTedO/tO2GiQS929+L3Tut94RlJhL5NLwSxMgNmf+Fx1MDAxMrl8KyNcdTAwMTHnc1x1MDAxOFlp8cfdo0lcdTAwMTRcYrTgu+bzuschXHUwMDAwul5GemnvkDGeuYK0g1x1MDAxZN04nWwmJzSi7Fx1MDAxZbfnP/a5pnR+wJc1pev8ZFukfIjCRTQzqlx1MDAwNyBiwl6ZZsurvKk041x1MDAxNC2hXHUwMDE5huhcdTAwMDNoVjm+WdaVXHUwMDFhdYaYoM/j2OboXmjU6EM70mc0ZFpcdTAwMDWL/N4gf3AhL6H5WGVV3j6rfkFcdTAwMTP8sffjOFZhM1xm//pxcHl/TjaelsvPUIiAXHUwMDE2JMPjuPdUv5edoWDBKSfVk8FNXHUwMDEyQXDXbWTXNydH+8jvu79cdTAwMGWvZPw9eE9cdTAwMTGcXHUwMDFmcFx1MDAwM0Vwca9cdKiBXHUwMDE4XHUwMDE2YvVec3mVN5VtnEBcdTAwMGIvXHUwMDE0QWJ6zfdnXHUwMDFincOxWVx1MDAxMVx1MDAxNDDfXHUwMDE0XHUwMDEw2cSPP9MkXHUwMDEwVDkpeG9cdTAwMTFsxbH+4IOZZ8RkWlx1MDAwNkdcdTAwMTlcdTAwMGVpuTUqfF0mSVObyplcdTAwMTlDktZ7vurvz+LlS6u4cv+C1Dl9VP5cdTAwMTJcdTAwMWWftp7+XHUwMDAzwqT10SJ9 preheadertenant.namemainfooter <ul> <li><code>preheader</code>: this block allows you to add content that won't be shown in the email body. It's used to finely control the email preview in the inbox list.</li> <li><code>main</code>: this block will bear the actual content of the email.</li> <li><code>footer</code>: this block will appear at the end of the email and can be used to put legal terms or social networks links.</li> </ul> <p>Before the <code>main</code> block, notice that we show the name of the tenant.</p>"},{"location":"configure/customization/email-templates/#customize","title":"Customize","text":"<p>You can customize the Base template from admin dashboard. On the left menu, click on Customization and Email templates. You'll see the list of all available templates.</p> <p></p> <p>Click on the Update button in the front of the Base template row. An editor will open, with the HTML code on the left and a preview on the right.</p> <p></p>"},{"location":"configure/customization/email-templates/#context","title":"Context","text":"<p>The context defines the available variables you can use in the template. The Base template gives you access to the following context:</p> <p>The tenant of the user, <code>tenant</code>, with the following properties</p> <ul> <li><code>id</code> (<code>uuid.UUID</code>): ID of the tenant.</li> <li><code>created_at</code> (<code>datetime</code>): Creation date of the tenant.</li> <li><code>updated_at</code> (<code>datetime</code>): Last update date of the tenant.</li> <li><code>name</code> (<code>str</code>): Name of the tenant.</li> <li><code>default</code> (<code>bool</code>): Whether it is the default tenant.</li> <li><code>slug</code> (<code>str</code>): Slug of the tenant, i.e. the part of the base URL after the domain.</li> <li><code>registration_allowed</code> (<code>str</code>): Whether registration are allowed or not for this tenant.</li> </ul> <p>The recipient user, <code>user</code>, with the following properties:</p> <ul> <li><code>id</code> (<code>uuid.UUID</code>): ID of the user.</li> <li><code>created_at</code> (<code>datetime</code>): Creation date of the user.</li> <li><code>updated_at</code> (<code>datetime</code>): Last update date of the user.</li> <li><code>email</code> (<code>str</code>): Email address of the user.</li> <li><code>tenant_id</code> (<code>uuid.UUID</code>): ID of the associated tenant.</li> <li><code>fields</code> (<code>dict[str, Any]</code>): Dictionary giving you the user fields values for this user, indexed by their slug.</li> </ul> <p>Examples</p> <pre><code>&lt;h1&gt;{{ tenant.name }}&lt;/h1&gt;\n</code></pre> <pre><code>&lt;p&gt;Hello, {{ user.fields.first_name }} \ud83d\udc4b&lt;/p&gt;\n</code></pre>"},{"location":"configure/customization/email-templates/#welcome-template","title":"Welcome template","text":"<p>The Welcome template is used to send an email when a new user registers. It's the ideal message to welcome them, show them the basics of your application or give them relevant information.</p> <p>The default template looks like this:</p> <pre><code>{% extends \"BASE\" %}\n\n{% block preheader %}Welcome to {{ tenant.name }}! We're thrilled to have you on board.{% endblock %}\n\n{% block main %}\n&lt;h1&gt;Welcome!&lt;/h1&gt;\n&lt;p&gt;Welcome to {{ tenant.name }}! We're thrilled to have you on board.&lt;/p&gt;\n{% endblock %}\n</code></pre> <p>You can see it's very lightweight: all we need to do is to define the content of each block. The magic happens thanks to the <code>{% extends \"BASE\" %}</code> instruction which tells Fief to inherit from the Base template.</p>"},{"location":"configure/customization/email-templates/#subject","title":"Subject","text":"<p>Using the text input above the code editor, you can customize the subject of the email. It accepts the same syntax and has the same context.</p>"},{"location":"configure/customization/email-templates/#context_1","title":"Context","text":"<p>The context is the same as for Base template.</p>"},{"location":"configure/customization/email-templates/#verify-email-template","title":"Verify email template","text":"<p>The Verify email template is used to send an email when a user needs to verify their email address. It should contain the code the user should input on Fief to verify their email.</p> <p>The default template looks like this:</p> <pre><code>{% extends \"BASE\" %}\n\n{% block preheader %}Use this code to verify your email address. This code is only valid for 1 hour.{% endblock %}\n\n{% block main %}\n  &lt;h1&gt;Verify your email address&lt;/h1&gt;\n  &lt;p&gt;You recently created or updated your email on your {{ tenant.name }}'s account. To verify your email address, please enter the verification code below.&lt;/p&gt;\n  &lt;table class=\"discount\" align=\"center\" width=\"100%\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\"&gt;\n    &lt;tr&gt;\n      &lt;td align=\"center\"&gt;\n        &lt;h1 class=\"f-fallback discount_heading\"&gt;{{ code }}&lt;/h1&gt;\n        &lt;p class=\"f-fallback discount_body\"&gt;This verification code is only valid for the next hour.&lt;/p&gt;\n      &lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/table&gt;\n{% endblock %}\n</code></pre> <p>You can see it's very lightweight: all we need to do is to define the content of each block. The magic happens thanks to the <code>{% extends \"BASE\" %}</code> instruction which tells Fief to inherit from the Base template.</p>"},{"location":"configure/customization/email-templates/#subject_1","title":"Subject","text":"<p>Using the text input above the code editor, you can customize the subject of the email. It accepts the same syntax and has the same context.</p>"},{"location":"configure/customization/email-templates/#context_2","title":"Context","text":"<p>The context is the same as for Base template. It also adds:</p> <ul> <li><code>code</code> (<code>str</code>): The verification code the user should input.</li> </ul>"},{"location":"configure/customization/email-templates/#forgot-password-template","title":"Forgot password template","text":"<p>The Forgot password template is used to send an email when a user wants to reset their password. The main purpose is to send them the link allowing them to change their password.</p> <p>The default template looks like this:</p> <pre><code>{% extends \"BASE\" %}\n\n{% block preheader %}Use this link to reset your password. This link is only valid for 1 hour.{% endblock %}\n\n{% block main %}\n  &lt;h1&gt;Reset your password&lt;/h1&gt;\n  &lt;p&gt;You recently requested to reset your password for your {{ tenant.name }} account. Use the button below to reset it. &lt;strong&gt;This password reset link is only valid for the next hour.&lt;/strong&gt;&lt;/p&gt;\n  &lt;table class=\"body-action\" align=\"center\" width=\"100%\" cellpadding=\"0\" cellspacing=\"0\" role=\"presentation\"&gt;\n    &lt;tr&gt;\n      &lt;td align=\"center\"&gt;\n        &lt;!-- Border based button\n  https://litmus.com/blog/a-guide-to-bulletproof-buttons-in-email-design --&gt;\n        &lt;table width=\"100%\" border=\"0\" cellspacing=\"0\" cellpadding=\"0\" role=\"presentation\"&gt;\n          &lt;tr&gt;\n            &lt;td align=\"center\"&gt;\n              &lt;a href=\"{{reset_url}}\" class=\"f-fallback button button--green\" target=\"_blank\" rel=\"noopener noreferrer\"&gt;Reset your password&lt;/a&gt;\n            &lt;/td&gt;\n          &lt;/tr&gt;\n        &lt;/table&gt;\n      &lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/table&gt;\n{% endblock %}\n</code></pre> <p>You can see it's very lightweight: all we need to do is to define the content of each block. The magic happens thanks to the <code>{% extends \"BASE\" %}</code> instruction which tells Fief to inherit from the Base template.</p>"},{"location":"configure/customization/email-templates/#subject_2","title":"Subject","text":"<p>Using the text input above the code editor, you can customize the subject of the email. It accepts the same syntax and has the same context.</p>"},{"location":"configure/customization/email-templates/#context_3","title":"Context","text":"<p>The context is the same as for Base template. It also adds:</p> <ul> <li><code>reset_url</code> (<code>str</code>): The URL where the user can reset their password.</li> </ul>"},{"location":"configure/customization/email-templates/#templating-language","title":"Templating language","text":"<p>The template language is based Jinja templating language, so all constructs accepted by Jinja are supported. In particular, you can insert dynamic values using the <code>{{ }}</code> syntax:</p> <pre><code>&lt;p&gt;{{ user.email }}&lt;/p&gt;\n</code></pre> <p>You can also define conditional blocks based on some values:</p> <pre><code>{% if user.fields.newsletter %}\n    &lt;p&gt;Thank you for subscribing to our newsletter \ud83c\udf89&lt;/p&gt;\n{% else %}\n    &lt;p&gt;You didn't subscribe to our newsletter \ud83e\udd72&lt;/p&gt;\n{% endif %}\n</code></pre>"},{"location":"configure/customization/themes/","title":"Themes","text":"<p>Fief comes with its own authentication pages for login, registration and reset password. You can customize them so they match the brand of your application. This is done through a system of themes. They can either be set globally, which is the most common case, or you can assign them to a specific tenant if you need to customize the look-and-feel per tenant.</p> <p>When your instance is created, Fief will always create a Default theme.</p> <p></p>"},{"location":"configure/customization/themes/#create-a-new-theme","title":"Create a new theme","text":"<p>You can create a new theme by clicking the Create Theme button. A modal will open where you'll be able to input its name. You'll then be taken to the theme edition page.</p> <p></p>"},{"location":"configure/customization/themes/#set-as-default","title":"Set as default","text":"<p>Unless specified otherwise, tenants will use the theme specified as default. To change the default theme, click on the Set as default button in front of the theme you want to make default.</p> <p></p>"},{"location":"configure/customization/themes/#edit-an-existing-theme","title":"Edit an existing theme","text":"<p>You can edit an existing theme by clicking on the Update button in its row. An editor will open, with the customization parameters on the left and a preview on the right.</p> <p></p> <p>You can switch the page to preview using the select menu above the preview.</p> <p></p>"},{"location":"configure/customization/themes/#customization-parameters","title":"Customization parameters","text":"<p>You'll find below a description of the customizable parameters and what is their effect.</p>"},{"location":"configure/customization/themes/#themess-name","title":"Themes's name","text":"<p>This is the name of the theme. It won't be shown to the end-user, it's just a way for you to easily identify them.</p>"},{"location":"configure/customization/themes/#primary-colors","title":"Primary colors","text":"<p>Primary colors correspond to the colors of the buttons, links and form focus borders. This is usually your \"brand color\".</p> <p> </p> Primary color <p> </p> Hover primary color <p> </p> Light primary color"},{"location":"configure/customization/themes/#form-input-colors","title":"Form input colors","text":"<p>Form input colors respectively control the color of the text and the background of the form inputs.</p> <p> </p> Form inputs colors"},{"location":"configure/customization/themes/#light-colors","title":"Light colors","text":"<p>Light colors control the color of the borders, in particular the ones on form inputs.</p> <p> </p> Light color <p> </p> Hover light color"},{"location":"configure/customization/themes/#text-colors","title":"Text colors","text":"<p>Text colors control the color of the content and headings.</p> <p> </p> Text color <p> </p> Accent text color"},{"location":"configure/customization/themes/#background-color","title":"Background color","text":"<p>Background color control the color of the whole background.</p> <p> </p> Background color"},{"location":"configure/customization/themes/#fonts","title":"Fonts","text":"<p>There are three parameters to control the fonts:</p> <ul> <li>Base font size: base size of the text, in <code>px</code>. Other font sizes (like headings) are proportional to this size.</li> <li>Font family: the font to use. It should be a valid CSS <code>font-family</code> property.</li> <li>CSS font URL: allows you to import custom fonts, like the ones from Google Fonts. The URL should point to a valid CSS file with <code>@font-face</code> instructions.</li> </ul> <p>The example below shows you the result with <code>14</code>, <code>'Merriweather', serif</code>, <code>https://fonts.googleapis.com/css2?family=Merriweather&amp;display=swap</code>:</p> <p></p>"},{"location":"getting-started/introduction/","title":"Introduction","text":"<p>Fief is what is usually called an identity provider: it provides and secures user identities to external apps.</p> <p>To allow this, Fief implements the OpenID Connect protocol, an identity layer on top of the well-known OAuth2 protocol. Basically, it describes a secure way for a user to give access to its data to an external app.</p> <p>So, how does everything will fit together? In a nutshell, Fief will store everything about your users data (email address, hashed passwords...) and give you a simple way to authenticate them in your application.</p> <pre><code>graph TD\n    U((User))\n    A{Your application}\n    subgraph FIEF [Fief]\n        F[Fief API]\n        FL[Login page]\n        FD[(Fief database)]\n    end\n    U -- is not authenticated ----&gt; FL\n    U -- is authenticated ----&gt; A\n    A -- checks user identity on --&gt; F\n    FL -. redirects to .-&gt; A\n    F -- stores users on --&gt; FD</code></pre>"},{"location":"getting-started/introduction/#lets-get-started","title":"Let's get started!","text":"<p>The first thing to do is to start your Fief instance on your machine!</p>"},{"location":"getting-started/local-instance/","title":"1. Start your local Fief instance","text":"<p>We provide a Docker image to help you start the Fief server locally in no time!</p>"},{"location":"getting-started/local-instance/#quickstart-command","title":"Quickstart command","text":"<p>Run the following command:</p> <pre><code>docker run -it --rm ghcr.io/fief-dev/fief:latest fief quickstart --docker\n</code></pre> <p>The command will ask you to give an email address for the first admin user. It'll be automatically created when starting the server.</p> <pre><code>User email: anne@bretagne.duchy\nUser password: XXX\nRepeat for confirmation: XXX\n</code></pre> <p>The result of this command is a complete <code>docker run</code> command with the required secrets generated and environment variables to help you get started. It'll look like the following:</p> <pre><code>docker run \\\n  --name fief-server \\\n  -p 8000:8000 \\\n  -d \\\n  -e \"SECRET=XXX\" \\\n  -e \"FIEF_CLIENT_ID=XXX\" \\\n  -e \"FIEF_CLIENT_SECRET=XXX\" \\\n  -e \"ENCRYPTION_KEY=XXX\" \\\n  -e \"PORT=8000\" \\\n  -e \"FIEF_DOMAIN=localhost:8000\" \\\n  -e \"FIEF_MAIN_USER_EMAIL=anne@bretagne.duchy\" \\\n  -e \"FIEF_MAIN_USER_PASSWORD=XXX\" \\\n  -e \"CSRF_COOKIE_SECURE=False\" \\\n  -e \"SESSION_DATA_COOKIE_SECURE=False\" \\\n  -e \"USER_LOCALE_COOKIE_SECURE=False\" \\\n  -e \"LOGIN_SESSION_COOKIE_SECURE=False\" \\\n  -e \"SESSION_COOKIE_SECURE=False\" \\\n  -e \"FIEF_ADMIN_SESSION_COOKIE_SECURE=False\" \\\n  ghcr.io/fief-dev/fief:latest\n</code></pre> <p>Save those secrets somewhere safe!</p> <p>If you need to restart or recreate your container, you'll need to set the same secrets again. If you lose them, you'll likely lose access to data or have a bad configuration. Read more about secrets and environment variables.</p> <p>Info</p> <p>The container is available on the port 8000 of your local machine by default.</p>"},{"location":"getting-started/local-instance/#good-to-go","title":"Good to go!","text":"<p>At this point, your Fief server should be up-and-running! Open http://localhost:8000/admin/ to access the admin dashboard. You'll be redirected to a login page. Authenticate with the user credentials you specified in the previous section.</p> <p></p> <p>You'll then be redirected to the admin dashboard.</p> <p></p> <p>Congratulations! Your Fief server instance is up-and-running \ud83c\udf89 You can now try Fief features and start to integrate authentication in your app.</p> <p>Tip</p> <p>For production deployment, we strongly recommend you to go through the self-hosting documentation.</p>"},{"location":"getting-started/oauth2/","title":"2. Understand OAuth2","text":"<p>Fief uses the OpenID Connect protocol, an identity layer on top of the well-known OAuth2 protocol to securely authenticate users.</p> <p>If you understand the basics of this protocol, you'll better understand how to integrate Fief to your own application.</p> <p>You probably already used OAuth2 before: whenever you use a button like Sign In with Google or Sign In with Facebook on a website, you actually authenticate yourself using the OAuth2 protocol!</p>"},{"location":"getting-started/oauth2/#authentication-flow","title":"Authentication flow","text":"<p>Schematically, a complete OAuth2 flow looks like this:</p> <pre><code>sequenceDiagram\n    actor U as User\n    participant A as Your app\n    participant F as Fief\n    U-&gt;&gt;A: Wants to login\n    A-&gt;&gt;U: Redirects to Fief login page\n    U-&gt;&gt;F: Authenticates on Fief\n    F-&gt;&gt;A: Redirects with a temporary code\n    A-&gt;&gt;F: Exchanges the temporary code\n    F-&gt;&gt;A: Generates a valid token\n    A-&gt;&gt;U: Answers with a valid session</code></pre> <p>You see that we have three actors in this flow:</p> <ol> <li>The user</li> <li>Your application that needs to know the authenticated user</li> <li>Fief, which is able to authenticate users and provide their information</li> </ol> <p>This flow relies a lot on redirections:</p> <ol> <li>The user first tries to access your application.</li> <li>If they're not logged in, they are redirected to the Fief login page.</li> <li>On this login page, the user will input its credentials, typically an email address and a password to authenticate themself.</li> </ol> <p></p> <p>At this point, we don't have a valid user session yet. In traditional applications, after a successful login, we do obtain a valid user session. However, in this context, the application needing the user session, your application, is not the same as the one that provides authentication, Fief.</p> <p>That's why we have an additional step: Fief redirects to your application with a temporary code, called the authorization code. This code is then used by your application to call the Fief API and obtain a valid token in exchange. Finally, your application can save this token somewhere to maintain the user session.</p> <p>The benefit of this approach is that your application never has access to the user credentials: the sensitive and difficult part is handled by Fief.</p> <p>There are other OAuth2 variants</p> <p>OAuth2 proposes several ways to achieve this kind of authentication flow.</p> <p>We showed here the authorization code grant, which is the most widely-used and the default in Fief.</p>"},{"location":"getting-started/oauth2/#scopes","title":"Scopes","text":"<p>A central part in OAuth2 is the concept of scopes. Basically, it determines what the application will be able to do or not with the user data.</p> <p>For the user, this translates to the famous consent screen: it's a special page after a successful login telling them what the application wants to do with their data.</p> <p></p> <p>Once the access token is generated, it'll be tied to this specific list of scopes the user has granted. In your application, you'll be able to limit some actions based on those scopes.</p> <p>As we said in introduction, we use the OpenID Connect protocol on top of OAuth2. With this protocol, we always have at least one scope, <code>openid</code>. It's a core scope giving access to the basic information of the user.</p> <p>First-party clients</p> <p>Since you'll use Fief to authenticate users on your own, official application, we introduced the concept of first-party clients. When a user logs in on a client configured as first-party, the consent screen is bypassed and every scopes asked are implicitly granted.</p> <p>You can read more about this in the dedicated section.</p> <p>Limitations</p> <p>In the future, you'll be able to create your own set of scopes in Fief.</p>"},{"location":"getting-started/oauth2/#access-token-and-id-token","title":"Access Token and ID Token","text":"<p>After a successful authentication flow, your application will get two different tokens: an access token and an ID token.</p> <p>The first one, the access token, is a secret value that'll authenticate the user on your application. It's tied to a specific user and a list of scopes.</p> <p>On the other hand, the ID token is a value containing all the basic information about the authenticated user, like its email and other personal information. It'll be very useful in your application if you need for example to display the email of the current user.</p> <p>For security reasons, both of them have a limited lifetime. At some point, we'll need to make another OAuth2 authentication flow again to retrieve fresh tokens.</p> <p>Those are JWT</p> <p>The access token and the ID token are both generated as JSON Web Tokens (JWT). JWT is a widely-used standard to secure data contained in a standard JSON object.</p> <p>Typically, JWT are cryptographically signed. It means that your application is able to certify that the tokens you get are true and authentic tokens generated by Fief, and not forged by a malicious attacker. This is critical since we use those to authenticate users into your app.</p> <p>The technical details around this are a bit complex but you can read more about on the official JWT documentation.</p>"},{"location":"getting-started/oauth2/#lets-try-it-for-real","title":"Let's try it for real!","text":"<p>Before starting to implement Fief in your own application, we'll perform an OAuth2 authentication on your own instance using the built-in tools of Fief.</p>"},{"location":"getting-started/try-oauth2/","title":"3. Try OAuth2 on your instance","text":"<p>The following exercise is very interesting to see and practice all the aspects of OAuth2 with Fief.</p> <p>First of all, go to your admin dashboard.</p> <p></p>"},{"location":"getting-started/try-oauth2/#1-check-redirect-uri-on-a-client","title":"1. Check Redirect URI on a Client","text":"<p>On the left menu, click on Clients. You'll see here the list of OAuth2 clients defined on your instance. When getting started, you will have one default client created for you.</p> <p>What is a client?</p> <p>A client is a central part of the OAuth2 protocol. It's the definition of an application authorized to request for access tokens and user information on Fief. In other words, your application will need one of those client to be able to authenticate users from your Fief instance.</p> <p>Each client has a Client ID and a Client Secret. Those values are used during OAuth2 authentification to recognize the client.</p> <p>Each instance comes with one client, tied to the default tenant.</p> <p></p> <p>Click on your default client in the list. You'll see its details on the right. Click on the Edit Client button. A modal will open where you'll be able to change some of the properties of this client.</p> <p>In the Redirect URIs part, you'll see that the client has already a list of predefined Redirect URI.</p> <p></p> <p>When integrating your own application, you'll need to add the corresponding Redirect URI here. For now, we have the ones we need for the current example.</p> <p>Keep this tab open</p> <p>You can keep this tab open in your browser, we'll need it right after.</p>"},{"location":"getting-started/try-oauth2/#2-open-the-interactive-documentation","title":"2. Open the interactive documentation","text":"<p>Fief comes with an interactive documentation allowing you to easily test its API. Open it in a new window: http://localhost:8000/docs</p> <p></p> <p>You see there the list of available API endpoints. We'll be able to call them when we'll be properly authenticated.</p>"},{"location":"getting-started/try-oauth2/#3-authenticate-in-the-interactive-documentation","title":"3. Authenticate in the interactive documentation","text":"<p>Click on the Authorize button. A modal will open showing you the available methods for authenticating. The one we're interested in is at the bottom of this window and called OAuth2AuthorizationCodeBearer.</p> <p></p> <p>You see a form expecting two things: the Client ID and Client Secret. Get back to the admin dashboard window and copy and paste them from the client information.</p> <p></p> <p>Don't forget also to check the <code>openid</code> checkbox (that's the scope we ask for!). Finally, click on the Authorize button. You'll be taken to a Fief login page!</p> <p></p> <p>Just go through the authentication process. If everything goes well, you'll be taken back to the interactive documentation. The authorize window now shows you that you are correctly authenticated: we successfully got an access token \ud83c\udf89</p> <p></p>"},{"location":"getting-started/try-oauth2/#4-call-an-api","title":"4. Call an API","text":"<p>We can now call one of the API! In particular, we'll try the <code>/api/userinfo</code> endpoint: it'll show the information about the current user (you!). Open the one called <code>GET /api/userinfo</code>, click on the Try it out button and then Execute. You'll see an API response showing the information about your user object:</p> <p></p> <p>Notice how the interactive documentation automatically added the <code>Authorization</code> header with the token!</p>"},{"location":"getting-started/try-oauth2/#youre-now-an-oauth2-master","title":"You're now an OAuth2 master \ud83d\udc4f","text":"<p>Congratulations! You've performed a full OAuth2 authentication from A to Z. Those concepts are important to have in mind because they'll be at the core of Fief integration in your app. The key things to remember are:</p> <ul> <li>You need a Client to make authentication requests, using its ID and Secret.</li> <li>You need to allow the Redirect URL on the Client so Fief can redirect to your application.</li> <li>You need to request an access token and store it somewhere to authenticate requests.</li> </ul>"},{"location":"getting-started/try-oauth2/#what-now","title":"What now?","text":"<p>You can now proceed to integrate Fief in your application! We provide libraries and guides for the following languages:</p> <p>Python JavaScript</p> <p>Also, be sure to get familiar with all the features of Fief by going through the admin dashboard documentation.</p>"},{"location":"going-further/acr/","title":"ACR","text":"<p>ACR stands for Authentication Context Class Reference. It's a way to standardize the level of security of an access token depending on how the user authenticated.</p>"},{"location":"going-further/acr/#why-this-is-useful","title":"Why this is useful?","text":"<p>In web applications, users usually logs in a first time with their email and password. When they come back, the application will use a cookie to remember their session so they don't have to authenticate again.</p> <p>While convenient for the user, we cannot consider the cookie as safe as the email and password authentication: a malicious user could be behind the device, taking advantage of the existing session. In this context, sensitive operations like changing the password or initiating a money transfer should be avoided and we should ask again for the user's password.</p> <p>That's exactly what ACR are for: properly define and prioritize the different ways a user can be authenticated, so we can allow or disallow sensitive operations.</p>"},{"location":"going-further/acr/#how-its-used-in-fief","title":"How it's used in Fief?","text":"<p>Fief defines two levels of ACR:</p> <ul> <li>Level 0: the user was authenticated through an existing session or a refresh token. They didn't authenticate with their email and password.</li> <li>Level 1: the user authenticated using their email and password.</li> </ul> <p>Other levels will be introduced in the future</p> <p>We plan to support more robust ways of authenticating in Fief, like multi-factor authentication (MFA) or passkeys. As a result, we'll have even higher levels of ACR.</p> <p>The ACR level is contained in the access token generated by Fief. Thus, the Fief API or your app can check for this parameter to allow or disallow an operation.</p> <p>The Fief API requires an ACR of at least level 1 to:</p> <ul> <li>Change the user's password</li> <li>Change the user's email</li> <li>Verify the user's email</li> </ul>"},{"location":"going-further/acr/#authenticate-the-user-with-a-specific-acr-level","title":"Authenticate the user with a specific ACR level","text":"<p>After the user has successfully authenticated with their email and password a first time, Fief will maintain a session on its side so they don't have to enter their credentials again. As a result, while this session is valid, the access token you'll get will have and ACR Level 0.</p> <p>If you require a higher ACR level, you can add the <code>acr_values</code> parameter to the Authorize URL. For example:</p> <pre><code>https://fief.mydomain.com/authorize?response_type=code&amp;client_id=YOUR_CLIENT_ID&amp;redirect_uri=http%3A%2F%2Flocalhost%3A8000%2Fcallback&amp;scope=openid&amp;acr_values=1\n</code></pre> <p>By doing this, even if there is a valid session on Fief's side, the server will force the user to authenticate again to match the desired ACR level.</p>"},{"location":"going-further/authorize-url/","title":"Authorize URL","text":"<p>As we explain in Understand OAuth2, the first step to authenticate your users is to redirect them to the Fief authentication page.</p> <p>This is done by redirecting them to the <code>/authorize</code> route of your tenant, with some specific parameters. Here is the full set of accepted parameters for the authorize URL. Most of them comes from the OAuth2 and OpenID specification, but Fief also defines some of its own.</p> Parameter name Description Allowed values Required <code>response_type</code> Denotes the kind of credential that will be returned after redirection. Official clients always use <code>code</code>. <code>code</code>, <code>code id_token</code>, <code>code token</code>, <code>code id_token token</code> \u2705 <code>client_id</code> Your Client ID. \u2705 <code>redirect_uri</code> The URL where the user will be redirected after authentication. Must be allowed on your Client. \u2705 <code>scope</code> Space-separated list of scope to ask for. Must contain at least <code>openid</code> <code>openid</code>, <code>offline_access</code> \u2705 <code>state</code> Optional value to keep track of the authentication process in your app. <code>prompt</code> Optional value to force or hide the authentication page prompt. If the user has already a session on Fief's side and has already consented access to this Client, they will be automatically redirected to your application without any prompt. You can disable this by setting this parameter to <code>login</code> to force the user to authenticate again or <code>consent</code> to force the user to give its consent again. <code>none</code>, <code>login</code>, <code>consent</code> <code>screen</code> By default, the user will be redirected to a login page. You can force Fief to redirect to a registration page with this parameter. <code>login</code>, <code>register</code> <code>login_hint</code> Optional parameter to either prefill the user email or put forward one of the OAuth Provider. Valid email address or ID of an OAuth Provider enabled on your tenant. <code>acr_values</code> Optional space-separated list of ACR levels the server should require from the user. <code>0</code>, <code>1</code> <code>lang</code> Optional parameter to set the user locale on the authentication pages. Valid RFC 3066 language identifier, like <code>fr</code> or <code>pt-PT</code>. <code>code_challenge</code> Optional code challenge value for PKCE. For public Clients <code>code_challenge_method</code> Method used to hash the code verifier for PKCE. <code>plain</code>, <code>S256</code> For public Clients"},{"location":"going-further/id-token-encryption/","title":"ID Token encryption","text":"<p>In Understand OAuth2 section, we said that, after a successful authentication, you get two different tokens: an access token and an ID token.</p> <p>The ID token is a value containing all the basic information about the authenticated user, like its id, email and profile information from user fields. For security and convenience, this data is encoded as a JSON Web Token (JWT).</p> <p>Before showing how to enable its encryption, let's explain how JWT work and why encryption is interesting.</p>"},{"location":"going-further/id-token-encryption/#what-are-jwt","title":"What are JWT?","text":"<p>JWT is a widely-used standard to secure and encode JSON data. For example, let's take the following JSON data, which is typical of what you could find in an ID token generated by Fief:</p> <pre><code>{\n    \"iss\": \"https://fief.mydomain.com\",\n    \"sub\": \"6c0e7f94-6af3-47ad-8599-6345a5a193cd\",\n    \"email\": \"anne@nantes.city\",\n    \"tenant_id\": \"3a85b89c-a232-4e2c-9d51-62501d8b6248\",\n    \"is_active\": true,\n    \"is_superuser\": false,\n    \"is_verified\": false,\n    \"fields\": {\n        \"given_name\": \"Anne\",\n        \"onboarding_done\": false\n    },\n    \"at_hash\": \"xWsDb_ALRF-uu_oKA16NBQ\",\n    \"aud\": [\n        \"YoiOW3KxPGJOvf3IAOXt8rVpXEX-IencR8j7GYKx5YQ\"\n    ],\n    \"auth_time\": 1664352285,\n    \"azp\": \"YoiOW3KxPGJOvf3IAOXt8rVpXEX-IencR8j7GYKx5YQ\",\n    \"c_hash\": \"1eTVhuCXj-Vz49DjpubmKg\",\n    \"exp\": 1664355888,\n    \"iat\": 1664352288\n}\n</code></pre> <p>If we encode this data as a JWT, here is what it looks like:</p> <pre><code>eyJhbGciOiJSUzI1NiJ9.eyJhdF9oYXNoIjoieFdzRGJfQUxSRi11dV9vS0ExNk5CUSIsImF1ZCI6WyJZb2lPVzNLeFBHSk92ZjNJQU9YdDhyVnBYRVgtSWVuY1I4ajdHWUt4NVlRIl0sImF1dGhfdGltZSI6MTY2NDM1MjI4NSwiYXpwIjoiWW9pT1czS3hQR0pPdmYzSUFPWHQ4clZwWEVYLUllbmNSOGo3R1lLeDVZUSIsImNfaGFzaCI6IjFlVFZodUNYai1WejQ5RGpwdWJtS2ciLCJlbWFpbCI6ImFubmVAbmFudGVzLmNpdHkiLCJleHAiOjE2NjQzNTU4ODgsImZpZWxkcyI6eyJnaXZlbl9uYW1lIjoiQW5uZSIsIm9uYm9hcmRpbmdfZG9uZSI6ZmFsc2V9LCJpYXQiOjE2NjQzNTIyODgsImlzX2FjdGl2ZSI6dHJ1ZSwiaXNfc3VwZXJ1c2VyIjpmYWxzZSwiaXNfdmVyaWZpZWQiOmZhbHNlLCJpc3MiOiJodHRwczovL2JyZXRhZ25lLmxvY2FsaG9zdDo4MDAwL3NlY29uZGFyeSIsInN1YiI6IjZjMGU3Zjk0LTZhZjMtNDdhZC04NTk5LTYzNDVhNWExOTNjZCIsInRlbmFudF9pZCI6IjNhODViODljLWEyMzItNGUyYy05ZDUxLTYyNTAxZDhiNjI0OCJ9.Rqe5DiaNR53pYEa8qaC_6TiUsvYzPNqmu0sJuu_Jx1ot3Ql9peEIYJOfkaas1M7E-DEKy_i0jXmdnsyU5uUIyQ\n</code></pre> <p>At first, we could think this data is encrypted and can't be read without a key. Actually, it's just a standard base64 encoding and it's very easy to decode. If you want to see it by yourself, you can copy-paste the value above into the JWT.io debugger: you'll see the data decoded!</p> <p></p> <p>So, why do we bother with JWT then? If you look closely at the debugger, you'll see there are three parts in the JWT, separated by a dot:</p> <ol> <li>The Header, in red.</li> <li>The Data, in purple which contains our base64-encoded JSON.</li> <li>The Signature, in blue.</li> </ol> <p>The signature is actually the main benefit of the JWT. It's a cryptographic technique allowing us to ensure the data has not been tampered or replaced by a malicious user: we're sure this is legitimate data generated by the Fief server.</p> <p>We also use JWT for access tokens: thanks to the signature, we can be sure it's a valid access token just by checking the signature, without having to make a request to the server. This is super convenient!</p> <p>Schematically, here is the creation process of a signed JWT:</p> <pre><code>flowchart LR\n    D[Data]\n    S{{Signature algorithm}}\n    T[Signed JWT]\n    D --&gt; S\n    S --&gt; T</code></pre>"},{"location":"going-further/id-token-encryption/#why-encryption-is-needed","title":"Why encryption is needed?","text":"<p>Ok, so we have our ID token as a JWT, and we can check the authenticity of the data. However, as we shown, the data can be easily decoded by anyone who could read the ID token.</p> <p>Since the ID token may contain personal information, like email, postal address or phone number, it may pose confidentiality issues.</p> <p>Fortunately, JWT accept a wide range of cryptographic algorithms, including assymetric encryption. In a nutshell, those algorithms use a pair of keys, a public one and a secret one. If we encrypt the data with the public key, it can only be decoded using the private key: the data remains private if we don't have this key.</p> <p>Schematically, it looks like this:</p> <pre><code>flowchart LR\n    D[Data]\n    E{{Encryption algorithm}}\n    T[Encrypted JWT]\n    D --&gt; E\n    E -- Public key --&gt; T</code></pre> <p>However, there is a problem: the data is now encrypted, but it's not signed anymore. In this case, a malicious user could easily tamper or replace the data, encrypt it with the public key and return it to us. We could decrypt it, but we couldn't be sure it's authentic data from the server.</p> <p>The solution is actually simple: take the encrypted JWT and wrap it in another JWT using a signature algorithm! This technique is called nested JWT. Hence, we have this process:</p> <pre><code>flowchart LR\n    D[Data]\n    E{{Encryption algorithm}}\n    S{{Signature algorithm}}\n    TE[Encrypted JWT]\n    T[Encrypted and signed JWT]\n    D --&gt; E\n    E -- Public key --&gt; TE\n    TE --&gt; S\n    S --&gt; T</code></pre> <p>Now, we have the best of both worlds: we can check the authenticity of the data while preserving its confidentiality. This is what we do when we enable ID Token encryption.</p>"},{"location":"going-further/id-token-encryption/#enable-id-token-encryption","title":"Enable ID Token encryption","text":"<p>In Fief, ID Token encryption can be enabled per client. From the admin dashboard, click on the client on which you want to enable ID Token encryption and, in its detail modal, click on the Generate key button.</p> <p></p> <p>Fief will generate a key pair for you. Then, a modal will open with your private encryption key. For security purposes, Fief will only keep the public one. It means that only you will be able to decrypt the data in the ID Token. Keep it safe and secret!</p> <p></p>"},{"location":"going-further/id-token-encryption/#configure-your-application-for-id-token-encryption","title":"Configure your application for ID Token encryption","text":"<p>You need now to configure your application so it can decode the ID Token. If you use our official libraries, all you need to do is to pass the key you copied above when initializing the Fief client:</p> PythonJavaScript <pre><code>fief = Fief(\n    \"https://fief.mydomain.com\",\n    \"YOUR_CLIENT_ID\",\n    \"YOUR_CLIENT_SECRET\",\n    encryption_key=\"YOUR_ENCRYPTION_KEY\",\n)\n</code></pre> <pre><code>const fief = new Fief({\n    baseURL: 'https://fief.mydomain.com',\n    clientId: 'YOUR_CLIENT_ID',\n    clientSecret: 'YOUR_CLIENT_SECRET',\n    encryptionKey: 'YOUR_ENCRYPTION_KEY',\n});\n</code></pre> <p>The client will then take care of decrypting the data for you.</p> <p>In other languages, use a JWT library to decrypt the ID token:</p> <ol> <li>Decrypt the encrypted JWT with your encryption key.</li> <li>The resulting <code>claims</code> is the signed JWT.</li> <li>Check the signature and decode the data of this signed JWT.</li> </ol> <p>Draw inspiration from our Python implementation</p> <p>If you need an example of how to do this, you can draw inspiration from our Python implementation.</p>"},{"location":"going-further/id-token-encryption/#regenerate-encryption-key","title":"Regenerate encryption key","text":"<p>If you need to reset your encryption key because it was compromised or because you lost it, you can click on the Regenerate key button in the client details to generate a new one.</p> <p></p>"},{"location":"going-further/oauth-provider-token/","title":"OAuth Provider token","text":"<p>When configuring an OAuth Provider for your app, you allow users to authenticate using their existing account on this particular service.</p> <p>But there is more: when you do this, and if you asked for the right scopes, you gain access to the API of this provider, so you can make actions on behalf of the user. For example, you could build a search engine indexing files from their Google Drive or an application to help manage GitHub issues.</p> <p>When a user authenticates using their external account, Fief automatically retrieves a valid access token that can be used to query the API of the external service.</p>"},{"location":"going-further/oauth-provider-token/#getting-a-fresh-access-token","title":"Getting a fresh access token","text":"<p>To help you integrate clever workflows into your application, Fief Admin API allows you to retrieve an access token for a given user and OAuth Provider. All you need is an Admin API key, the ID of the OAuth Provider (the one in Fief, not the Client ID) and the ID of the user. Then, you just have to make an HTTP request like this:</p> <pre><code>curl \\\n-X GET \\\n-H 'Authorization: Bearer FIEF_ADMIN_API_KEY' \\\n'https://fief.mydomain.com/admin/api/oauth-providers/OAUTH_PROVIDER_ID/access-token/USER_ID'\n</code></pre> <p>You'll then get a JSON response including a valid access token ready for you to use in the external API:</p> <pre><code>{\n  \"id\": \"8c735912-c5d6-4722-852e-f817a0d81282\",\n  \"account_id\": \"people/100817388859897448986\",\n  \"access_token\": \"ACCESS_TOKEN\",\n  \"expires_at\": \"2022-09-08T13:37:00.000Z\"\n}\n</code></pre> <p>Fief takes care of refreshing the access token if it expires. If the OAuth Provider supports it, and if you asked for the adequate scope, Fief also stores a refresh token allowing to generate fresh access tokens. This operation is done automatically when calling the endpoint above.</p>"},{"location":"going-further/pkce/","title":"PKCE","text":"<p>Proof Key for Code Exchange (PKCE) is an extension of the OAuth2 protocol to help secure public clients.</p> <p>What is a client?</p> <p>A client is a central part of the OAuth2 protocol. It's the definition of an application authorized to request for access tokens and user information on Fief. In other words, your application will need one of those client to be able to authenticate users from your Fief instance.</p> <p>Each client has a Client ID and a Client Secret. Those values are used during OAuth2 authentification to recognize the client.</p> <p>Each instance comes with one client, tied to the default tenant.</p>"},{"location":"going-further/pkce/#rationale","title":"Rationale","text":"<p>As we mentioned in a previous section, clients are considered public when the client secret can't be properly protected. This is usually the case for JavaScript applications and mobile applications, where the secret could be easily discovered in the source code.</p> <p>In OAuth2 protocol, when the user has successfully authenticated, they are redirected to your application with a temporary code, called the authorization code. This code is then used by your application to call the Fief API and obtain a valid token in exchange. For this exchange to happen, the protocol requires that you provide the client secret, to prove that you are allowed to make such requests.</p> <p>However, how could we do that for public clients where we don't have the client secret? That's the purpose of PKCE! In a nutshell, your application will generate a temporary secret each time we want to authenticate a user.</p> <p>Schematically, here is the process:</p> <pre><code>sequenceDiagram\n    actor U as User\n    participant A as Your app\n    participant F as Fief\n    U-&gt;&gt;A: Wants to login\n    rect rgb(191, 223, 255)\n    note right of A: Authorization step\n        A-&gt;&gt;A: Generates a random string, the code verifier\n        A-&gt;&gt;A: Computes the hash of this code, the code challenge\n        A-&gt;&gt;F: Redirects to Fief login page, with the code challenge\n        U-&gt;&gt;F: Authenticates on Fief\n        F-&gt;&gt;A: Redirects with the authorization code\n    end\n    rect rgb(191, 223, 255)\n    note right of A: Token generation step\n        A-&gt;&gt;F: Asks for an access token, including the code verifier\n        F-&gt;&gt;F: Computes the hash of the code verifier\n        F-&gt;&gt;F: Checks it corresponds to the code challenge it got in the first place\n        F-&gt;&gt;A: Generates a valid token\n    end</code></pre> <p>Basically, the client generates a random string, the code verifier, makes a hash out of it, the code challenge, and keep them both in memory.</p> <p>In the authorization step, the client only sends the code challenge. The server will keep this value in memory.</p> <p>In the token generation step, the client now sends the code verifier. The server will then compute the hash the same way the client did and compare it with the challenge it got in the authorization step.</p> <p>In a way, it's quite similar to how web applications handle user passwords: the server only keep the hashed value, and when the user logs in it computes the hash and compares it with the one in database.</p> <p>PKCE can also be used with confidential clients</p> <p>While initally designed for public clients, PKCE can also be used with confidential clients, as an extra security layer.</p>"},{"location":"going-further/pkce/#use-pkce-with-fief","title":"Use PKCE with Fief","text":"<p>Fief enforces the use of PKCE for public clients: you must pass the <code>code_challenge</code> and <code>code_challenge_method</code> to the <code>/authorize</code> URL.</p>"},{"location":"going-further/pkce/#javascript-integration","title":"JavaScript integration","text":"<p>Our official client comes with all the tools you need to perform PKCE.</p> <p>Browser and React integrations do it automatically!</p> <p>Actually, if you use our browser or React integration, PKCE is already handled automatically!</p> <p>If you need more control you can use the <code>crypto</code> module to generate the code verifier and challenge. Then, you can directly pass them to <code>getAuthURL</code> and <code>authCallback</code>.</p> <pre><code>const cryptoHelper = fief.crypto.getCrypto();\nconst codeVerifier = await cryptoHelper.generateCodeVerifier();\nconst codeChallenge = await cryptoHelper.getCodeChallenge(codeVerifier, 'S256');\nconst authURL = await fief.getAuthURL({\n    redirectURI: 'https://fief.mydomain.com/callback',\n    scope: ['openid'],\n    codeChallenge,\n    codeChallengeMethod: 'S256',\n);\n</code></pre> <pre><code>const [tokens, userinfo] = await fief.authCallback(\n    'CODE',\n    'https://fief.mydomain.com/callback',\n    codeVerifier,\n);\n</code></pre>"},{"location":"going-further/pkce/#other-languages","title":"Other languages","text":"<p>If you need to implement PKCE for other languages, you'll need to:</p> <ol> <li>Generate a cryptographic-safe random string of 128 characters.</li> <li>Compute the SHA-256 hash of this value and encode it in base64.</li> </ol> <p>Draw inspiration from our JavaScript implementation</p> <p>If you need an example of how to do this, you can draw inspiration from our JavaScript implementation.</p> <p>Then, you'll need to pass <code>code_challenge</code> and <code>code_challenge_method</code> parameters to the authorization URL:</p> <pre><code>GET /authorize\n    ?response_type=code\n    &amp;client_id=YOUR_CLIENT_ID\n    &amp;redirect_uri=http://localhost:8080/callback.html\n    &amp;scope=openid\n    &amp;code_challenge=mvmfsFiKEO7h5OfvxtXxJPeteUmIJpXIWhcauYbgovs\n    &amp;code_challenge_method=S256\nHTTP/1.1\nHost: fief.mydomain.com\n</code></pre> <p>Finally, when requesting the token, don't forget to pass <code>code_verifier</code>:</p> <pre><code>POST /token HTTP/1.1\nHost: fief.mydomain.com\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 155\n\ngrant_type=authorization_code\n&amp;client_id=YOUR_CLIENT_ID\n&amp;code=AUTHORIZATION_CODE\n&amp;redirect_uri=http://localhost:8080/callback.html\n&amp;code_verifier=CODE_VERIFIER\n</code></pre>"},{"location":"integrate/javascript/","title":"JavaScript","text":"<p>We provide an official client for JavaScript. You can install it with <code>npm</code>:</p> <pre><code>npm install @fief/fief\n</code></pre>"},{"location":"integrate/javascript/#create-a-fief-client","title":"Create a <code>Fief</code> client","text":"<p>The Fief client provides all the necessary methods to manage OAuth2 authentication, validate access tokens and refresh them.</p> <pre><code>const fief = new Fief({\n  baseURL: 'https://fief.mydomain.com',  // (1)!\n  clientId: 'YOUR_CLIENT_ID',  // (2)!\n  clientSecret: 'YOUR_CLIENT_SECRET', // (3)!\n});\n</code></pre> <ol> <li> <p>Base URL of your Fief tenant</p> <p>You can find it in the admin dashboard, in the Tenants list. More info</p> <p></p> </li> <li> <p>ID of your Fief client</p> <p>You can find it in the admin dashboard, in the Clients list. More info</p> <p></p> <p>Info</p> <p>A first client is always created for you when you create your instance. When getting started, you should use this one.</p> </li> <li> <p>Secret of your Fief client</p> <p>You can find it in the admin dashboard, in the Clients list. More info</p> <p></p> <p>Info</p> <p>A first client is always created for you when you create your instance. When getting started, you should use this one.</p> </li> </ol> <p>Client secret is not safe in browser-based applications</p> <p>If you build a browser-based application in JavaScript, the Client Secret is not safe: the end-user can easily find it in the source code.</p> <p>To circumvent this, Fief allows to omit the client secret for clients with the public type. However, a PKCE code challenge will be required during the authorization flow.</p>"},{"location":"integrate/javascript/#whats-next","title":"What's next?","text":"<p>JavaScript being a vast ecosystem both for browsers and servers, integration paths can be quite different following your use-case.</p> <p>To help you further, we provide you helpers and examples for popular JavaScript frameworks and technologies, like React.</p>"},{"location":"integrate/javascript/#backend","title":"Backend","text":"<p>Integrate with Express</p>"},{"location":"integrate/javascript/#server-side-rendering-ssr","title":"Server-Side Rendering (SSR)","text":"<p>Integrate with Next.js</p>"},{"location":"integrate/javascript/#frontend","title":"Frontend","text":"<p>Integrate in browser with plain JavaScript Integrate with React</p>"},{"location":"integrate/javascript/backend/express/","title":"Express","text":"<p>Express is a highly popular Node.js web framework.</p> <p>The Fief JavaScript client provides tools to help you integrate Fief authentication in your Express project. Let's see how to use them!</p>"},{"location":"integrate/javascript/backend/express/#install-the-client","title":"Install the client","text":"<pre><code>npm install @fief/fief\n</code></pre>"},{"location":"integrate/javascript/backend/express/#api-example","title":"API example","text":"<p>This is for you if...</p> <ul> <li> Your Express backend will work as a pure REST API.</li> <li> You have a separate frontend, like a JavaScript or mobile app, that'll take care of the OAuth2 flow.</li> </ul> <p>In this first example, we won't implement routes to perform the OAuth2 authentication. The goal here is just to show you how to protect your API route with a Fief access token.</p> app.js<pre><code>const fief = require('@fief/fief');\nconst fiefExpress = require('@fief/fief/express');\nconst express = require('express');\n\nconst PORT = 3000;\n\nconst fiefClient = new fief.Fief({  // (1)!\n  baseURL: 'https://fief.mydomain.com',\n  clientId: 'YOUR_CLIENT_ID',\n  clientSecret: 'YOUR_CLIENT_SECRET',\n});\n\nconst fiefAuthMiddleware = fiefExpress.createMiddleware({  // (2)!\n  client: fiefClient,  // (3)!\n  tokenGetter: fiefExpress.authorizationSchemeGetter(),  // (4)!\n});\n\nconst app = express();\n\napp.get('/authenticated', fiefAuthMiddleware(), (req, res) =&gt; {  // (5)!\n  res.json(req.accessTokenInfo);  // (6)!\n});\n\napp.get('/authenticated-scope', fiefAuthMiddleware({ scope: ['openid', 'required_scope'] }), (req, res) =&gt; {  // (7)!\n  res.json(req.accessTokenInfo);\n});\n\napp.get('/authenticated-permissions', fiefAuthMiddleware({ permissions: ['castles:read'] }), (req, res) =&gt; {  // (8)!\n  res.json(req.accessTokenInfo);\n});\n\napp.listen(PORT, () =&gt; {\n  console.log(`Example app listening on port ${PORT}`)\n});\n</code></pre> <ol> <li> <p>Fief client instantiation</p> <p>As we showed in the standard JavaScript section, we instantiate here a Fief client here with the base tenant URL and client credentials.</p> </li> <li> <p>Middleware helper</p> <p>The <code>fiefExpress</code> module exposes the <code>createMiddleware</code> function which returns a proper middleware to use in your Express routes.</p> </li> <li> <p>The Fief client</p> <p>The first mandatory parameter is the Fief client we just created above.</p> </li> <li> <p>The token getter</p> <p>The second mandatory parameter is a function retrieving the access token from an Express request.</p> <p>You can create yours, as long as it follows the TokenGetter signature, or you can use the ones we provide.</p> <p>Here, we use <code>authorizationSchemeGetter</code>, which will retrieve the token from an <code>Authorization</code> header with the <code>Bearer</code> scheme: <code>Authorization: Bearer ACCESS_TOKEN</code></p> </li> <li> <p>Use the middleware in your route</p> <p>If you want to protect a route, all you need to do is to add your <code>fiefAuthMiddleware</code> instance as a middleware.</p> <p>When your handler is called, you're sure the user is authenticated with a valid session.</p> </li> <li> <p><code>accessTokenInfo</code> is available in <code>req</code></p> <p>In your route handler, you have access to the <code>accessTokenInfo</code> object in <code>req</code>.</p> <p><code>accessTokenInfo</code> is a <code>FiefAccessTokenInfo</code> object containing the ID of the user, the list of allowed scopes and permissions and the raw access token.</p> </li> <li> <p>Check for scopes</p> <p><code>fiefAuthMiddleware</code> accepts an optional <code>scope</code> parameter where you can list the scope required to access this route.</p> <p>If the access token doesn't have the required scope, the forbidden response is returned.</p> </li> <li> <p>Check for permissions</p> <p><code>fiefAuthMiddleware</code> accepts an optional <code>perrmissions</code> parameter where you can list the permissions required to access this route.</p> <p>If the access token doesn't have the required permissions, the forbidden response is returned.</p> </li> </ol>"},{"location":"integrate/javascript/backend/express/#web-application-example","title":"Web application example","text":"<p>This is for you if...</p> <ul> <li> Your Express backend will render HTML pages.</li> <li> Your application is intended to be used in a browser.</li> </ul> <p>Prerequisites</p> <ul> <li> Allow the following Redirect URI on your Fief Client: <code>http://localhost:3O00/auth-callback</code></li> </ul> <p>The examples we showed previously are working well in a pure REST API context: a frontend, like interactive documentation, a JavaScript application or a mobile app will take care of the OAuth2 authentication flow to retrieve an access token before making request to your API.</p> <p>Another common context is traditional web application, where the server takes care of generating HTML pages before returning it to the browser. In this case, we'll need some routes to redirect the user to the Fief login page if they're not authenticated and take care of storing the access token somewhere. This is what'll show in this example.</p> <p>Besides, we'll usually need the basic information about the authenticated user, like its email or the values of the custom user fields. We'll see how we can use it.</p> <p>Basically, here's what we'll do:</p> <ol> <li>This time, we'll expect the access token to be passed through a traditional cookie instead of an HTTP header. Cookies are very convenient when designing web apps because they are handled automatically by the browser.</li> <li>If the cookie is not present, we'll redirect the user to the Fief login page. Once again, the browser will help us a lot here since it'll automatically follow the redirection.</li> <li>Upon successful login, Fief will automatically redirect the user to the callback route. This callback route will take care of setting a new cookie containing the access token. It means that the access token will be safely stored in the browser memory.</li> <li>Finally, the user is redirected back to the protected route. The browser will automatically send the cookie containing the access token: our request is now authenticated!</li> </ol> app.js<pre><code>const fief = require('@fief/fief');\nconst fiefExpress = require('@fief/fief/express');\nconst express = require('express');\n\nconst SESSION_COOKIE_NAME = \"user_session\"  // (1)!\nconst PORT = 3000;\nconst REDIRECT_URI = `http://localhost:${PORT}/auth-callback`;  // (2)!\n\nclass MemoryUserInfoCache {  // (3)!\n  constructor() {\n    this.storage = {};\n  }\n\n  async get(id) {\n    const userinfo = this.storage[id];\n    if (userinfo) {\n      return userinfo;\n    }\n    return null;\n  }\n\n  async set(id, userinfo) {\n    this.storage[id] = userinfo;\n  }\n\n  async remove(id) {\n    this.storage[id] = undefined;\n  }\n\n  async clear() {\n    this.storage = {};\n  }\n}\n\nconst userInfoCache = new MemoryUserInfoCache();\n\nconst fiefClient = new fief.Fief({  // (4)!\n  baseURL: 'https://fief.mydomain.com',\n  clientId: 'YOUR_CLIENT_ID',\n  clientSecret: 'YOUR_CLIENT_SECRET',\n});\n\nconst unauthorizedResponse = async (req, res) =&gt; {  // (5)!\n  const authURL = await fiefClient.getAuthURL({ redirectURI: REDIRECT_URI, scope: ['openid'] });  // (6)!\n  res.redirect(307, authURL);  // (7)!\n};\n\nconst fiefAuthMiddleware = fiefExpress.createMiddleware({\n  client: fiefClient,\n  tokenGetter: fiefExpress.cookieGetter(SESSION_COOKIE_NAME),  // (8)!\n  unauthorizedResponse,  // (9)!\n  userInfoCache,  // (10)!\n});\n\nconst app = express();\n\napp.get('/auth-callback', async (req, res) =&gt; {  // (11)!\n  const code = req.query['code'];\n  const [tokens, userinfo] = await fiefClient.authCallback(code, REDIRECT_URI);  // (12)!\n\n  userInfoCache.set(userinfo.sub, userinfo);  // (13)!\n\n  res.cookie(  // (14)!\n    SESSION_COOKIE_NAME,\n    tokens.access_token,\n    {\n      maxAge: tokens.expires_in * 1000,\n      httpOnly: true,  // (15)!\n      secure: false,  // \u274c Set this to `true` in production (16)!\n    },\n  );\n  res.redirect('/protected');\n});\n\napp.get('/protected', fiefAuthMiddleware(), (req, res) =&gt; {  // (17)!\n  res.send(`&lt;h1&gt;You are authenticated. Your user email is ${req.user.email}&lt;/h1&gt;`)  // (18)!\n});\n\napp.listen(PORT, () =&gt; {\n  console.log(`Example app listening on port ${PORT}`)\n});\n</code></pre> <ol> <li> <p>Define a session cookie name constant</p> <p>As we said, we'll use a cookie to maintain the user session.</p> <p>For convenience, we set its name in a constant.</p> </li> <li> <p>Define a redirect URI constant</p> <p>After the user has succesfully authenticated on Fief, our user will need to be redirected to our application so we can get the access token and set our session.</p> <p>This constant is an absolute URL to our <code>/auth-callback</code> route we define below.</p> <p>In a production environment, it should corresponds to your actual domain.</p> </li> <li> <p>Implement a user information cache</p> <p>To make sure we don't call the Fief API every time we want the user data, we'll cache it in our application. It'll be way more performant!</p> <p>To do this, we impement a class following the <code>IUserInfoCache</code> interface.</p> <p>In this example, we use very simple approach that will just store the data in memory. If your server is rebooted, the cache will be lost.</p> <p>It can work quite well when starting, but you'll probably need more robust approaches in the long run, like writing to a Redis store. The good thing is that you'll only need to change this class when the time comes!</p> </li> <li> <p>This doesn't change from the previous example</p> <p>The <code>Fief</code> client is always at the heart of the integration \ud83d\ude09</p> </li> <li> <p>Define a custom unauthorized response</p> <p>By default, the Express integration will return a 401 response when the user is not authenticated.</p> <p>In our case here, we want them to be redirected to Fief authentication page.</p> </li> <li> <p>We generate an authorization URL on the Fief server</p> <p>Thanks to the <code>getAuthURL</code> method on the Fief client, we can automatically generate the authorization URL on the Fief server.</p> </li> <li> <p>We build a redirect response</p> <p>We redirect the user to the Fief authorization URL.</p> </li> <li> <p>We use a cookie getter</p> <p>Contrary to the previous examples, we expect the access token to be passed in a cookie. Thus, we use the provided <code>cookieGetter</code> function.</p> <p>Notice that we pass it the cookie name, <code>SESSION_COOKIE_NAME</code>, as parameter.</p> </li> <li> <p>We use our custom unauthorized response</p> <p>We tell the middleware about our customer handler we defined above.</p> </li> <li> <p>We use our user information cache</p> <p>We tell the middleware about our user information cache, so it can use it to save and retrieve the data.</p> </li> <li> <p>We implement an <code>/auth-callback</code> route</p> <p>This is the route that'll take care of exchanging the authorization code with a fresh access token and save it in a cookie.</p> </li> <li> <p>We generate an access token</p> <p>We finish the OAuth2 flow by exchanging the authorization code with a fresh access token.</p> </li> <li> <p>We cache the user information</p> <p>When a user has successfully authenticated, we do not only get the access token: we also get an ID token which already contains the user information.</p> <p>Hence, we'll take this opportunity to store it in our cache! The ID token is automatically decoded by <code>fiefClient.authCallback</code> method.</p> <p>Thus, we just have to use our cache helper to store it!</p> </li> <li> <p>We build a new cookie containing the access token</p> <p>The response will contain a <code>Set-Cookie</code> header instructing the browser to save the access token in its memory. This method allows us to configure each properties of the cookie.</p> <p>You can read more about HTTP cookies on the MDN documentation.</p> </li> <li> <p>Set the cookie as <code>HTTPOnly</code></p> <p>For such sensitive values, it's strongly recommended to set the cookie as <code>HTTPOnly</code>. It means that it won't be possible to read its value from JavaScript, reducing potential attacks.</p> </li> <li> <p>Set the cookie as secure in production</p> <p>For such sensitive values, it's strongly recommended to set the cookie as <code>Secure</code>. It tells the browser to send the cookie only on HTTPS (SSL) connection, reducing the risk of the access token to be stolen by a attacker between the client and the server.</p> <p>However, in a local environment, you usually don't serve your application with SSL. That's why we set it to <code>false</code> in this example. A common approach to handle this is to have an environment variable to control this parameter, so you can disable it in local and enable it in production.</p> </li> <li> <p>We implement a <code>/protected</code> route</p> <p>Now, we can just use our <code>fiefAuthMiddleware</code> to protect our routes.</p> </li> <li> <p><code>user</code> object is available in <code>req</code></p> <p>If the request is properly authenticated, the middleware will automatically add the <code>user</code> obkect to <code>req</code>.</p> <p><code>user</code> is a <code>FiefUserInfo</code> object containing the user data. If it's not available in cache, it's automatically retrieved from the Fief API.</p> </li> </ol> <p>That's it! If you run this application and go to http://localhost:3000/protected, you'll be redirected to the Fief login page and experience the authentication flow before getting back to this route with a proper authentication cookie.</p>"},{"location":"integrate/javascript/frontend/browser/","title":"Browser","text":"<p>It's possible to manage authentication with Fief entirely within the browser, using a bit of JavaScript.</p> <p>To help you in this task, the Fief JavaScript client provides tools dedicated to the browser environment. Let's see how to use them!</p>"},{"location":"integrate/javascript/frontend/browser/#install-the-client","title":"Install the client","text":"<p>The recommended way to install the client is to use <code>npm</code>:</p> <pre><code>npm install @fief/fief\n</code></pre> <p>However, if you don't use a JavaScript bundler, like Webpack, you can include the package directly in a browser script, thanks to UNPKG CDN:</p> <pre><code>&lt;script src=\"https://unpkg.com/@fief/fief/build/index.umd.js\"&gt;&lt;/script&gt; &lt;!-- (1)! --&gt;\n&lt;script&gt;\n    console.log(fief); // Module is available globally under the `fief` variable\n&lt;/script&gt;\n</code></pre> <ol> <li> <p>This will always load the latest version</p> <p>You should pin the version to avoid problems when we update the client and improve the loading time.</p> <p>For example, to load the version <code>0.10.1</code>:</p> <pre><code>&lt;script src=\"https://unpkg.com/@fief/fief@0.10.1/build/index.umd.js\"&gt;&lt;/script&gt;\n</code></pre> </li> </ol>"},{"location":"integrate/javascript/frontend/browser/#application-example","title":"Application example","text":"<p>This is for you if...</p> <ul> <li> You want to handle all the OAuth authentication in the browser.</li> </ul> <p>Prerequisites</p> <ul> <li> Make sure your Fief Client is Public.</li> <li> Allow the following Redirect URI on your Fief Client: <code>http://localhost:8080/callback.html</code></li> <li> Install http-server, a simple Node.js HTTP server: <code>npm i --global http-server</code></li> </ul> <p>In this example, we'll show you a very simple HTML and JavaScript application to perform the OAuth2 authentication. We'll define two pages:</p> <ul> <li><code>index.html</code>: it'll show if the user is logged in or not, and display a Login button.</li> <li><code>callback.html</code>: the page Fief will redirect the user to after a successful login to complete the OAuth authentication.</li> </ul> <p>Let's see the first one:</p> index.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Fief JavaScript Browser example&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"logged-out\" style=\"display: none\"&gt; &lt;!-- (1)! --&gt;\n      &lt;h1&gt;You are not logged in&lt;/h1&gt;\n      &lt;button type=\"button\" id=\"login-button\"&gt;Login&lt;/button&gt;\n    &lt;/div&gt;\n    &lt;div id=\"logged-in\" style=\"display: none\"&gt; &lt;!-- (2)! --&gt;\n      &lt;h1&gt;Hello &lt;span id=\"user-email\"&gt;&lt;/span&gt; \ud83d\udc4b&lt;/h1&gt;\n      &lt;button type=\"button\" id=\"logout-button\"&gt;Logout&lt;/button&gt;\n    &lt;/div&gt;\n    &lt;script src=\"https://unpkg.com/@fief/fief/build/index.umd.js\"&gt;&lt;/script&gt;\n    &lt;script&gt;\n      const initialize = () =&gt; {\n        const fiefClient = new fief.Fief({  // (3)!\n          baseURL: 'https://fief.mydomain.com',\n          clientId: 'YOUR_CLIENT_ID',\n        });\n        const fiefAuth = new fief.browser.FiefAuth(fiefClient);  // (4)!\n\n        document.getElementById('login-button').addEventListener('click', () =&gt; {\n          fiefAuth.redirectToLogin('http://localhost:8080/callback.html');  // (5)!\n        });\n\n        document.getElementById('logout-button').addEventListener('click', () =&gt; {\n          fiefAuth.logout('http://localhost:8080');  // (6)!\n        });\n\n        const userinfo = fiefAuth.getUserinfo();  // (7)!\n\n        if (userinfo !== null) {  // (8)!\n          document.getElementById('logged-in').style.display = 'block';\n          document.getElementById('logged-out').style.display = 'none';\n\n          document.getElementById('user-email').textContent = userinfo.email;\n        } else {  // (9)!\n          document.getElementById('logged-in').style.display = 'none';\n          document.getElementById('logged-out').style.display = 'block';\n        }\n      };\n\n      document.addEventListener('DOMContentLoaded', initialize, false);\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <ol> <li> <p>HTML block for when the user is not logged in</p> <p>It simply contains a generic title and a login button.</p> </li> <li> <p>HTML block for when the user is logged in</p> <p>We greet the logged in user with their email address and show them a logout button.</p> </li> <li> <p>Fief client instantiation</p> <p>As we showed in the JavaScript section, we instantiate here a Fief client here with the base tenant URL and client credentials.</p> <p>Notice here that we omit the Client Secret. Indeed, the secret can't be kept safe in the browser: the end-user can easily find it in the source code.</p> <p>That's why we set the Fief Client as Public: we allow it to make authentication requests without the Client Secret.</p> </li> <li> <p>Fief helper for the browser</p> <p>This is the helper doing the tedious work for you in the browser. All it needs is an instance of the Fief client.</p> <p>Under the hood, <code>FiefAuth</code> will store the user session data on the browser SessionStorage. This is how we'll maintain the logged-in state of the user during its visit.</p> </li> <li> <p>When the login button is clicked, redirect to Fief login page</p> <p>We simply add an event listener on the button to start the authorization process when it's clicked.</p> <p>We use the <code>FiefAuth</code> helper for this. All it needs is the redirect URL where the user will be redirected after a successful authentication on Fief: the <code>callback.html</code> page.</p> <p>Under the hood, <code>FiefAuth</code> takes care of generating a PKCE code challenge for maximum security!</p> </li> <li> <p>When the logout button is clicked, clear session and redirect to Fief logout page</p> <p>We simply add an event listener on the button to logout the user.</p> <p>The <code>FiefAuth</code> helper takes care of clearing the local session and redirect to the Fief logout page so that the session on Fief's side can also be cleared.</p> <p>All it needs is the redirect URL where the user will be redirected after a successful logout. Here, we go back to the <code>index.html</code> page.</p> </li> <li> <p>Get user information in session</p> <p>The <code>getUserinfo</code> method of <code>FiefAuth</code> allows to retrieve the user information stored in session, if any.</p> </li> <li> <p>User information is available</p> <p>The user is logged in \ud83d\udc4d We can show the right HTML block and fill the user email to greet them properly.</p> </li> <li> <p>User information is not available</p> <p>The user is not logged in \ud83d\ude14 We can show the right HTML block with the login button.</p> </li> </ol> <p>As you can see, the JavaScript code is quite short! Most of the tedious work is done by the <code>FiefAuth</code> helper, which takes care of storing the session in the browser and authenticating the client with PKCE.</p> <p>Let's now see the <code>callback.html</code> page:</p> callback.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;Fief JavaScript Browser example&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;script src=\"https://unpkg.com/@fief/fief/build/index.umd.js\"&gt;&lt;/script&gt;\n    &lt;script&gt;\n      const initialize = () =&gt; {\n        const fiefClient = new fief.Fief({\n          baseURL: 'https://fief.mydomain.com',\n          clientId: 'YOUR_CLIENT_ID',\n        });\n        const fiefAuth = new fief.browser.FiefAuth(fiefClient);  // (1)!\n\n        fiefAuth.authCallback('http://localhost:8080/callback.html').then(  // (2)!\n          () =&gt; {\n            window.location.href = 'http://localhost:8080';\n          }\n        );\n      };\n\n      document.addEventListener('DOMContentLoaded', initialize, false);\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <ol> <li> <p>This doesn't change</p> <p>We once again instantiate a Fief client and the browser helper.</p> </li> <li> <p>We call the <code>authCallback</code> method</p> <p>This method takes care of everything: retrieving the authorization code in the query parameters, exchanging it with a fresh access token and save it in the browser session.</p> <p>Once the promise is resolved, all we have to do is to redirect back to the <code>index.html</code> page.</p> </li> </ol> <p>That's it! Assuming you have both files in a directory named <code>app-directory</code>, you can run this application using <code>http-server</code>:</p> <pre><code>http-server app-directory/\n</code></pre> <p>It'll make it available on http://localhost:8080. The first time you open it, you'll be logged out:</p> <p></p> <p>If you click on the Login button, you'll be redirected to Fief to authenticate. Once done, you'll be redirected to your application and should be properly logged in:</p> <p></p> <p>You can also try the Logout button to see how the session is cleared.</p>"},{"location":"integrate/javascript/frontend/browser/#call-an-api-with-an-access-token","title":"Call an API with an access token","text":"<p>In most cases, you'll have an API backend from which you can read or write data to display to the user in your web application.</p> <p>To secure your API, you can make it require a valid Fief access token, so we are sure the call is made from an authenticated user. This is what we show for example in the FastAPI or Flask API examples.</p> <p>From your browser application, you can perform XHR requests in JavaScript. All you need is to pass a valid access token in the <code>Authorization</code> header of your request.</p> <p>When a user is authenticated, you can get the current access token using the <code>fiefAuth.getTokenInfo</code> method. We show below an example of an HTTP request made to your backend using <code>fetch</code>:</p> <pre><code>const tokenInfo = fiefAuth.getTokenInfo();\nconst accessToken = tokenResponse.access_token;\nconst response = await fetch(\n    'http://localhost:8000/user',\n    {\n        headers: {\n            Authorization: `Bearer ${accessToken}`,\n        }\n    }\n);\ndata = response.json();\n</code></pre>"},{"location":"integrate/javascript/frontend/react/","title":"React","text":"<p>React is one of the most popular JavaScript framework to build dynamic applications for the browser.</p> <p>The Fief JavaScript client provides tools to help you integrate Fief authentication in your React project. Let's see how to use them!</p>"},{"location":"integrate/javascript/frontend/react/#install-the-client","title":"Install the client","text":"<pre><code>npm install @fief/fief\n</code></pre>"},{"location":"integrate/javascript/frontend/react/#application-example","title":"Application example","text":"<p>This is for you if...</p> <ul> <li> You want to handle all the OAuth authentication in your React application.</li> </ul> <p>Prerequisites</p> <ul> <li> You have a React project setup.</li> <li> Make sure your Fief Client is Public.</li> <li> Allow the following Redirect URI on your Fief Client: <code>http://localhost:3000/callback</code></li> </ul> <p>In this example, we'll show you how to use the components and hooks provided by Fief to authenticate users and protect routes using React Router.</p>"},{"location":"integrate/javascript/frontend/react/#setup-fiefauthprovider","title":"Setup <code>FiefAuthProvider</code>","text":"<p>The <code>FiefAuthProvider</code> is a component providing all the necessary context for Fief, especially the Fief client and user session state. Every component nested inside this component will have access to the Fief hooks.</p> App.tsx<pre><code>import { FiefAuthProvider } from '@fief/fief/react';\nimport { Routes, Route } from 'react-router-dom';\n\nimport Callback from './Callback';\nimport Public from './Public';\nimport Private from './Private';\nimport Header from './Header';\nimport RequireAuth from './RequireAuth';\n\nfunction App() {\n  return (\n    &lt;FiefAuthProvider // (1)!\n      baseURL=\"https://fief.mydomain.com\"\n      clientId=\"NFL8Ycdag-gbvO-5pJezwCmFEouCDRhCG4paUNOaDoI\"\n    &gt;\n      &lt;div className=\"App\"&gt;\n        &lt;h1&gt;Fief React example&lt;/h1&gt;\n        &lt;Header /&gt;  {/* (2)! */}\n        &lt;Routes&gt;  {/* (3)! */}\n          &lt;Route path=\"/\" element={&lt;Public /&gt;} /&gt; {/* (4)! */}\n          &lt;Route path=\"/private\" element={&lt;RequireAuth&gt;&lt;Private /&gt;&lt;/RequireAuth&gt;} /&gt; {/* (5)! */}\n          &lt;Route path=\"/callback\" element={&lt;Callback /&gt;} /&gt; {/* (6)! */}\n        &lt;/Routes&gt;\n      &lt;/div&gt;\n    &lt;/FiefAuthProvider&gt;\n  );\n}\n\nexport default App;\n</code></pre> <ol> <li> <p>Declare the <code>FiefAuthProvider</code></p> <p>This is necessary to give to nested components the right Fief context and makes the hooks working.</p> <p>It takes as properties the same arguments as the <code>Fief</code>  client.</p> </li> <li> <p>A <code>Header</code> component</p> <p>Contains the navigation. We'll detail it in a moment.</p> </li> <li> <p>The <code>Routes</code> component from React Router</p> </li> <li> <p>A public route</p> <p>This route will be accessible by any visitor, even if not logged in.</p> </li> <li> <p>A private route</p> <p>This route will be accessible only by logged in users. To do this, we wrap it in a <code>RequireAuth</code> component. We'll detail it in a moment.</p> </li> <li> <p>A callback route</p> <p>The route where Fief will redirect the user to after a successful login to complete the OAuth authentication.</p> </li> </ol> <p>At this point, your React app has everything it needs to use Fief authentication tools!</p>"},{"location":"integrate/javascript/frontend/react/#implement-callback-route","title":"Implement callback route","text":"<p>After the user has successfully logged in on Fief, they will be redirected to your callback route. It needs to exchange the authorization code with a proper access token.</p> <p>The role of this route is then just to perform this task before redirecting to another route.</p> Callback.tsx<pre><code>import { useFiefAuth } from '@fief/fief/react';\nimport { useEffect } from 'react';\nimport { useNavigate } from 'react-router-dom';\n\nconst Callback: React.FunctionComponent = () =&gt; {\n  const fiefAuth = useFiefAuth();  // (1)!\n  const navigate = useNavigate();\n\n  useEffect(() =&gt; {\n    fiefAuth.authCallback(`${window.location.protocol}//${window.location.host}/callback`).then(() =&gt; {  // (2)!\n      navigate('/');\n    });\n  }, [fiefAuth, navigate]);\n\n  return (\n    &lt;p&gt;Callback!&lt;/p&gt;\n  );\n};\n\nexport default Callback;\n</code></pre> <ol> <li> <p>Hook to get the <code>FiefAuth</code> class</p> <p>This is the browser helper provided by the Fief JavaScript client.</p> </li> <li> <p>We call the <code>authCallback</code> method</p> <p>This method takes care of everything: retrieving the authorization code in the query parameters, exchanging it with a fresh access token and save it in the browser session.</p> <p>Once the promise is resolved, all we have to do is to redirect back to the index page.</p> </li> </ol>"},{"location":"integrate/javascript/frontend/react/#protect-private-routes","title":"Protect private routes","text":"<p>Usually, you'll need to prevent visitors from accessing a page if they're not logged in.</p> <p>To do this, we implement a simple component that'll check for the authentication state and automatically redirect to the Fief authentication page if the user is not logged in.</p> RequireAuth.tsx<pre><code>import { useFiefAuth, useFiefIsAuthenticated } from '@fief/fief/react';\nimport React, { useEffect } from 'react';\n\nconst RequireAuth: React.FunctionComponent&lt;React.PropsWithChildren&gt; = ({ children }) =&gt; {\n  const fiefAuth = useFiefAuth();  // (1)!\n  const isAuthenticated = useFiefIsAuthenticated(); // (2)!\n\n  useEffect(() =&gt; {\n    if (!isAuthenticated) {\n      fiefAuth.redirectToLogin(`${window.location.protocol}//${window.location.host}/callback`);  // (3)!\n    }\n  }, [fiefAuth, isAuthenticated]);\n\n  return (\n    &lt;&gt;\n      {isAuthenticated &amp;&amp; children}\n    &lt;/&gt;\n  );\n};\n\nexport default RequireAuth;\n</code></pre> <ol> <li> <p>Hook to get the <code>FiefAuth</code> class</p> <p>This is the browser helper provided by the Fief JavaScript client.</p> </li> <li> <p>Hook to get the authentication state</p> <p>This hook simply returns a boolean stating if a user is logged in or not.</p> </li> <li> <p>Redirect to Fief authentication page</p> <p>With this effect, we automatically redirect the user to the Fief authentication page so that they can log in.</p> <p>The <code>redirectToLogin</code> method only needs the redirect URL where the user will be redirected after a successful authentication on Fief: the <code>/callback</code> route.</p> </li> </ol>"},{"location":"integrate/javascript/frontend/react/#manage-authentication","title":"Manage authentication","text":"<p>You have access to a set of hooks to help you manage the authentication state of the user, like retrieving their information, redirect them to the authentication page or logout them.</p> <p>In the example below, we show a simple header with navigation links and a login or logout button.</p> Header.tsx<pre><code>import { useFiefAuth, useFiefIsAuthenticated, useFiefUserinfo } from '@fief/fief/react';\nimport React, { useCallback } from 'react';\nimport { Link } from 'react-router-dom';\n\nconst Header: React.FunctionComponent = () =&gt; {\n  const fiefAuth = useFiefAuth();\n  const isAuthenticated = useFiefIsAuthenticated();\n  const userinfo = useFiefUserinfo();  // (1)!\n\n  const login = useCallback(() =&gt; {  // (2)!\n    fiefAuth.redirectToLogin(`${window.location.protocol}//${window.location.host}/callback`);\n  }, [fiefAuth]);\n\n  const logout = useCallback(() =&gt; {  // (3)!\n    fiefAuth.logout(`${window.location.protocol}//${window.location.host}`);\n  }, [fiefAuth]);\n\n  return (\n    &lt;ul&gt;\n      &lt;li&gt;&lt;Link to=\"/\"&gt;Public page&lt;/Link&gt;&lt;/li&gt;\n      &lt;li&gt;&lt;Link to=\"/private\"&gt;Private page&lt;/Link&gt;&lt;/li&gt;\n      &lt;li&gt;\n        {!isAuthenticated &amp;&amp; &lt;button type=\"button\" onClick={() =&gt; login()}&gt;Login&lt;/button&gt;}\n        {isAuthenticated &amp;&amp; userinfo &amp;&amp; (\n          &lt;div&gt;\n            &lt;span&gt;{userinfo.email}&lt;/span&gt;\n            &lt;button type=\"button\" onClick={() =&gt; logout()}&gt;Logout&lt;/button&gt;\n          &lt;/div&gt;\n        )}\n      &lt;/li&gt;\n    &lt;/ul&gt;\n  );\n};\n\nexport default Header;\n</code></pre> <ol> <li> <p>Hook to get user information</p> <p>It'll return you an object with the user information, or <code>null</code> if no user is authenticated.</p> </li> <li> <p>Callback to redirect to Fief authentication page</p> <p>When the login button is clicked, this callback will redirect to the Fief authentication page. This is exactly the same thing we showed in the <code>RequireAuth</code> component.</p> </li> <li> <p>Callback to logout</p> <p>When the logout button is clicked, this callback will start the logout process.</p> <p>The <code>FiefAuth</code> helper takes care of clearing the local session and redirect to the Fief logout page so that the session on Fief's side can also be cleared.</p> <p>All it needs is the redirect URL where the user will be redirected after a successful logout. Here, we go back to the index route.</p> </li> </ol>"},{"location":"integrate/javascript/frontend/react/#call-an-api-with-an-access-token","title":"Call an API with an access token","text":"<p>In most cases, you'll have an API backend from which you can read or write data to display to the user in your web application.</p> <p>To secure your API, you can make it require a valid Fief access token, so we are sure the call is made from an authenticated user. This is what we show for example in the FastAPI or Flask API examples.</p> <p>From your browser application, you can perform XHR requests in JavaScript. All you need is to pass a valid access token in the <code>Authorization</code> header of your request.</p> <p>When a user is authenticated, you can get the current access token using the <code>useFiefTokenInfo</code> hook. We show below an example of an HTTP request made to your backend using <code>fetch</code>:</p> <pre><code>const tokenInfo = useFiefTokenInfo();\nconst [data, setData] = useState();\n\nuseEffect(() =&gt; {\n    const accessToken = tokenInfo.access_token;\n    fetch(\n        'http://localhost:8000/user',\n        {\n            headers: {\n                Authorization: `Bearer ${accessToken}`,\n            }\n        }\n    ).then((response) =&gt; {\n        setData(response.json());\n    });\n}, [tokenInfo]);\n</code></pre>"},{"location":"integrate/javascript/ssr/nextjs-app/","title":"Next.js (App Router)","text":"<p>Next.js is a highly popular JavaScript framework for Server-Side Rendering. The Fief JavaScript client provides tools dedicated to Next.js. Let's see how to use them!</p>"},{"location":"integrate/javascript/ssr/nextjs-app/#install-the-client","title":"Install the client","text":"<pre><code>npm install @fief/fief\n</code></pre>"},{"location":"integrate/javascript/ssr/nextjs-app/#the-big-picture","title":"The big picture","text":"<p>To make integration seamless, we use a middleware to handle the authentication process. When the user is successfully authenticated, this middleware will set headers that can be read by layouts and pages to retrieve user information.</p> <pre><code>graph LR\n    subgraph Next.js\n        M[Middleware]\n        P[Page]\n    end\n    F[Fief]\n    RQ((Request))\n    RQ --&gt; M\n    M -- not authenticated --&gt; F\n    F -- callback --&gt; M\n    M -- authenticated --&gt; P</code></pre>"},{"location":"integrate/javascript/ssr/nextjs-app/#middleware","title":"Middleware","text":"<p>In most recent versions, Next.js introduced Middleware. It's a useful mechanism allowing us to define logic before every request. Next.js team designed it to be highly performant: it's executed by their Edge Runtime technology, a special runtime different from Node.js.</p> <p>In Fief implementation, we'll use the Middleware to check if the user is authenticated and if they have the right scope and permissions.</p> <p>Besides, it'll also automatically handle special routes dedicated to authentication:</p> <ul> <li><code>/login</code> will redirect to Fief authentication page.</li> <li><code>/auth-callback</code> will complete the OAuth2 callback and set the session cookie;</li> <li><code>/logout</code> will clear the session cookie and redirect to Fief logout.</li> </ul>"},{"location":"integrate/javascript/ssr/nextjs-app/#pages-and-layout","title":"Pages and layout","text":"<p>The actual pages and layouts of our app will then only have to read the information set by the middleware on the server side to get information about the user and render the components, passing the data through props as needed.</p>"},{"location":"integrate/javascript/ssr/nextjs-app/#configure-your-project","title":"Configure your project","text":"<p>This is for you if...</p> <ul> <li> You use Next.js with App Router.</li> </ul> <p>Prerequisites</p> <ul> <li> Bootstrap a Next.js project as described in Automatic Setup section of the Next.js documentation.</li> <li> Allow the following Redirect URI on your Fief Client: <code>http://localhost:3000/auth-callback</code></li> </ul>"},{"location":"integrate/javascript/ssr/nextjs-app/#1-create-a-fief-module","title":"1. Create a <code>fief</code> module","text":"<p>Let's create a <code>fief.ts</code> module at the root of the project. It'll contain the basic instantiation of Fief helpers.</p> fief.ts<pre><code>import { Fief, FiefUserInfo } from '@fief/fief';\nimport { FiefAuth, IUserInfoCache } from '@fief/fief/nextjs';\n\nexport const SESSION_COOKIE_NAME = \"user_session\";  // (1)!\n\nexport const fiefClient = new Fief({  // (2)!\n  baseURL: 'http://localhost:8000',\n  clientId: 'YOUR_CLIENT_ID',\n  clientSecret: 'YOUR_CLIENT_SECRET',\n  requestInit: { next: { revalidate: 3600 } },\n});\n\nexport const fiefAuth = new FiefAuth({  // (3)!\n  client: fiefClient,  // (4)!\n  sessionCookieName: SESSION_COOKIE_NAME,  // (5)!\n  redirectURI: 'http://localhost:3000/auth-callback',  // (6)!\n  logoutRedirectURI: 'http://localhost:3000',  // (7)!\n});\n</code></pre> <ol> <li> <p>Define a session cookie name constant</p> <p>We'll use a cookie to maintain the user session.</p> <p>For convenience, we set its name in a constant.</p> </li> <li> <p>Fief client instantiation</p> <p>As we showed in the standard JavaScript section, we instantiate here a Fief client here with the base tenant URL and client credentials.</p> </li> <li> <p>Fief helper for Next.js</p> <p>This is the helper doing the tedious work for you with Next.js.</p> <p>We'll review here the required parameters. You can have a complete list of parameters in the reference documentation.</p> </li> <li> <p>The Fief client</p> <p>The first mandatory parameter is the Fief client we just created above.</p> </li> <li> <p>The session cookie name</p> <p>We pass the constant we defined above.</p> </li> <li> <p>Absolute redirect URI</p> <p>After the user has succesfully authenticated on Fief, our user will need to be redirected to our application so we can get the access token and set our session.</p> <p>This constant is an absolute URL to the <code>/auth-callback</code> route the Middleware will handle.</p> </li> <li> <p>Absolute redirect URI after logout</p> <p>When logging out, the user is redirected to Fief so the session stored on Fief's side can also be cleared.</p> <p>After that, Fief will redirect the user to your application. This parameter allows you to set the page where they should be redirected.</p> <p>Typically, this can be the home page of your application.</p> </li> </ol>"},{"location":"integrate/javascript/ssr/nextjs-app/#2-add-the-middleware","title":"2. Add the Middleware","text":"<p>If not already, create a <code>middleware.ts</code> module at the root of the project.</p> middleware.ts<pre><code>import type { NextRequest } from 'next/server';\n\nimport { fiefAuth } from './fief';  // (1)!\n\nconst authMiddleware = fiefAuth.middleware([  // (2)!\n  {\n    matcher: '/private',  // (3)!\n    parameters: {},\n  },\n  {\n    matcher: '/castles/:path*',  // (4)!\n    parameters: {\n      permissions: ['castles:read'],  // (5)!\n    },\n  },\n  {\n    matcher: '/:path*',  // (6)!\n    parameters: {\n      optional: true,\n    },\n  },\n]);\n\nexport async function middleware(request: NextRequest) {  // (7)!\n  return authMiddleware(request);  // (8)!\n};\n</code></pre> <ol> <li> <p>Import the <code>fiefAuth</code> instance from <code>fief</code> module</p> <p>This is the instance of FiefAuth we created in the previous section.</p> </li> <li> <p>Create an instance of the middleware</p> <p>Using the <code>fiefAuth.middleware</code> method, we create an instance of a Next.js Middleware that'll check the authentication on our routes.</p> <p>All it needs is an array of routes, consisting of the elements described below.</p> </li> <li> <p>Match the <code>/private</code> path</p> <p>By doing this, we tell the middleware to ensure a user is authenticated before accessing the <code>/private</code> page.</p> <p>If they're not, they will be automatically redirected to the Fief login page.</p> </li> <li> <p>Match all the routes starting with <code>/castles</code></p> <p>The <code>matcher</code> property follows the same syntax as the one supported by Next.js.</p> <p>It means that you can match a single path, a group of paths or a specific pattern.</p> <p>Here, we match all the routes starting with <code>/castles</code>. We'll be sure that the user is authenticated before accessing those routes.</p> </li> <li> <p>Require a permission to access <code>/castles</code> routes</p> <p>You can add <code>AuthenticateRequestParameters</code> to a path matcher.</p> <p>Here, we require the user to have <code>castles:read</code> permission to access those routes.</p> <p>If they don't have the required permission, the middleware will redirect them to the <code>/forbidden</code> page.</p> </li> <li> <p>Catch all the other routes</p> <p>To be able to get the user information even for routes that don't require authentication (think, for example, a home page where you render a header with a user menu), we need a last matcher that catches all the route.</p> <p>It ensures the middleware does its job and set the necessary headers for the pages and layouts. Notice how we set the <code>optional: true</code> option: it means we won't redirect the user to the login page if they're not authenticated.</p> </li> <li> <p>Define the Middleware function</p> <p>This is the standard way to define a Next.js Middleware.</p> </li> <li> <p>Call the <code>authMiddleware</code> function</p> <p>You can now call the <code>authMiddleware</code> function with the <code>request</code> object.</p> <p>This function returns a <code>NextResponse</code>, so you can very well add your own middleware logic if needed to further customize it.</p> </li> </ol> <p>Don't mix it with default <code>config</code> matcher</p> <p>The Next.js Middleware documentation shows you how to filter the execution of your Middleware using path matchers.</p> <pre><code>export const config = {\n    matcher: ['/about/:path*', '/dashboard/:path*'],\n}\n</code></pre> <p>When using Fief middleware, it's better to avoid it to make sure the authentication logic is called on the routes you defined.</p> <p>Indeed, let's imagine you have this configuration:</p> <pre><code>const authMiddleware = fiefAuth.middleware([\n    {\n        matcher: '/private',\n        parameters: {},\n    },\n]);\n// \u274c Don't do this\nexport const config = {\n    matcher: ['/another-route'],\n}\n</code></pre> <p>The authentication middleware will never be called in this configuration, because Next.js will only run the Middleware for <code>/another-route</code>, not <code>/private</code>.</p>"},{"location":"integrate/javascript/ssr/nextjs-app/#4-create-a-forbidden-page","title":"4. Create a <code>forbidden</code> page","text":"<p>When the user tries to access a page they are not authorized to see, e.g. if they lack a scope or a permission; the Middleware will automatically render the <code>pages/forbidden.tsx</code> page.</p> <p>You should implement it to show a useful error message to the user. It can be as simple as the following:</p> /app/forbidden/page.tsx<pre><code>export default async function Page() {\n  return (\n    &lt;h2&gt;Sorry, you are not authorized to access this page.&lt;/h2&gt;\n  )\n}\n</code></pre>"},{"location":"integrate/javascript/ssr/nextjs-app/#5-build-a-root-layout","title":"5. Build a root layout","text":"<p>The root layout is useful to render common components in all parts of your application. Typically, you may want to render a header showing the authenticated user or a login button.</p> <p>It can look like this:</p> /app/layout.tsx<pre><code>import type { Metadata } from 'next'\nimport { Inter } from 'next/font/google'\nimport './globals.css'\nimport { fiefAuth } from '@/fief'  // (1)!\nimport Header from '@/components/Header/Header'\n\nconst inter = Inter({ subsets: ['latin'] })\n\nexport const metadata: Metadata = {\n  title: 'Create Next App',\n  description: 'Generated by create next app',\n}\n\nexport default async function RootLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  const userinfo = await fiefAuth.getUserInfo() // (2)!\n  return (\n      &lt;html lang=\"en\"&gt;\n        &lt;body className={inter.className}&gt;\n          &lt;Header userinfo={userinfo} /&gt;  {/* (3)! */}\n          {children}\n        &lt;/body&gt;\n      &lt;/html&gt;\n  )\n}\n</code></pre> <ol> <li> <p>Import the <code>fiefAuth</code> instance from <code>fief</code> module</p> <p>This is the instance of FiefAuth we created at the beginning.</p> </li> <li> <p>Get user information</p> <p>Use the <code>getUserInfo</code> method to retrieve information about the authenticated user, or <code>null</code> if not authenticated.</p> </li> <li> <p>A simple demo <code>Header</code> component</p> <p>This is a simple demo component. Notice how we pass down user information as props.</p> </li> </ol>"},{"location":"integrate/javascript/ssr/nextjs-app/#good-to-go","title":"Good to go!","text":"<p>Our project is now ready! You can run it with:</p> <pre><code>npm run dev\n</code></pre> <p>If you go to http://localhost:3000, you'll see the index public page.</p> <p></p> <p>If you click on the Private page link in the header, you'll be automatically redirected on Fief authentication pages. After a successful login, you'll be taken back to the <code>/private</code> page.</p> <p></p> <p>As you can see, we can show the email address of the current user. This is done quite simply using again <code>getUserInfo</code>.</p> /app/private/page.tsx<pre><code>import { fiefAuth } from '@/fief'\n\nexport default async function Page() {\n  const userInfo = await fiefAuth.getUserInfo()\n\n  return (\n    &lt;h2&gt;You are authenticated. Your user email is {userInfo?.email}&lt;/h2&gt;\n  )\n}\n</code></pre> <p>Now, let's try to go to the Castles / Index page. If you've not added the correct permission to the user, you'll probably see the Forbidden page:</p> <p></p> <p>If you assign the correct permission to the user and authenticate again, you'll see the actual page.</p> <p></p> <p>As you can see, we are able to show the list of permissions granted to the user. It can be useful to hide or show parts of the UI depending on those permissions.</p> <p>You can easily access them using the <code>getAccessTokenInfo</code> method.</p> /app/castles/page.tsx<pre><code>import { fiefAuth } from '@/fief'\n\nexport default async function Page() {\n  const accessTokenInfo = await fiefAuth.getAccessTokenInfo()\n\n  return (\n    &lt;&gt;\n      &lt;h2&gt;You have the following permissions:&lt;/h2&gt;\n      &lt;ul&gt;\n        {accessTokenInfo?.permissions.map((permission) =&gt; &lt;li key={permission}&gt;{permission}&lt;/li&gt;)}\n      &lt;/ul&gt;\n    &lt;/&gt;\n  )\n}\n</code></pre> <p>If you click on Logout, your session will be cleared and you will be redirected to the index page.</p>"},{"location":"integrate/javascript/ssr/nextjs-app/#summary","title":"Summary","text":"<p>Your Next.js project is now ready and can easily control the authentication and permissions of your users! Here are the most important things to remember while developing your app:</p> <ol> <li>If you want to protect a page, add it to the <code>authMiddleware</code> paths in <code>middleware.ts</code>.</li> <li>If you want to access user information or permissions, use <code>getUserInfo</code> and <code>getAccessTokenInfo</code> methods.</li> </ol> <p>If you want to go further and customize more aspects, like the path to login or logout routes, be sure to check the library reference.</p>"},{"location":"integrate/javascript/ssr/nextjs-pages/","title":"Next.js (Pages Router)","text":"<p>Next.js is a highly popular JavaScript framework for Server-Side Rendering. It tries to combine the reactivity of React and the performance of backend technologies. As such, it has many subtelties and comes with very specific challenges, especially regarding user authentication.</p> <p>To help you with this, the Fief JavaScript client provides tools dedicated to Next.js. Let's see how to use them!</p> <p>Starting a new Next.js app?</p> <p>We recommend you to look at the more modern App Router approach.</p>"},{"location":"integrate/javascript/ssr/nextjs-pages/#install-the-client","title":"Install the client","text":"<pre><code>npm install @fief/fief\n</code></pre>"},{"location":"integrate/javascript/ssr/nextjs-pages/#the-big-picture","title":"The big picture","text":"<p>As we said, Next.js is a hybrid framework combining backend technologies and frontend technologies. It means that managing authentication will have to happen at several levels.</p> <pre><code>graph LR\n    subgraph Next.js\n        M[Middleware]\n        A[API]\n        R[React]\n    end\n    F[Fief]\n    RQ((Request))\n    RQ --&gt; M\n    M -- not authenticated --&gt; F\n    F -- callback --&gt; M\n    M -- authenticated --&gt; R\n    R -- useFiefUserinfo --&gt; A</code></pre>"},{"location":"integrate/javascript/ssr/nextjs-pages/#middleware-level","title":"Middleware level","text":"<p>In most recent versions, Next.js introduced Middleware. It's a useful mechanism allowing us to define logic before every request. Next.js team designed it to be highly performant: it's executed by their Edge Runtime technology, a special runtime different from Node.js.</p> <p>In Fief implementation, we'll use the Middleware to check if the user is authenticated and if they have the right scope and permissions.</p> <p>Besides, it'll also automatically handle special routes dedicated to authentication:</p> <ul> <li><code>/login</code> will redirect to Fief authentication page.</li> <li><code>/auth-callback</code> will complete the OAuth2 callback and set the session cookie;</li> <li><code>/logout</code> will clear the session cookie and redirect to Fief logout.</li> </ul>"},{"location":"integrate/javascript/ssr/nextjs-pages/#api-level","title":"API level","text":"<p>Next.js allows us to define API routes. They can be used to perform backend logic and are executed by a standard Node.js runtime.</p> <p>In Fief implemenetation, we'll define an API route allowing the React application to retrieve the current user information.</p>"},{"location":"integrate/javascript/ssr/nextjs-pages/#react-level","title":"React level","text":"<p>Finally, the React level is the interface shown to the user.</p> <p>In Fief implementation, we provide hooks allowing you to retrieve the current user information and authentication state.</p>"},{"location":"integrate/javascript/ssr/nextjs-pages/#configure-your-project","title":"Configure your project","text":"<p>This is for you if...</p> <ul> <li> You use Next.js with Pages Router.</li> </ul> <p>Prerequisites</p> <ul> <li> Bootstrap a Next.js project as described in Automatic Setup section of the Next.js documentation.</li> <li> Allow the following Redirect URI on your Fief Client: <code>http://localhost:3000/auth-callback</code></li> </ul>"},{"location":"integrate/javascript/ssr/nextjs-pages/#1-create-a-fief-module","title":"1. Create a <code>fief</code> module","text":"<p>Let's create a <code>fief.ts</code> module at the root of the project. It'll contain the basic instantiation of Fief helpers.</p> fief.ts<pre><code>import { Fief, FiefUserInfo } from '@fief/fief';\nimport { FiefAuth, IUserInfoCache } from '@fief/fief/nextjs';\n\nexport const SESSION_COOKIE_NAME = \"user_session\";  // (1)!\n\nexport const fiefClient = new Fief({  // (2)!\n  baseURL: 'http://localhost:8000',\n  clientId: 'YOUR_CLIENT_ID',\n  clientSecret: 'YOUR_CLIENT_SECRET',\n  requestInit: { next: { revalidate: 3600 } },\n});\n\nclass MemoryUserInfoCache implements IUserInfoCache {  // (3)!\n  private storage: Record&lt;string, any&gt;;\n\n  constructor() {\n    this.storage = {};\n  }\n\n  async get(id: string): Promise&lt;FiefUserInfo | null&gt; {\n    const userinfo = this.storage[id];\n    if (userinfo) {\n      return userinfo;\n    }\n    return null;\n  }\n\n  async set(id: string, userinfo: FiefUserInfo): Promise&lt;void&gt; {\n    this.storage[id] = userinfo;\n  }\n\n  async remove(id: string): Promise&lt;void&gt; {\n    this.storage[id] = undefined;\n  }\n\n  async clear(): Promise&lt;void&gt; {\n    this.storage = {};\n  }\n}\n\nexport const fiefAuth = new FiefAuth({  // (4)!\n  client: fiefClient,  // (5)!\n  sessionCookieName: SESSION_COOKIE_NAME,  // (6)!\n  redirectURI: 'http://localhost:3000/auth-callback',  // (7)!\n  logoutRedirectURI: 'http://localhost:3000',  // (8)!\n  userInfoCache: new MemoryUserInfoCache(),  // (9)!\n});\n</code></pre> <ol> <li> <p>Define a session cookie name constant</p> <p>We'll use a cookie to maintain the user session.</p> <p>For convenience, we set its name in a constant.</p> </li> <li> <p>Fief client instantiation</p> <p>As we showed in the standard JavaScript section, we instantiate here a Fief client here with the base tenant URL and client credentials.</p> </li> <li> <p>Implement a user information cache</p> <p>To make sure we don't call the Fief API every time we want the user data, we'll cache it in our application. It'll be way more performant!</p> <p>To do this, we impement a class following the <code>IUserInfoCache</code> interface.</p> <p>In this example, we use very simple approach that will just store the data in memory. If your server is rebooted, the cache will be lost.</p> <p>It can work quite well when starting, but you'll probably need more robust approaches in the long run, like writing to a Redis store. The good thing is that you'll only need to change this class when the time comes!</p> </li> <li> <p>Fief helper for Next.js</p> <p>This is the helper doing the tedious work for you with Next.js.</p> <p>We'll review here the required parameters. You can have a complete list of parameters in the reference documentation.</p> </li> <li> <p>The Fief client</p> <p>The first mandatory parameter is the Fief client we just created above.</p> </li> <li> <p>The session cookie name</p> <p>We pass the constant we defined above.</p> </li> <li> <p>Absolute redirect URI</p> <p>After the user has succesfully authenticated on Fief, our user will need to be redirected to our application so we can get the access token and set our session.</p> <p>This constant is an absolute URL to the <code>/auth-callback</code> route the Middleware will handle.</p> </li> <li> <p>Absolute redirect URI after logout</p> <p>When logging out, the user is redirected to Fief so the session stored on Fief's side can also be cleared.</p> <p>After that, Fief will redirect the user to your application. This parameter allows you to set the page where they should be redirected.</p> <p>Typically, this can be the home page of your application.</p> </li> <li> <p>We use our user information cache</p> <p>We tell about our user information cache, so the helper can use it to save and retrieve the data.</p> </li> </ol>"},{"location":"integrate/javascript/ssr/nextjs-pages/#2-add-the-middleware","title":"2. Add the Middleware","text":"<p>If not already, create a <code>middleware.ts</code> module at the root of the project.</p> middleware.ts<pre><code>import type { NextRequest } from 'next/server';\n\nimport { fiefAuth } from './fief';  // (1)!\n\nconst authMiddleware = fiefAuth.middleware([  // (2)!\n  {\n    matcher: '/private',  // (3)!\n    parameters: {},\n  },\n  {\n    matcher: '/castles/:path*',  // (4)!\n    parameters: {\n      permissions: ['castles:read'],  // (5)!\n    },\n  },\n]);\n\nexport async function middleware(request: NextRequest) {  // (6)!\n  return authMiddleware(request);  // (7)!\n};\n</code></pre> <ol> <li> <p>Import the <code>fiefAuth</code> instance from <code>fief</code> module</p> <p>This is the instance of FiefAuth we created in the previous section.</p> </li> <li> <p>Create an instance of the middleware</p> <p>Using the <code>fiefAuth.middleware</code> method, we create an instance of a Next.js Middleware that'll check the authentication on our routes.</p> <p>All it needs is an array of routes, consisting of the elements described below.</p> </li> <li> <p>Match the <code>/private</code> path</p> <p>By doing this, we tell the middleware to ensure a user is authenticated before accessing the <code>/private</code> page.</p> <p>If they're not, they will be automatically redirected to the Fief login page.</p> </li> <li> <p>Match all the routes starting with <code>/castles</code></p> <p>The <code>matcher</code> property follows the same syntax as the one supported by Next.js.</p> <p>It means that you can match a single path, a group of paths or a specific pattern.</p> <p>Here, we match all the routes starting with <code>/castles</code>. We'll be sure that the user is authenticated before accessing those routes.</p> </li> <li> <p>Require a permission to access <code>/castles</code> routes</p> <p>You can add <code>AuthenticateRequestParameters</code> to a path matcher.</p> <p>Here, we require the user to have <code>castles:read</code> permission to access those routes.</p> <p>If they don't have the required permission, the middleware will redirect them to the <code>/forbidden</code> page.</p> </li> <li> <p>Define the Middleware function</p> <p>This is the standard way to define a Next.js Middleware.</p> </li> <li> <p>Call the <code>authMiddleware</code> function</p> <p>You can now call the <code>authMiddleware</code> function with the <code>request</code> object.</p> <p>This function returns a <code>NextResponse</code>, so you can very well add your own middleware logic if needed to further customize it.</p> </li> </ol> <p>Don't mix it with default <code>config</code> matcher</p> <p>The Next.js Middleware documentation shows you how to filter the execution of your Middleware using path matchers.</p> <pre><code>export const config = {\n    matcher: ['/about/:path*', '/dashboard/:path*'],\n}\n</code></pre> <p>When using Fief middleware, it's better to avoid it to make sure the authentication logic is called on the routes you defined.</p> <p>Indeed, let's imagine you have this configuration:</p> <pre><code>const authMiddleware = fiefAuth.middleware([\n    {\n        matcher: '/private',\n        parameters: {},\n    },\n]);\n// \u274c Don't do this\nexport const config = {\n    matcher: ['/another-route'],\n}\n</code></pre> <p>The authentication middleware will never be called in this configuration, because Next.js will only run the Middleware for <code>/another-route</code>, not <code>/private</code>.</p>"},{"location":"integrate/javascript/ssr/nextjs-pages/#3-add-the-current-user-api","title":"3. Add the <code>current-user</code> API","text":"<p>In the <code>/pages/api</code> directory, create a <code>current-user.ts</code> module.</p> /pages/api/current-user.ts<pre><code>import { fiefAuth } from '../../fief';  // (1)!\n\nexport default fiefAuth.currentUser();  // (2)!\n</code></pre> <ol> <li> <p>Import the <code>fiefAuth</code> instance from <code>fief</code> module</p> <p>This is the instance of FiefAuth we created in the first section.</p> </li> <li> <p>Instantiate and export the <code>currentUser</code> API route</p> <p>Thanks to the <code>fiefAuth.currentUser</code> method, you can generate an API route that'll return the user information of the authenticated user.</p> <p>Nothing more to do!</p> </li> </ol>"},{"location":"integrate/javascript/ssr/nextjs-pages/#4-create-a-forbidden-page","title":"4. Create a <code>forbidden</code> page","text":"<p>When the user tries to access a page they are not authorized to see, e.g. if they lack a scope or a permission; the Middleware will automatically render the <code>pages/forbidden.tsx</code> page.</p> <p>You should implement it to show a useful error message to the user. It can be as simple as the following:</p> /pages/forbidden.tsx<pre><code>import type { NextPage } from 'next';\n\nconst Forbidden: NextPage = () =&gt; {\n  return (\n    &lt;h2&gt;Sorry, you are not authorized to access this page.&lt;/h2&gt;\n  )\n};\n\nexport default Forbidden;\n</code></pre>"},{"location":"integrate/javascript/ssr/nextjs-pages/#5-prepare-your-react-application","title":"5. Prepare your React application","text":"<p>On the React side, we'll need to declare a context so the frontend application can store the authentication state and user information in its state. It'll also let us use a set of useful hooks.</p> <p>Your <code>/pages/_app.tsx</code> file should look like this:</p> /pages/_app.tsx<pre><code>import { FiefAuthProvider } from '@fief/fief/nextjs/react';\nimport type { AppContext, AppProps, AppInitialProps } from 'next/app';\nimport App from 'next/app';\n\nimport Header from '../components/Header/Header';\n\nimport '../styles/globals.css';\n\nfunction MyApp({ Component, pageProps }: AppProps) {\n  return (\n    &lt;FiefAuthProvider state={{ accessTokenInfo: null, userinfo: null }} currentUserPath=\"/api/current-user\"&gt; {/* (1)! */}\n      &lt;Header /&gt; {/* (2)! */}\n      &lt;Component {...pageProps} /&gt;\n    &lt;/FiefAuthProvider&gt;\n  );\n};\n\nMyApp.getInitialProps = async (\n  context: AppContext\n): Promise&lt;AppInitialProps&gt; =&gt; {\n  const ctx = await App.getInitialProps(context)\n\n  return { ...ctx }\n}\n\nexport default MyApp;\n</code></pre> <ol> <li> <p>Wrap <code>Component</code> with <code>FiefAuthProvider</code></p> <p><code>FiefAuthProvider</code> will provide the necessary React context so we can use the hooks in our application.</p> <p>The only property required is <code>currentUserPath</code>, which should be the path of the current user API we defined in the previous section.</p> </li> <li> <p>A simple demo <code>Header</code> component</p> <p>This is a simple demo component to show you how to use hooks. We'll detail it in the next sections.</p> </li> </ol> <p>In React context, the import path is <code>@fief/fief/nextjs/react</code></p> <p>For technical reasons, components and hooks need to be imported from <code>@fief/fief/nextjs/react</code>, not <code>@fief/fief/nextjs</code>.</p>"},{"location":"integrate/javascript/ssr/nextjs-pages/#good-to-go","title":"Good to go!","text":"<p>Our project is now ready! You can run it with:</p> <pre><code>npm run dev\n</code></pre> <p>If you go to http://localhost:3000, you'll see the index public page.</p> <p></p> <p>If you click on the Private page link in the header, you'll be automatically redirected on Fief authentication pages. After a successful login, you'll be taken back to the <code>/private</code> page.</p> <p></p> <p>As you can see, we can show the email address of the current user. This is done quite simply using the provided React hooks:</p> /pages/private.tsx<pre><code>import { useFiefUserinfo } from '@fief/fief/nextjs/react';\nimport type { NextPage } from 'next';\n\nconst Private: NextPage = () =&gt; {\n  const user = useFiefUserinfo(); // (1)!\n\n  return (\n    &lt;h2&gt;You are authenticated. Your user email is {user?.email}&lt;/h2&gt;\n  )\n};\n\nexport default Private;\n</code></pre> <ol> <li> <p><code>useFiefUserinfo</code> gives you access to the current user information</p> <p>The hook <code>useFiefUserinfo</code> returns you a <code>FiefUserInfo</code> object you can use to work with the user data.</p> </li> </ol> <p>Now, let's try to go to the Castles / Index page. If you've not added the correct permission to the user, you'll probably see the Forbidden page:</p> <p></p> <p>If you assign the correct permission to the user and authenticate again, you'll see the actual page.</p> <p></p> <p>As you can see, we are able to show the list of permissions granted to the user. It can be useful to hide or show parts of the UI depending on those permissions.</p> <p>You can easily access them using the <code>useFiefAccessTokenInfo</code> hook.</p> /pages/castles/index.tsx<pre><code>import { useFiefAccessTokenInfo } from '@fief/fief/nextjs/react';\nimport type { NextPage } from 'next';\n\nconst CastlesIndex: NextPage = () =&gt; {\n  const accessTokenInfo = useFiefAccessTokenInfo();\n\n  return (\n    &lt;&gt;\n      &lt;h2&gt;You have the following permissions:&lt;/h2&gt;\n      &lt;ul&gt;\n        {accessTokenInfo?.permissions.map((permission) =&gt; &lt;li key={permission}&gt;{permission}&lt;/li&gt;)}\n      &lt;/ul&gt;\n    &lt;/&gt;\n  );\n};\n\nexport default CastlesIndex;\n</code></pre> <p>If you click on Logout, your session will be cleared and you will be redirected to the index page.</p> <p>Generating links to login, logout and other pages is no different from a standard Next.js links. Just be sure you use the right path!</p> /components/Header/Header.tsx<pre><code>import { useFiefIsAuthenticated, useFiefUserinfo } from '@fief/fief/nextjs/react';\nimport Link from 'next/link';\nimport React from 'react';\n\nconst Header: React.FunctionComponent = () =&gt; {\n  const isAuthenticated = useFiefIsAuthenticated(); /* (1)! */\n  const userinfo = useFiefUserinfo();\n\n  return (\n    &lt;ul&gt;\n      &lt;li&gt;&lt;Link href=\"/\"&gt;Public page&lt;/Link&gt;&lt;/li&gt;\n      &lt;li&gt;&lt;Link href=\"/private\"&gt;Private page&lt;/Link&gt;&lt;/li&gt;\n      &lt;li&gt;\n        Castles\n        &lt;ul&gt;\n          &lt;li&gt;&lt;Link href=\"/castles\"&gt;Index&lt;/Link&gt;&lt;/li&gt;\n          &lt;li&gt;&lt;Link href=\"/castles/create\"&gt;Create&lt;/Link&gt;&lt;/li&gt;\n        &lt;/ul&gt;\n      &lt;/li&gt;\n      &lt;li&gt;\n        {/* (2)! */}\n        {!isAuthenticated &amp;&amp; &lt;Link href=\"/login\"&gt;Login&lt;/Link&gt;}\n        {isAuthenticated &amp;&amp; userinfo &amp;&amp; (\n          &lt;div&gt;\n            &lt;span&gt;{userinfo.email} - &lt;/span&gt;\n            {/* (3)! */}\n            &lt;Link href=\"/logout\"&gt;Logout&lt;/Link&gt;\n          &lt;/div&gt;\n        )}\n      &lt;/li&gt;\n    &lt;/ul&gt;\n  );\n};\n\nexport default Header;\n</code></pre> <ol> <li> <p>Use <code>useFiefIsAuthenticated</code> hook to know if a user is authenticated</p> <p><code>useFiefIsAuthenticated</code> is very useful to quickly check if there is a valid session and adapt the UI.</p> </li> <li> <p>Show a Login link if not authenticated</p> <p>Simply add a Link component pointing to the <code>/login</code> path. This path is automatically handled by the Middleware.</p> </li> <li> <p>Show a Logout link if authenticated</p> <p>Simply add a Link component pointing to the <code>/logout</code> path. This path is automatically handled by the Middleware.</p> </li> </ol>"},{"location":"integrate/javascript/ssr/nextjs-pages/#summary","title":"Summary","text":"<p>Your Next.js project is now ready and can easily control the authentication and permissions of your users! Here are the most important things to remember while developing your app:</p> <ol> <li>If you want to protect a page, add it to the <code>authMiddleware</code> paths in <code>middleware.ts</code>.</li> <li>If you want to access user information or permissions, use <code>useFiefUserinfo</code> and <code>useFiefAccessTokenInfo</code> hooks.</li> </ol> <p>If you want to go further and customize more aspects, like the path to login or logout routes, be sure to check the library reference.</p>"},{"location":"integrate/javascript/ssr/nextjs-pages/#get-access-token","title":"Get access token","text":"<p>In somes contexts, you might need to call a separate API backend that will expect a valid access token to authenticate the request. For example, this is what we show in the FastAPI example.</p> <p>In this case, your Next.js took care of authenticating the user and has a valid access token in session. Now, you only need to get this access token and set it as <code>Authorization</code> header when making requests to your API backend.</p> <p>With Next.js, you can do this in two contexts:</p>"},{"location":"integrate/javascript/ssr/nextjs-pages/#1-from-getserversideprops","title":"1. From <code>getServerSideProps</code>","text":"<p><code>getServerSideProps</code> is a Next.js feature to fetch data server-side, in a pure SSR approach. It's a good candidate to fetch the data you want to show to the users from your API, like a list of items.</p> <p>Fief's integration allows you to retrieve the user ID and the access token information server-side using the <code>getUserId</code> and <code>getAccessTokenInfo</code> methods.</p> <pre><code>import { fiefAuth } from '../fief';\n\nexport const getServerSideProps: GetServerSideProps = async (context) =&gt; {\n  const userId = await fiefAuth.getUserId(context.req)\n  const accessTokenInfo = await fiefAuth.getAccessTokenInfo(context.req)\n  const res = await fetch('https://api.bretagne.duchy', {\n    headers: {\n      Authorization: `Bearer ${accessTokenInfo?.access_token}`,\n    },\n  });\n  const data = await res.json()\n  // Pass data to the page via props\n  return { props: { data } }\n}\n</code></pre>"},{"location":"integrate/javascript/ssr/nextjs-pages/#2-from-react","title":"2. From React","text":"<p>Of course, you might need to call your API from the frontend side as well, typically when the user needs to create or update new data.</p> <p>For this, you can get the access token with the <code>useFiefAccessTokenInfo</code> hook.</p> <pre><code>const accessTokenInfo = useFiefAccessTokenInfo();\n\nconst submitData = useCallback(async (data) =&gt; {\n  await fetch('https://api.bretagne.duchy', {\n    method: 'POST',\n    headers: {\n      Authorization: `Bearer ${accessTokenInfo?.access_token}`,\n    },\n    body: JSON.stringify(data),\n  });\n}, [accessTokenInfo]);\n</code></pre>"},{"location":"integrate/python/","title":"Python","text":"<p>We provide an official client for Python. You can install it with <code>pip</code>:</p> <pre><code>pip install fief-client\n</code></pre>"},{"location":"integrate/python/#create-a-fief-client","title":"Create a <code>Fief</code> client","text":"<p>Prerequisites</p> <ul> <li> Allow the following Redirect URI on your Fief Client: <code>http://localhost:8000/callback</code></li> </ul> <p>The Fief client provides all the necessary methods to manage OAuth2 authentication, validate access tokens and refresh them.</p> client.py<pre><code>from fief_client import Fief\n\nfief = Fief(\n    \"https://fief.mydomain.com\",  # (1)!\n    \"YOUR_CLIENT_ID\",  # (2)!\n    \"YOUR_CLIENT_SECRET\",  # (3)!\n)\n\nredirect_url = \"http://localhost:8000/callback\"\n\nauth_url = fief.auth_url(redirect_url, scope=[\"openid\"])\nprint(f\"Open this URL in your browser: {auth_url}\")\n\ncode = input(\"Paste the callback code: \")\n\ntokens, userinfo = fief.auth_callback(code, redirect_url)\nprint(f\"Tokens: {tokens}\")\nprint(f\"Userinfo: {userinfo}\")\n</code></pre> <ol> <li> <p>Base URL of your Fief tenant</p> <p>You can find it in the admin dashboard, in the Tenants list. More info</p> <p></p> </li> <li> <p>ID of your Fief client</p> <p>You can find it in the admin dashboard, in the Clients list. More info</p> <p></p> <p>Info</p> <p>A first client is always created for you when you create your instance. When getting started, you should use this one.</p> </li> <li> <p>Secret of your Fief client</p> <p>You can find it in the admin dashboard, in the Clients list. More info</p> <p></p> <p>Info</p> <p>A first client is always created for you when you create your instance. When getting started, you should use this one.</p> </li> </ol> <p>Avoid to hardcode your secrets in your code</p> <p>It's usually not recommended to hardcode secrets like Client ID and Secret in your code like this. If your code gets published on the web, for example on GitHub, the security of your instance would be compromised.</p> <p>Besides, it'll be harder if you need to deploy on several environments, like a staging or testing one, in addition to your production environment.</p> <p>A standard and widely-used approach is to use environment variables.</p> <p>Async support</p> <p>For <code>asyncio</code> enthusiasts, we also provide a <code>FiefAsync</code> class with the same methods.</p>"},{"location":"integrate/python/#perform-an-oauth2-flow-manually","title":"Perform an OAuth2 flow manually","text":"<p>The simple script below shows you how to authenticate with OAuth2 \"manually\". The goal is to show you how to use the client. You'll then be able to integrate it in your own project with your framework and stack.</p> <p>The first step is to generate an authorization URL, which is an URL on the Fief server that'll ask you for your email address and password.</p> client.py<pre><code>from fief_client import Fief\n\nfief = Fief(\n    \"https://fief.mydomain.com\",  # (1)!\n    \"YOUR_CLIENT_ID\",  # (2)!\n    \"YOUR_CLIENT_SECRET\",  # (3)!\n)\n\nredirect_url = \"http://localhost:8000/callback\"\n\nauth_url = fief.auth_url(redirect_url, scope=[\"openid\"])\nprint(f\"Open this URL in your browser: {auth_url}\")\n\ncode = input(\"Paste the callback code: \")\n\ntokens, userinfo = fief.auth_callback(code, redirect_url)\nprint(f\"Tokens: {tokens}\")\nprint(f\"Userinfo: {userinfo}\")\n</code></pre> <p>Then, we make the script prompt for the authorization code.</p> client.py<pre><code>from fief_client import Fief\n\nfief = Fief(\n    \"https://fief.mydomain.com\",  # (1)!\n    \"YOUR_CLIENT_ID\",  # (2)!\n    \"YOUR_CLIENT_SECRET\",  # (3)!\n)\n\nredirect_url = \"http://localhost:8000/callback\"\n\nauth_url = fief.auth_url(redirect_url, scope=[\"openid\"])\nprint(f\"Open this URL in your browser: {auth_url}\")\n\ncode = input(\"Paste the callback code: \")\n\ntokens, userinfo = fief.auth_callback(code, redirect_url)\nprint(f\"Tokens: {tokens}\")\nprint(f\"Userinfo: {userinfo}\")\n</code></pre> <p>This temporary code is generated by Fief upon successful login and can be used to obtain valid tokens. Fief returns both an access token and an ID token, which contains information about the user.</p> client.py<pre><code>from fief_client import Fief\n\nfief = Fief(\n    \"https://fief.mydomain.com\",  # (1)!\n    \"YOUR_CLIENT_ID\",  # (2)!\n    \"YOUR_CLIENT_SECRET\",  # (3)!\n)\n\nredirect_url = \"http://localhost:8000/callback\"\n\nauth_url = fief.auth_url(redirect_url, scope=[\"openid\"])\nprint(f\"Open this URL in your browser: {auth_url}\")\n\ncode = input(\"Paste the callback code: \")\n\ntokens, userinfo = fief.auth_callback(code, redirect_url)\nprint(f\"Tokens: {tokens}\")\nprint(f\"Userinfo: {userinfo}\")\n</code></pre>"},{"location":"integrate/python/#test-it","title":"Test it","text":"<p>You can run this script from a command line:</p> <pre><code>python client.py\n</code></pre> <p>You'll get the following output:</p> <pre><code>Open this URL in your browser: https://fief.mydomain.com/authorize?response_type=code&amp;client_id=YOUR_CLIENT_ID&amp;redirect_uri=http%3A%2F%2Flocalhost%3A8000%2Fcallback&amp;scope=openid\nPaste the callback code:\n</code></pre> <p>You can copy and paste this URL manually in your browser. You'll be redirected to a Fief login page.</p> <p></p> <p>Upon successful login, Fief will redirect to the redirect URL you defined above, including a query parameter named <code>code</code>. It'll look like this:</p> <pre><code>http://localhost:8000/redirect?code=wPEDiSRkoYOtA-4QCJHpsLne0P2PXVYAlW6hcH5OVBg\n</code></pre> <p>Your browser will probably show an error at this point</p> <p>In this simple implementation, we don't have a web server running on our local machine, so the browser won't be able to open the redirect URL. It's not a problem: what we care about is retrieving the authorization code by hand.</p> <p>Copy the code value, get back to the command line where the script is running and paste it. You'll get the following output:</p> <pre><code>Paste the callback code: wPEDiSRkoYOtA-4QCJHpsLne0P2PXVYAlW6hcH5OVBg\nTokens: {'access_token': 'eyJhbGciOiJSUzI1NiJ9.eyJhdWQiOlsiRE9JaGpfNzJIYTlyWWg5dURnbmRTdTYyRVhKdUZmUTVsa2t4MS1rc1VJbyJdLCJhenAiOiJET0loal83MkhhOXJZaDl1RGduZFN1NjJFWEp1RmZRNWxra3gxLWtzVUlvIiwiZXhwIjoxNjQ4MDUwNDIzLCJpYXQiOjE2NDgwNDY4MjMsImlzcyI6Imh0dHBzOi8vZXhhbXBsZS5maWVmLmRldiIsInNjb3BlIjoib3BlbmlkIiwic3ViIjoiYTM4NDZjYzEtN2MwOC00Mzg5LThjOGUtYzBlNzlmNzA3NWZlIn0.R5JnZW9Vq6lWai-FZcqsihYxmtFRbIjZ7D0Ck9XAG0d2YnQQ7ms3bUwtXEAnLhos4C3paGDa0PzQRtXSAx4IH85ZdeVJoBk9GrOj1ZV7E6dtZZSZlvtY2msMeXFC9gNg-A86R9ZU_T0PoROof0u1eJHYVlmo_dv2fodyNqkDB8V6HK3vqf7jaqNQtk8Fg6eHKhwb-3bAtjb5cpWAAWhMSrHZzTWIYUvYsvwAas5ihgenv3UOkpcl_p7b7G9SDhGE5abPQQ7lvyfhYZE7CV1DzVRU6UL4N0D2l4uI3RJNOQoECvltfo2etYzp5viwAwvg9LUS3466Ra1i8beBKXsPFQ', 'id_token': 'eyJhbGciOiJSUzI1NiJ9.eyJhdWQiOlsiRE9JaGpfNzJIYTlyWWg5dURnbmRTdTYyRVhKdUZmUTVsa2t4MS1rc1VJbyJdLCJhenAiOiJET0loal83MkhhOXJZaDl1RGduZFN1NjJFWEp1RmZRNWxra3gxLWtzVUlvIiwiZW1haWwiOiJmcmFuY29pcyt0ZXN0QGZpZWYuZGV2IiwiZXhwIjoxNjQ4MDUwNDIzLCJpYXQiOjE2NDgwNDY4MjMsImlzcyI6Imh0dHBzOi8vZXhhbXBsZS5maWVmLmRldiIsInN1YiI6ImEzODQ2Y2MxLTdjMDgtNDM4OS04YzhlLWMwZTc5ZjcwNzVmZSIsInRlbmFudF9pZCI6IjcwNDEzNWI2LTRiZmQtNGM1NS04MDkwLWM2MzhhNmJhNTNhMiJ9.ULQy7TlgF5_oQwwgA6ydTahTYE31obr4F3olJy-mgyPw67XstoJLM1VwUNawzyz2Iu2QDmgcBrH3OMVfgCkBAFk2sp-QQIDr9arIF1QXNKG65El3zgPQ5-niTTsIuAkemyjNGcpdrcN2b9FaeodzauO5eOjno60h5dTBbcLnqv00V-Jv6sq8lB8_o5JXHKWUoZZA2VFEDox9MXfhDqrvyHcitsIRWIy7XhILKcZ-JG_AMcXnuDcyMnsoy91-gJznvMk7_ty9eNWs8Cm0ZhK3nMqEKML4tXIREmIN-vYUGDtbDWX3O45N98ovu9gJi9S3aVOh-gZQsnwauJmlW82ZQQ', 'token_type': 'bearer', 'expires_in': 3600}\nUserinfo: {'aud': ['YOUR_CLIENT_ID'], 'azp': 'YOUR_CLIENT_ID', 'email': 'anne@bretagne.duchy', 'exp': 1648050423, 'iat': 1648046823, 'iss': 'https://fief.mydomain.com', 'sub': 'a3846cc1-7c08-4389-8c8e-c0e79f7075fe', 'tenant_id': '704135b6-4bfd-4c55-8090-c638a6ba53a2'}\n</code></pre> <p>As you can see, we obtained a first dictionary <code>tokens</code> containing an access token, an ID token and other standard OAuth2 information.</p> <p>The second variable, <code>userinfo</code>, is a dictionary with the user data. It's actually the information contained in the ID token that the client decoded for you.</p>"},{"location":"integrate/python/#whats-next","title":"What's next?","text":"<p>You have the fundamental basics for performing an OAuth2 authentication with the Fief Python client.</p> <p>To help you further, we provide you helpers and examples for popular Python frameworks like Flask or FastAPI.</p> <p>Integrate with FastAPI Integrate with Flask</p>"},{"location":"integrate/python/cli/","title":"CLI","text":"<p>Command Line Tools are really useful for tech users to easily interact with your product and integrate it in scripts or workflows.</p> <p>The Fief Python client provides tools to help you integration Fief authentication in your CLI application. Let's see how to use them!</p>"},{"location":"integrate/python/cli/#install-the-client","title":"Install the client","text":"<p>Install the Fief client with the optional CLI dependencies:</p> <pre><code>pip install \"fief-client[cli]\"\n</code></pre>"},{"location":"integrate/python/cli/#example","title":"Example","text":"<p>This is for you if...</p> <ul> <li> You want your CLI to make authenticated requests to your backend.</li> </ul> <p>Prerequisites</p> <ul> <li> Make sure your Fief Client is Public.</li> <li> Check that the following Redirect URI is allowed on your Fief Client: <code>http://localhost:51562/callback</code></li> </ul> <p>For this example, we used Click, a widely used library to build CLI tools in Python.</p> app.py<pre><code>import click\nfrom fief_client import Fief\nfrom fief_client.integrations.cli import FiefAuth, FiefAuthNotAuthenticatedError\n\nfief = Fief(  # (1)!\n    \"https://fief.mydomain.com\",\n    \"YOUR_CLIENT_ID\",\n)\nfief_auth = FiefAuth(fief, \"./credentials.json\")  # (2)!\n\n\n@click.group()\ndef cli():\n    pass\n\n\n@cli.command()\ndef login():\n    fief_auth.authorize()  # (3)!\n\n\n@cli.command()\ndef hello():\n    try:\n        userinfo = fief_auth.current_user()  # (4)!\n        click.echo(f\"Hello {userinfo['email']} \ud83d\udc4b\")\n    except FiefAuthNotAuthenticatedError as e:  # (5)!\n        raise click.UsageError(\"You're not authenticated\") from e\n\n\n@cli.command()\n@click.argument(\"api_route\")\ndef call_api(api_route: str):\n    try:\n        access_token_info = fief_auth.access_token_info()  # (6)!\n        access_token = access_token_info[\"access_token\"]\n        click.echo(f\"Make API call to {api_route} with access token {access_token}...\")\n    except FiefAuthNotAuthenticatedError as e:\n        raise click.UsageError(\"You're not authenticated\") from e\n\n\nif __name__ == \"__main__\":\n    cli()\n</code></pre> <ol> <li> <p>Fief client instantiation</p> <p>As we showed in the standard Python section, we instantiate here a Fief client here with the base tenant URL and client ID.</p> <p>Notice here that we don't set the client secret. Since the CLI app will be installed on the user's machine, it can't be considered as safe. That's why you have to use a public client.</p> </li> <li> <p>Fief helper for CLI tools</p> <p>This is the helper doing the tedious work for you. It first needs an instance of the Fief client we created above and the path where the credentials will be saved on the user's machine.</p> <p>We put here directly in the current working directory, but a proper way to manage this is probably to use the operating sytem directories dedicated for this kind of data. Libraries like appdir can help you to determine a reasonable path depending on the user's operating system.</p> </li> <li> <p>Authenticate the user</p> <p>The method <code>authorize</code> on the helper performs all the operations needed to authenticate your CLI application: it'll open the authorization page in the browser, catch the redirection, get tokens and save them on disk.</p> <p>Under the hood, it'll temporarily open a web server to catch the redirection. By default, it'll be opened on <code>localhost:51562</code>. You can customize this but don't forget then to update your client's redirect URI.</p> </li> <li> <p>Get info about the authenticated user</p> <p>The method <code>current_user</code> returns you a <code>FiefUserInfo</code> dictionary containing the data of the user.</p> </li> <li> <p><code>FiefAuthNotAuthenticatedError</code> is raised if the CLI is not authenticated</p> <p>If there is no credentials saved on disk, <code>FiefAuthNotAuthenticatedError</code> is raised. In this case, you can explain the problem to the user and ask them to authenticate.</p> </li> <li> <p>Get the access token</p> <p>In general, you'll need an access token to make authenticated request to your server. The method <code>access_token_info</code> returns you a <code>FiefAccessTokenInfo</code> dictionary, containing the access token.</p> <p>By default, if the access token is expired, it'll automatically ask for a fresh one using the refresh token and update it on disk.</p> </li> </ol> <p>That's it! The tedious work is mostly done by the helper. If you run the following command, you'll be taken through the authentication process:</p> <p>A browser window will automatically open to the Fief authentication page. After signing in, you can go back to the CLI: you're now authenticated!</p>"},{"location":"integrate/python/fastapi/","title":"FastAPI","text":"<p>FastAPI is one of the fastest-growing Python web framework. It features impressive performance and top-notch developer experience. Actually, the Fief server itself is implemented with FastAPI!</p> <p>The Fief Python client provides tools to help you integrate Fief authentication in your FastAPI project. Let's see how to use them!</p>"},{"location":"integrate/python/fastapi/#install-the-client","title":"Install the client","text":"<p>Install the Fief client with the optional FastAPI dependencies:</p> <pre><code>pip install \"fief-client[fastapi]\"\n</code></pre>"},{"location":"integrate/python/fastapi/#api-example","title":"API example","text":"<p>This is for you if...</p> <ul> <li> Your FastAPI backend will work as a pure REST API.</li> <li> You have a separate frontend, like a JavaScript or mobile app, that'll take care of the OAuth2 flow.</li> </ul> <p>Prerequisites</p> <ul> <li> Check that the following Redirect URI is allowed on your Fief Client: <code>http://localhost:8000/docs/oauth2-redirect</code></li> </ul> <p>In this first example, we'll leverage the interactive documentation generated by FastAPI to perform the OAuth2 authentication. The goal here is just to show you how to protect your API route with a Fief access token.</p> app.py<pre><code>from fastapi import Depends, FastAPI\nfrom fastapi.security import OAuth2AuthorizationCodeBearer\nfrom fief_client import FiefAccessTokenInfo, FiefAsync\nfrom fief_client.integrations.fastapi import FiefAuth\n\nfief = FiefAsync(  # (1)!\n    \"https://fief.mydomain.com\",\n    \"YOUR_CLIENT_ID\",\n    \"YOUR_CLIENT_SECRET\",\n)\n\nscheme = OAuth2AuthorizationCodeBearer(  # (2)!\n    \"https://fief.mydomain.com/authorize\",  # (3)!\n    \"https://fief.mydomain.com/api/token\",  # (4)!\n    scopes={\"openid\": \"openid\", \"offline_access\": \"offline_access\"},\n    auto_error=False,  # (5)!\n)\n\nauth = FiefAuth(fief, scheme)  # (6)!\n\napp = FastAPI()\n\n\n@app.get(\"/user\")\nasync def get_user(\n    access_token_info: FiefAccessTokenInfo = Depends(auth.authenticated()),  # (7)!\n):\n    return access_token_info\n</code></pre> <ol> <li> <p>Fief client instantiation</p> <p>As we showed in the standard Python section, we instantiate here a Fief client here with the base tenant URL and client credentials.</p> <p>Notice here that we use the <code>FiefAsync</code> class. FastAPI being an ASGI framework, it's always nice to take advantage of <code>asyncio</code> capabilities.</p> </li> <li> <p>OpenAPI security scheme</p> <p>FastAPI uses those security schemes to generate an interactive documentation showing the right interface to authenticate with the API. We use here a standard OAuth2 interface.</p> </li> <li> <p>Don't forget to replace with your base URL here</p> <p>This is to tell the interactive documentation where to redirect you upon authorization.</p> </li> <li> <p>Don't forget to replace with your base URL here</p> <p>This is to tell the interactive documentation where to ask for a fresh token after successful login.</p> </li> <li> <p>We set the auto_error argument to <code>False</code></p> <p>It tells FastAPI user to bypass its built-in error response if the token is not present: Fief client provides its own logic to handle this.</p> </li> <li> <p>Fief helper for FastAPI</p> <p>This is the helper doing the tedious work for you with FastAPI. All it needs is an instance of the Fief client and the scheme.</p> </li> <li> <p><code>authenticated</code> dependency</p> <p>This is where the magic happens: in pure FastAPI style, <code>FiefAuth</code> gives you a <code>authenticated</code> dependency to check for the access token and optionally for required scopes.</p> <p>If everything goes well, you'll get a dictionary containing the ID of the user, the list of allowed scopes and the raw access token.</p> </li> </ol> <p>And that's about it!</p>"},{"location":"integrate/python/fastapi/#test-it","title":"Test it","text":"<p>You can run this example just like you would do for any FastAPI app:</p> <pre><code>uvicorn app:app\n</code></pre> <p>Open http://localhost:8000/docs to access the interactive documentation.</p> <p></p> <p>Let's try first the <code>/user</code> endpoint:</p> <p></p> <p>We get an 401 error! That's expected: we are not authenticated yet!</p> <p>Let's fix that: click on the Authorize button to start the authentication process. You'll need to provide your client ID and secret and select the scopes.</p> <p></p> <p>Click on the Authorize button: you are redirected to the Fief login page.</p> <p></p> <p>Upon successful login, you will be redirected back to the interactive documentation: a valid access token has been generated!</p> <p></p> <p>You can now try the <code>/user</code> endpoint to check the result:</p> <p></p> <p>Notice how the interactive documentation passed the access token in the <code>Authorization</code> header of the request!</p> <p>Besides, the response does contain the user ID, the list of allowed scopes and the access token itself.</p>"},{"location":"integrate/python/fastapi/#checking-for-scopes","title":"Checking for scopes","text":"<p>Building on the previous example, you can make your endpoint require the access token to be granted a list of scopes. Simply add this list of scopes as a keyword parameter of the <code>authenticated</code> dependency.</p> app.py<pre><code>from fastapi import Depends, FastAPI\nfrom fastapi.security import OAuth2AuthorizationCodeBearer\nfrom fief_client import FiefAccessTokenInfo, FiefAsync\nfrom fief_client.integrations.fastapi import FiefAuth\n\nfief = FiefAsync(\n    \"https://fief.mydomain.com\",\n    \"YOUR_CLIENT_ID\",\n    \"YOUR_CLIENT_SECRET\",\n)\n\nscheme = OAuth2AuthorizationCodeBearer(\n    \"https://fief.mydomain.com/authorize\",\n    \"https://fief.mydomain.com/api/token\",\n    scopes={\"openid\": \"openid\", \"offline_access\": \"offline_access\"},\n    auto_error=False,\n)\n\nauth = FiefAuth(fief, scheme)\n\napp = FastAPI()\n\n\n@app.get(\"/user\")\nasync def get_user(\n    access_token_info: FiefAccessTokenInfo = Depends(\n        auth.authenticated(scope=[\"openid\", \"required_scope\"])\n    ),\n):\n    return access_token_info\n</code></pre> <p>If one of the required scope is missing on the access token, a <code>403 Forbidden</code> error will automatically be returned.</p>"},{"location":"integrate/python/fastapi/#checking-for-permissions","title":"Checking for permissions","text":"<p>Similary, you can make your endpoint require the user to be granted a list of permissions. Simply add this list of permissions as a keyword parameter of the <code>authenticated</code> dependency.</p> app.py<pre><code>from fastapi import Depends, FastAPI\nfrom fastapi.security import OAuth2AuthorizationCodeBearer\nfrom fief_client import FiefAccessTokenInfo, FiefAsync\nfrom fief_client.integrations.fastapi import FiefAuth\n\nfief = FiefAsync(\n    \"https://fief.mydomain.com\",\n    \"YOUR_CLIENT_ID\",\n    \"YOUR_CLIENT_SECRET\",\n)\n\nscheme = OAuth2AuthorizationCodeBearer(\n    \"https://fief.mydomain.com/authorize\",\n    \"https://fief.mydomain.com/api/token\",\n    scopes={\"openid\": \"openid\", \"offline_access\": \"offline_access\"},\n    auto_error=False,\n)\n\nauth = FiefAuth(fief, scheme)\n\napp = FastAPI()\n\n\n@app.get(\"/user\")\nasync def get_user(\n    access_token_info: FiefAccessTokenInfo = Depends(\n        auth.authenticated(permissions=[\"castles:read\"])\n    ),\n):\n    return access_token_info\n</code></pre> <p>If one of the required permission is missing on ther user, a <code>403 Forbidden</code> error will automatically be returned.</p>"},{"location":"integrate/python/fastapi/#optional-user","title":"Optional user","text":"<p>Sometimes, you need to have a route retrieve the user if there is one authenticated, but still work if there is none. To do this, you can leverage the <code>optional</code> parameter of the <code>authenticated</code> dependency.</p> app.py<pre><code>from typing import Optional\n\nfrom fastapi import Depends, FastAPI\nfrom fastapi.security import OAuth2AuthorizationCodeBearer\nfrom fief_client import FiefAccessTokenInfo, FiefAsync\nfrom fief_client.integrations.fastapi import FiefAuth\n\nfief = FiefAsync(\n    \"https://fief.mydomain.com\",\n    \"YOUR_CLIENT_ID\",\n    \"YOUR_CLIENT_SECRET\",\n)\n\nscheme = OAuth2AuthorizationCodeBearer(\n    \"https://fief.mydomain.com/authorize\",\n    \"https://fief.mydomain.com/api/token\",\n    scopes={\"openid\": \"openid\", \"offline_access\": \"offline_access\"},\n    auto_error=False,\n)\n\nauth = FiefAuth(fief, scheme)\n\napp = FastAPI()\n\n\n@app.get(\"/optional-user\")\nasync def get_optional_user(\n    access_token_info: Optional[FiefAccessTokenInfo] = Depends(\n        auth.authenticated(optional=True)\n    ),\n):\n    if access_token_info is None:\n        return {\"message\": \"Anonymous user\"}\n    return access_token_info\n</code></pre>"},{"location":"integrate/python/fastapi/#web-application-example","title":"Web application example","text":"<p>This is for you if...</p> <ul> <li> Your FastAPI backend will render HTML pages.</li> <li> Your application is intended to be used in a browser.</li> </ul> <p>Prerequisites</p> <ul> <li> Allow the following Redirect URI on your Fief Client: <code>http://localhost:8000/auth-callback</code></li> </ul> <p>The examples we showed previously are working well in a pure REST API context: a frontend, like interactive documentation, a JavaScript application or a mobile app will take care of the OAuth2 authentication flow to retrieve an access token before making request to your API.</p> <p>Another common context is traditional web application, where the server takes care of generating HTML pages before returning it to the browser. In this case, we'll need some routes to redirect the user to the Fief login page if they're not authenticated and take care of storing the access token somewhere. This is what'll show in this example.</p> <p>Besides, we'll usually need the basic information about the authenticated user, like its email or the values of the custom user fields. We'll see how we can use it.</p> <p>Basically, here's what we'll do:</p> <ol> <li>This time, we'll expect the access token to be passed through a traditional cookie instead of an HTTP header. Cookies are very convenient when designing web apps because they are handled automatically by the browser.</li> <li>If the cookie is not present, we'll redirect the user to the Fief login page. Once again, the browser will help us a lot here since it'll automatically follow the redirection.</li> <li>Upon successful login, Fief will automatically redirect the user to the callback route. This callback route will take care of setting a new cookie containing the access token. It means that the access token will be safely stored in the browser memory.</li> <li>Finally, the user is redirected back to the protected route. The browser will automatically send the cookie containing the access token: our request is now authenticated!</li> </ol> app.py<pre><code>from fastapi import Depends, FastAPI, HTTPException, Query, Request, Response, status\nfrom fastapi.responses import HTMLResponse, RedirectResponse\nfrom fastapi.security import APIKeyCookie\nfrom fief_client import FiefAsync, FiefUserInfo\nfrom fief_client.integrations.fastapi import FiefAuth\n\n\nclass CustomFiefAuth(FiefAuth):  # (1)!\n    client: FiefAsync\n\n    async def get_unauthorized_response(self, request: Request, response: Response):\n        redirect_uri = request.url_for(\"auth_callback\")  # (2)!\n        auth_url = await self.client.auth_url(redirect_uri, scope=[\"openid\"])  # (3)!\n        raise HTTPException(\n            status_code=status.HTTP_307_TEMPORARY_REDIRECT,  # (4)!\n            headers={\"Location\": str(auth_url)},\n        )\n\n\nfief = FiefAsync(  # (5)!\n    \"https://fief.mydomain.com\",\n    \"YOUR_CLIENT_ID\",\n    \"YOUR_CLIENT_SECRET\",\n)\n\nSESSION_COOKIE_NAME = \"user_session\"\nscheme = APIKeyCookie(name=SESSION_COOKIE_NAME, auto_error=False)  # (6)!\nauth = CustomFiefAuth(fief, scheme)  # (7)!\napp = FastAPI()\n\n\n@app.get(\"/auth-callback\", name=\"auth_callback\")  # (8)!\nasync def auth_callback(request: Request, response: Response, code: str = Query(...)):\n    redirect_uri = request.url_for(\"auth_callback\")\n    tokens, _ = await fief.auth_callback(code, redirect_uri)  # (9)!\n\n    response = RedirectResponse(request.url_for(\"protected\"))  # (10)!\n    response.set_cookie(  # (11)!\n        SESSION_COOKIE_NAME,\n        tokens[\"access_token\"],\n        max_age=tokens[\"expires_in\"],\n        httponly=True,  # (12)!\n        secure=False,  # \u274c Set this to `True` in production (13)!\n    )\n\n    return response\n\n\n@app.get(\"/protected\", name=\"protected\")\nasync def protected(\n    user: FiefUserInfo = Depends(auth.current_user()),  # (14)!\n):\n    return HTMLResponse(\n        f\"&lt;h1&gt;You are authenticated. Your user email is {user['email']}&lt;/h1&gt;\"\n    )\n</code></pre> <ol> <li> <p>We customize the <code>FiefAuth</code> helper to fit our needs</p> <p>The base class is implemented with an API scenario in mind. Nevertheless, it's designed in a way you can customize its behavior when the user is not authenticated or has not the required scope.</p> <p>That's what'll do with the <code>get_unauthorized_response</code>.</p> </li> <li> <p>We build the redirect URL</p> <p>This points to our <code>/auth-callback</code> route that we define below.</p> </li> <li> <p>We generate an authorization URL on the Fief server</p> <p>Thanks to the <code>auth_url</code> method on the Fief client, we can automatically generate the authorization URL on the Fief server.</p> </li> <li> <p>We build a redirect response</p> <p>By setting a status code in the 3XX range, we tell the browser that it should redirect the user to another URL, specified in the <code>Location</code> header.</p> <p>You can read more about HTTP redirections on the MDN documentation.</p> </li> <li> <p>This doesn't change from the previous example</p> <p>The <code>FiefAsync</code> client is always at the heart of the integration \ud83d\ude09</p> </li> <li> <p>We use a scheme expecting a cookie</p> <p>Contrary to the previous examples, we expect the access token to be passed in a cookie. Thus, we use a dedicated scheme for that.</p> <p>Notice that we set the name of this cookie through the <code>SESSION_COOKIE_NAME</code> constant.</p> <p>Besides, we set the <code>auto_error</code> argument to <code>False</code>. It tells FastAPI user to bypass its built-in error response if the cookie is not present: we have our own logic to handle this.</p> </li> <li> <p>We use our custom <code>CustomFiefAuth</code> class</p> <p>Of course, now that we overloaded the behavior of this helper class, we shouldn't forget to actually use it!</p> </li> <li> <p>We implement an <code>/auth-callback</code> route</p> <p>This is the route that'll take care of exchanging the authorization code with a fresh access token and save it in a cookie.</p> <p>Notice that we set its <code>name</code> parameter: this is how we can generate its URL automatically with the <code>request.url_for</code> method.</p> </li> <li> <p>We generate an access token</p> <p>We finish the OAuth2 flow by exchanging the authorization code with a fresh access token.</p> </li> <li> <p>We build a redirection to the <code>/protected</code> route</p> <p>The user will now be correctly authenticated to our web application. Thus, we can redirect them to a protected page.</p> </li> <li> <p>We build a new cookie containing the access token</p> <p>The response will contain a <code>Set-Cookie</code> header instructing the browser to save the access token in its memory. This method allows us to configure each properties of the cookie.</p> <p>You can read more about HTTP cookies on the MDN documentation.</p> </li> <li> <p>Set the cookie as <code>HTTPOnly</code></p> <p>For such sensitive values, it's strongly recommended to set the cookie as <code>HTTPOnly</code>. It means that it won't be possible to read its value from JavaScript, reducing potential attacks.</p> </li> <li> <p>Set the cookie as secure in production</p> <p>For such sensitive values, it's strongly recommended to set the cookie as <code>Secure</code>. It tells the browser to send the cookie only on HTTPS (SSL) connection, reducing the risk of the access token to be stolen by a attacker between the client and the server.</p> <p>However, in a local environment, you usually don't serve your application with SSL. That's why we set it to <code>False</code> in this example. A common approach to handle this is to have an environment variable to control this parameter, so you can disable it in local and enable it in production.</p> </li> <li> <p>Use the <code>current_user</code> dependency</p> <p>This time, we use the <code>current_user</code> dependency instead of <code>authenticated</code>. Under the hood, it'll stil call <code>authenticated</code> and check if the cookie is available in the request and proceed if everything goes well. However, it'll return you a <code>FiefUserInfo</code> dictionary containing the data of the user.</p> <p>If the request is not authenticated, our custom <code>get_unauthorized_response</code> will be called and the user will be redirected to the Fief login page.</p> </li> </ol> <p>That's it! If you run this application and go to http://localhost:8000/protected, you'll be redirected to the Fief login page and experience the authentication flow before getting back to this route with a proper authentication cookie.</p> <p>Read the next example for a more optimal implementation</p> <p>In this example, the user information is not cached. For the performance of your application, we highly recommend you to read the next example.</p> <p><code>current_user</code> can also check for scope and permissions</p> <p>In a similar way as we shown in the API example, you can also require the access token to be granted a list of scopes or the user to be granted a list of permissions.</p> <pre><code>async def protected(\n    user: FiefUserInfo = Depends(auth.current_user(scope=[\"openid\", \"required_scope\"])),\n):\n    ...\n</code></pre> <pre><code>async def protected(\n    user: FiefUserInfo = Depends(auth.current_user(permissions=[\"castles:read\"])),\n):\n    ...\n</code></pre> <p>You can also optionally require the user</p> <p>In a similar way as we shown in the API example, you can leverage the <code>optional</code> parameter to make the route work even if no user is authenticated.</p> <pre><code>@app.get(\"/protected\", name=\"protected\")\nasync def protected(\n    user: Optional[FiefUserInfo] = Depends(auth.current_user(optional=True)),\n):\n    if user is None:\n        return HTMLResponse(\n            f\"&lt;h1&gt;You are an anonymous user.&lt;/h1&gt;\"\n        )\n    return HTMLResponse(\n        f\"&lt;h1&gt;You are authenticated. Your user email is {user['email']}&lt;/h1&gt;\"\n    )\n</code></pre>"},{"location":"integrate/python/fastapi/#caching-user-information","title":"Caching user information","text":"<p>In the previous example, we didn't set up cache for the user information. It means that everytime we hit the <code>/protected</code> route, the Fief API will be called to get the data. Obviously, this is not very optimal.</p> <p>Let's fix this! Fortunately, the client provides you useful tools to help you with this. Building upon the previous example, let's see how we can cache user information.</p> app.py<pre><code>import uuid\nfrom typing import Dict, Optional\n\nfrom fastapi import Depends, FastAPI, HTTPException, Query, Request, Response, status\nfrom fastapi.responses import HTMLResponse, RedirectResponse\nfrom fastapi.security import APIKeyCookie\nfrom fief_client import FiefAsync, FiefUserInfo\nfrom fief_client.integrations.fastapi import FiefAuth\n\n\nclass CustomFiefAuth(FiefAuth):\n    client: FiefAsync\n\n    async def get_unauthorized_response(self, request: Request, response: Response):\n        redirect_uri = request.url_for(\"auth_callback\")\n        auth_url = await self.client.auth_url(redirect_uri, scope=[\"openid\"])\n        raise HTTPException(\n            status_code=status.HTTP_307_TEMPORARY_REDIRECT,\n            headers={\"Location\": str(auth_url)},\n        )\n\n\nclass MemoryUserInfoCache:  # (1)!\n    def __init__(self) -&gt; None:\n        self.storage: Dict[uuid.UUID, FiefUserInfo] = {}  # (2)!\n\n    async def get(self, user_id: uuid.UUID) -&gt; Optional[FiefUserInfo]:  # (3)!\n        return self.storage.get(user_id)\n\n    async def set(self, user_id: uuid.UUID, userinfo: FiefUserInfo) -&gt; None:  # (4)!\n        self.storage[user_id] = userinfo\n\n\nmemory_userinfo_cache = MemoryUserInfoCache()  # (5)!\n\n\nasync def get_memory_userinfo_cache() -&gt; MemoryUserInfoCache:  # (6)!\n    return memory_userinfo_cache\n\n\nfief = FiefAsync(\n    \"https://fief.mydomain.com\",\n    \"YOUR_CLIENT_ID\",\n    \"YOUR_CLIENT_SECRET\",\n)\n\nSESSION_COOKIE_NAME = \"user_session\"\nscheme = APIKeyCookie(name=SESSION_COOKIE_NAME, auto_error=False)\nauth = CustomFiefAuth(\n    fief,\n    scheme,\n    get_userinfo_cache=get_memory_userinfo_cache,  # (7)!\n)\napp = FastAPI()\n\n\n@app.get(\"/auth-callback\", name=\"auth_callback\")\nasync def auth_callback(\n    request: Request,\n    response: Response,\n    code: str = Query(...),\n    memory_userinfo_cache: MemoryUserInfoCache = Depends(  # (8)!\n        get_memory_userinfo_cache\n    ),\n):\n    redirect_uri = request.url_for(\"auth_callback\")\n    tokens, userinfo = await fief.auth_callback(code, redirect_uri)\n\n    response = RedirectResponse(request.url_for(\"protected\"))\n    response.set_cookie(\n        SESSION_COOKIE_NAME,\n        tokens[\"access_token\"],\n        max_age=tokens[\"expires_in\"],\n        httponly=True,\n        secure=False,\n    )\n\n    await memory_userinfo_cache.set(uuid.UUID(userinfo[\"sub\"]), userinfo)  # (9)!\n\n    return response\n\n\n@app.get(\"/protected\", name=\"protected\")\nasync def protected(\n    user: FiefUserInfo = Depends(auth.current_user()),  # (10)!\n):\n    return HTMLResponse(\n        f\"&lt;h1&gt;You are authenticated. Your user email is {user['email']}&lt;/h1&gt;\"\n    )\n</code></pre> <ol> <li> <p>We start by implementing an helper class to store the user information somewhere</p> <p>The implementation is completely up-to-you and could be something rather complex, like using a Redis server to cache this information.</p> <p>We'll see that it expects you to implement two methods for working correctly with <code>FiefAuth</code>.</p> </li> <li> <p>We store the data in memory using a dictionary</p> <p>This is a very simple approach that will just store the data in memory. If your server is rebooted, the cache will be lost.</p> <p>It can work quite well when starting, but you'll probably need more robust approaches in the long run, like writing to a Redis store. The good thing is that you'll only need to change this class when the time comes!</p> </li> <li> <p>We implement the <code>.get</code> method</p> <p>This is the first compulsory method you have to implement in the class. It accepts an user ID as argument and expects you to return a cached <code>FiefUserInfo</code> dictionary or <code>None</code> if not available.</p> <p>Here, we simply read from our dictionary.</p> </li> <li> <p>We implement the <code>.set</code> method</p> <p>This is the second and last compulsory method you have to implement in the class. It accepts an user ID and a <code>FiefUserInfo</code> dictionary as arguments. There, you'll need to store this data in cache.</p> <p>Here, we simply set the user information into our dictionary.</p> </li> <li> <p>We instantiate <code>MemoryUserInfoCache</code> globally</p> <p>In order to have a global memory cache, we instantiate our class in the global context, at the same time of our FastAPI app.</p> <p>This way, the dictionary will be initialized at the same time our app is launched.</p> <p>Depending on your implementation, this may not be needed. We could also imagine to have a fresh instance every time we use it. This is typically the case when using database sessions for example.</p> </li> <li> <p>We define a callable dependency to get our class</p> <p>This pattern is typical of FastAPI. With a callable dependency, we are able to tell FastAPI to automatically instantiate objects, potentially needing other sub-dependencies as well.</p> <p>This is especially handy if you already have a dependency taking care of returning you a database connection or a session object for example.</p> <p>In our example here, we don't have any complex dependency, so we can just directly return the <code>memory_userinfo_cache</code> instance.</p> </li> <li> <p>We add the <code>get_userinfo_cache</code> argument to <code>CustomFiefAuth</code></p> <p>This is an optional keyword argument that basically tells <code>FiefAuth</code> to use the caching class returned by <code>get_userinfo_cache</code> when you want to get the user information.</p> <p>That's why it's important to strictly follow the methods signature presented above: <code>FiefAuth</code> will call them inside its logic.</p> </li> <li> <p>We add <code>memory_userinfo_cache</code> as a dependency to <code>auth_callback</code></p> <p>When a user has successfully authenticated, we do not only get the access token: we also get an ID token which already contains the user information.</p> <p>Hence, we'll take this opportunity to store it in our cache!</p> <p>Since we defined it as a callable dependency, we can directly use <code>get_memory_userinfo_cache</code> inside our route to use it.</p> </li> <li> <p>We cache the user information</p> <p>The ID token is automatically decoded by <code>fief.auth_callback</code> method.</p> <p>Thus, we just have to use our cache to store it!</p> </li> <li> <p>The <code>current_user</code> dependency doesn't change</p> <p>Nothing changes here! Now that we have set a <code>get_userinfo_cache</code> dependency, <code>current_user</code> will automatically use it to return you the user information.</p> <p>If it's not present in cache, it'll hit the Fief API.</p> <p>Note that you can use <code>auth.current_user(refresh=True)</code> if you need to always retrieve fresh data from the Fief API.</p> </li> </ol> <p>That's it! Now, we won't retrieve user information from the Fief API at each request. Typically, we'll set it in cache when the user authenticates and it'll be used during the lifetime of the session.</p>"},{"location":"integrate/python/flask/","title":"Flask","text":"<p>Flask is probably the most popular Python web framework.</p> <p>The Fief Python client provides tools to help you integrate Fief authentication in your Flask project. Let's see how to use them!</p>"},{"location":"integrate/python/flask/#install-the-client","title":"Install the client","text":"<p>Install the Fief client with the optional Flask dependencies:</p> <pre><code>pip install \"fief-client[flask]\"\n</code></pre>"},{"location":"integrate/python/flask/#api-example","title":"API example","text":"<p>This is for you if...</p> <ul> <li> Your Flask backend will work as a pure REST API.</li> <li> You have a separate frontend, like a JavaScript or mobile app, that'll take care of the OAuth2 flow.</li> </ul> <p>In this first example, we won't implement routes to perform the OAuth2 authentication. The goal here is just to show you how to protect your API route with a Fief access token.</p> app.py<pre><code>from fief_client import Fief\nfrom fief_client.integrations.flask import (\n    FiefAuth,\n    FiefAuthForbidden,\n    FiefAuthUnauthorized,\n    get_authorization_scheme_token,\n)\nfrom flask import Flask, g\n\nfief = Fief(  # (1)!\n    \"https://fief.mydomain.com\",\n    \"YOUR_CLIENT_ID\",\n    \"YOUR_CLIENT_SECRET\",\n)\n\nauth = FiefAuth(fief, get_authorization_scheme_token())  # (2)!\n\napp = Flask(__name__)\n\n\n@app.errorhandler(FiefAuthUnauthorized)  # (3)!\ndef fief_unauthorized_error(e):\n    return \"\", 401\n\n\n@app.errorhandler(FiefAuthForbidden)  # (4)!\ndef fief_forbidden_error(e):\n    return \"\", 403\n\n\n@app.get(\"/authenticated\")\n@auth.authenticated()  # (5)!\ndef get_authenticated():\n    return g.access_token_info  # (6)!\n\n\n@app.get(\"/authenticated-scope\")\n@auth.authenticated(scope=[\"openid\", \"required_scope\"])  # (7)!\ndef get_authenticated_scope():\n    return g.access_token_info\n\n\n@app.get(\"/authenticated-permissions\")\n@auth.authenticated(permissions=[\"castles:read\"])  # (8)!\ndef get_authenticated_permissions():\n    return g.access_token_info\n</code></pre> <ol> <li> <p>Fief client instantiation</p> <p>As we showed in the standard Python section, we instantiate here a Fief client here with the base tenant URL and client credentials.</p> </li> <li> <p>Fief helper for Flask</p> <p>This is the helper doing the tedious work for you with Flask. It first needs an instance of the Fief client we created above and a function retrieving the access token from the Flask request.</p> <p>It's a simple function which can use the global <code>request</code> object to retrieve the access token.</p> <p>For convenience, we provide two of them: <code>get_authorization_scheme_token</code> and <code>get_cookie</code>.</p> </li> <li> <p>Error handler for <code>FiefAuthUnauthorized</code></p> <p>When a protected route is called without a valid access token, the Fief helper will raise the <code>FiefAuthUnauthorized</code>.</p> <p>By registering a Flask error handler, we can catch this error and customize the response returned to the user. Here, we just return an empty response with the 401 status code.</p> </li> <li> <p>Error handler for <code>FiefAuthForbidden</code></p> <p>When a request is made with a valid access token but without the required scope, the Fief helper will raise the <code>FiefAuthForbidden</code>.</p> <p>By registering a Flask error handler, we can catch this error and customize the response returned to the user. Here, we just return an empty response with the 403 status code.</p> </li> <li> <p><code>authenticated</code> decorator</p> <p>This is where the magic happens: <code>FiefAuth</code> gives you a <code>authenticated</code> decorator to check for the access token and optionally for required scopes.</p> <p>If everything goes well, the route logic will be executed.</p> </li> <li> <p><code>access_token_info</code> dictionary is available in <code>g</code></p> <p>When a valid access token is found in the request, the <code>access_token_info</code> decorator will automatically add the <code>access_token_info</code> property to the global <code>g</code> application context of Flask.</p> <p>This <code>access_token_info</code> property is a <code>FiefAccessTokenInfo</code> dictionary containing the ID of the user, the list of allowed scopes and permissions and the raw access token.</p> </li> <li> <p>Check for scopes</p> <p>The <code>access_token_info</code> decorator accepts an optional <code>scope</code> argument where you can list the scope required to access this route.</p> <p>If the access token doesn't have the required scope, <code>FiefAuthForbidden</code> error is raised.</p> </li> <li> <p>Check for permissions</p> <p>The <code>access_token_info</code> decorator accepts an optional <code>permissions</code> argument where you can list the permissions required to access this route.</p> <p>If the user doesn't have the required permissions, <code>FiefAuthForbidden</code> is raised.</p> </li> </ol> <p>And that's about it!</p>"},{"location":"integrate/python/flask/#optional-user","title":"Optional user","text":"<p>Sometimes, you need to have a route retrieving the user if there is one authenticated, but still working if there none. To do this, you can leverage the <code>optional</code> parameter of the <code>authenticated</code> decorator.</p> app.py<pre><code>from fief_client import Fief\nfrom fief_client.integrations.flask import (\n    FiefAuth,\n    FiefAuthForbidden,\n    FiefAuthUnauthorized,\n    get_authorization_scheme_token,\n)\nfrom flask import Flask, g\n\nfief = Fief(\n    \"https://fief.mydomain.com\",\n    \"YOUR_CLIENT_ID\",\n    \"YOUR_CLIENT_SECRET\",\n)\n\nauth = FiefAuth(fief, get_authorization_scheme_token())\n\napp = Flask(__name__)\n\n\n@app.errorhandler(FiefAuthUnauthorized)\ndef fief_unauthorized_error(e):\n    return \"\", 401\n\n\n@app.errorhandler(FiefAuthForbidden)\ndef fief_forbidden_error(e):\n    return \"\", 403\n\n\n@app.get(\"/authenticated\")\n@auth.authenticated(optional=True)\ndef get_authenticated():\n    if g.access_token_info is None:\n        return {\"message\": \"Anonymous user\"}\n    return g.access_token_info\n</code></pre>"},{"location":"integrate/python/flask/#web-application-example","title":"Web application example","text":"<p>This is for you if...</p> <ul> <li> Your Flask backend will render HTML pages.</li> <li> Your application is intended to be used in a browser.</li> </ul> <p>Prerequisites</p> <ul> <li> Allow the following Redirect URI on your Fief Client: <code>http://localhost:8000/auth-callback</code></li> </ul> <p>The examples we showed previously are working well in a pure REST API context: a frontend, like interactive documentation, a JavaScript application or a mobile app will take care of the OAuth2 authentication flow to retrieve an access token before making request to your API.</p> <p>Another common context is traditional web application, where the server takes care of generating HTML pages before returning it to the browser. In this case, we'll need some routes to redirect the user to the Fief login page if they're not authenticated and take care of storing the access token somewhere. This is what'll show in this example.</p> <p>Besides, we'll usually need the basic information about the authenticated user, like its email or the values of the custom user fields. We'll see how we can use it.</p> <p>Basically, here's what we'll do:</p> <ol> <li>This time, we'll expect the access token to be passed through a traditional cookie instead of an HTTP header. Cookies are very convenient when designing web apps because they are handled automatically by the browser.</li> <li>If the cookie is not present, we'll redirect the user to the Fief login page. Once again, the browser will help us a lot here since it'll automatically follow the redirection.</li> <li>Upon successful login, Fief will automatically redirect the user to the callback route. This callback route will take care of setting a new cookie containing the access token. It means that the access token will be safely stored in the browser memory.</li> <li>Finally, the user is redirected back to the protected route. The browser will automatically send the cookie containing the access token: our request is now authenticated!</li> </ol> app.py<pre><code>import uuid\nfrom typing import Optional\n\nfrom fief_client import Fief, FiefUserInfo\nfrom fief_client.integrations.flask import (\n    FiefAuth,\n    FiefAuthForbidden,\n    FiefAuthUnauthorized,\n    get_cookie,\n)\nfrom flask import Flask, g, redirect, request, session, url_for\n\nSESSION_COOKIE_NAME = \"user_session\"\nSECRET_KEY = \"SECRET\"  # (1)!\n\n\nfief = Fief(  # (2)!\n    \"https://fief.mydomain.com\",\n    \"YOUR_CLIENT_ID\",\n    \"YOUR_CLIENT_SECRET\",\n)\n\n\ndef get_userinfo_cache(id: uuid.UUID) -&gt; Optional[FiefUserInfo]:  # (3)!\n    return session.get(f\"userinfo-{str(id)}\")\n\n\ndef set_userinfo_cache(id: uuid.UUID, userinfo: FiefUserInfo) -&gt; None:  # (4)!\n    session[f\"userinfo-{str(id)}\"] = userinfo\n\n\nauth = FiefAuth(\n    fief,\n    get_cookie(SESSION_COOKIE_NAME),  # (5)\n    get_userinfo_cache=get_userinfo_cache,  # (6)!\n    set_userinfo_cache=set_userinfo_cache,\n)\napp = Flask(__name__)\napp.secret_key = SECRET_KEY\n\n\n@app.errorhandler(FiefAuthUnauthorized)  # (7)!\ndef fief_unauthorized_error(e):\n    redirect_uri = url_for(\"auth_callback\", _external=True)  # (8)!\n    auth_url = fief.auth_url(redirect_uri, scope=[\"openid\"])  # (9)!\n    return redirect(auth_url)  # (10)!\n\n\n@app.errorhandler(FiefAuthForbidden)\ndef fief_forbidden_error(e):\n    return \"\", 403\n\n\n@app.get(\"/auth-callback\")  # (11)!\ndef auth_callback():\n    redirect_uri = url_for(\"auth_callback\", _external=True)\n    code = request.args[\"code\"]\n    tokens, userinfo = fief.auth_callback(code, redirect_uri)  # (12)!\n\n    response = redirect(url_for(\"protected\"))  # (13)!\n    response.set_cookie(  # (14)!\n        SESSION_COOKIE_NAME,\n        tokens[\"access_token\"],\n        max_age=tokens[\"expires_in\"],\n        httponly=True,  # (15)!\n        secure=False,  # \u274c Set this to `True` in production (16)!\n    )\n\n    set_userinfo_cache(uuid.UUID(userinfo[\"sub\"]), userinfo)  # (17)!\n\n    return response\n\n\n@app.get(\"/protected\")\n@auth.current_user()  # (18)!\ndef protected():\n    user = g.user  # (19)!\n    return f\"&lt;h1&gt;You are authenticated. Your user email is {user['email']}&lt;/h1&gt;\"\n</code></pre> <ol> <li> <p>Define a secret key for Flask</p> <p>We'll use the Sessions mechanism from Flask to keep user information in cache. To enable it, we need to set a secret key for Flask.</p> <p>Generate a strong passphrase and don't share it.</p> <p>Avoid to hardcode your secrets in your code</p> <p>It's usually not recommended to hardcode secrets like Client ID and Secret in your code like this. If your code gets published on the web, for example on GitHub, the security of your instance would be compromised.</p> <p>Besides, it'll be harder if you need to deploy on several environments, like a staging or testing one, in addition to your production environment.</p> <p>A standard and widely-used approach is to use environment variables.</p> </li> <li> <p>This doesn't change from the previous example</p> <p>The <code>Fief</code> client is always at the heart of the integration \ud83d\ude09</p> </li> <li> <p>We define a function to retrieve user information from cache</p> <p>To make sure we don't call the Fief API every time we want the user data, we'll cache it in our application. It'll be way more performant!</p> <p>To do this, we implement a simple function allowing us to retrieve the user information given a user ID.</p> <p>In this example, we simply use the Sessions mechanism from Flask, but it can be something more complex, like reading from a Redis store.</p> </li> <li> <p>We define a function to set user information in cache</p> <p>As you probably have guessed, we need the other side of the operation: saving user information in cache.</p> <p>To do this, we implement a simple function accepting a user ID and a <code>FiefUserInfo</code> dictionary as arguments. There, you'll need to store this data in cache.</p> <p>In this example, we simply use the Sessions mechanism from Flask, but it can be something more complex, like writing to a Redis store.</p> </li> <li> <p>We use a cookie getter</p> <p>Contrary to the previous examples, we expect the access token to be passed in a cookie. Thus, we use the <code>get_cookie</code> getter.</p> <p>Notice that we set the name of this cookie through the <code>SESSION_COOKIE_NAME</code> constant.</p> </li> <li> <p>We pass both <code>get_userinfo_cache</code> and <code>set_userinfo_cache</code> as arguments</p> <p>Basically, we tell <code>FiefAuth</code> to use the caching functions we implemented when we want to get the user information.</p> <p>That's why it's important to strictly follow the functions signature presented above: <code>FiefAuth</code> will call them inside its logic.</p> </li> <li> <p>We change the error handler for <code>FiefAuthUnauthorized</code></p> <p>This time, we'll generate a redirect response so the user can login on Fief.</p> </li> <li> <p>We build the redirect URL</p> <p>This points to our <code>/auth-callback</code> route that we define below.</p> </li> <li> <p>We generate an authorization URL on the Fief server</p> <p>Thanks to the <code>auth_url</code> method on the Fief client, we can automatically generate the authorization URL on the Fief server.</p> </li> <li> <p>We build a redirect response</p> <p>We redirect the user to the Fief authorization URL.</p> </li> <li> <p>We implement an <code>/auth-callback</code> route</p> <p>This is the route that'll take care of exchanging the authorization code with a fresh access token and save it in a cookie.</p> </li> <li> <p>We generate an access token</p> <p>We finish the OAuth2 flow by exchanging the authorization code with a fresh access token.</p> </li> <li> <p>We build a redirection to the <code>/protected</code> route</p> <p>The user will now be correctly authenticated to our web application. Thus, we can redirect them to a protected page.</p> </li> <li> <p>We build a new cookie containing the access token</p> <p>The response will contain a <code>Set-Cookie</code> header instructing the browser to save the access token in its memory. This method allows us to configure each properties of the cookie.</p> <p>You can read more about HTTP cookies on the MDN documentation.</p> </li> <li> <p>Set the cookie as <code>HTTPOnly</code></p> <p>For such sensitive values, it's strongly recommended to set the cookie as <code>HTTPOnly</code>. It means that it won't be possible to read its value from JavaScript, reducing potential attacks.</p> </li> <li> <p>Set the cookie as secure in production</p> <p>For such sensitive values, it's strongly recommended to set the cookie as <code>Secure</code>. It tells the browser to send the cookie only on HTTPS (SSL) connection, reducing the risk of the access token to be stolen by a attacker between the client and the server.</p> <p>However, in a local environment, you usually don't serve your application with SSL. That's why we set it to <code>False</code> in this example. A common approach to handle this is to have an environment variable to control this parameter, so you can disable it in local and enable it in production.</p> </li> <li> <p>We cache the user information</p> <p>When a user has successfully authenticated, we do not only get the access token: we also get an ID token which already contains the user information.</p> <p>Hence, we'll take this opportunity to store it in our cache! The ID token is automatically decoded by <code>fief.auth_callback</code> method.</p> <p>Thus, we just have to use our cache function to store it!</p> </li> <li> <p>Use the <code>current_user</code> decorator</p> <p>This time, we use the <code>current_user</code> decorator instead of <code>authenticated</code>. Under the hood, it'll stil call <code>authenticated</code> and check if the cookie is available in the request and proceed if everything goes well. However, it'll return you a <code>FiefUserInfo</code> dictionary containing the data of the user.</p> <p>If the request is not authenticated, an <code>FiefAuthUnauthorized</code> error will be raised and the user will be redirected to the Fief login page.</p> </li> <li> <p><code>user</code> dictionary is available in <code>g</code></p> <p>If the request is properly authenticated, the <code>current_user</code> decorator will automatically add the <code>user</code> property to the global <code>g</code> application context of Flask.</p> <p>This <code>user</code> property is a <code>FiefUserInfo</code> dictionary containing the user data. If it's not available in cache, it's automatically retrieved from the Fief API.</p> </li> </ol> <p>That's it! If you run this application and go to http://localhost:8000/protected, you'll be redirected to the Fief login page and experience the authentication flow before getting back to this route with a proper authentication cookie.</p> <p><code>current_user</code> can also check for scope and permissions</p> <p>In a similar way as we shown in the API example, you can also require the access token to be granted a list of scopes or the user to be granted a list of permissions.</p> <pre><code>@app.get(\"/protected\")\n@auth.current_user(scope=[\"openid\", \"required_scope\"])\ndef protected():\n    ...\n</code></pre> <pre><code>@app.get(\"/protected\")\n@auth.current_user(permissions=[\"castles:read\"])\ndef protected():\n    ...\n</code></pre> <p>You can also optionally require the user</p> <p>In a similar way as we shown in the API example, you can leverage the <code>optional</code> parameter to make the route works even if no user is authenticated.</p> <pre><code>@app.get(\"/protected\")\n@auth.current_user(optional=True)\ndef protected():\n    user = g.user\n    if user is None:\n        return f\"&lt;h1&gt;You are an anonymous user.&lt;/h1&gt;\"\n    return f\"&lt;h1&gt;You are authenticated. Your user email is {user['email']}&lt;/h1&gt;\"\n</code></pre>"},{"location":"miscellaneous/resources/","title":"Resources","text":"<ul> <li>RFC7517 (JSON Web Key): https://datatracker.ietf.org/doc/html/rfc7517</li> <li>RFC7636 (OAuth2 PKCE): https://datatracker.ietf.org/doc/html/rfc7636</li> <li>RFC8414 (OAuth2 Metadata): https://datatracker.ietf.org/doc/html/rfc8414</li> <li>OpenID Connect 1.0 specification: https://openid.net/specs/openid-connect-core-1_0.html</li> <li>JWCrypto's library documentation: https://jwcrypto.readthedocs.io/</li> </ul>"},{"location":"self-hosting/","title":"Self-hosting","text":"<p>Fief is a platform that you host for free on your own infrastructure.</p> <p>In Getting started, we show you a way to easily start your instance locally. However, for production usage, we highly recommend you to perform a complete setup. We provide guides and blueprints to get you started on various hosting technologies and cloud platforms.</p> <p>Railway Render Docker Compose</p>"},{"location":"self-hosting/#comparison","title":"Comparison","text":"Platform Setup Maintenance Cost Rewards Fief financially Railway Easy Easy Average <sup>1</sup> Render Easy Easy Average Docker Compose Medium Medium Cheap"},{"location":"self-hosting/#not-sure","title":"Not sure ? \ud83e\udd14","text":"<p>If you're not sure about the way to go, ask us on the GitHub Discussions forum. We're here to help!</p> <ol> <li> <p>Railway rewards us 25% of your spending in the form of platform credits, as part of their Template Kickback program. It doesn't directly finance us, but it helps us to pay some bills, like our GitHub bot.\u00a0\u21a9</p> </li> </ol>"},{"location":"self-hosting/environment-variables/","title":"Environment variables","text":"<p>Fief server relies heavily on environment variables for configuration. You'll likely need to adjust those settings for your deployment.</p>"},{"location":"self-hosting/environment-variables/#set-environment-variables","title":"Set environment variables","text":""},{"location":"self-hosting/environment-variables/#using-docker","title":"Using Docker","text":"<p>When running Fief server with Docker, the most straightforward way is to use the <code>-e</code> option on the command line, as shown in Getting started.</p> <pre><code>docker run \\\n  --name fief-server \\\n  -p 8000:8000 \\\n  -d \\\n  -e \"SECRET=XXX\" \\\n  -e \"FIEF_CLIENT_ID=XXX\" \\\n  -e \"FIEF_CLIENT_SECRET=XXX\" \\\n  -e \"ENCRYPTION_KEY=XXX\" \\\n  -e \"PORT=8000\" \\\n  -e \"FIEF_DOMAIN=localhost:8000\" \\\n  -e \"CSRF_COOKIE_SECURE=False\" \\\n  -e \"LOGIN_SESSION_COOKIE_SECURE=False\" \\\n  -e \"SESSION_COOKIE_SECURE=False\" \\\n  -e \"FIEF_ADMIN_SESSION_COOKIE_SECURE=False\" \\\n  ghcr.io/fief-dev/fief:latest\n</code></pre> <p>However, it may become hard to maintain when having lot of variables to set. An alternative way is to use a <code>.env</code> file. It's a simple file where each line consists of a key and a value separated by an equal sign:</p> .env<pre><code>SECRET=XXX\nFIEF_CLIENT_ID=XXX\nFIEF_CLIENT_SECRET=XXX\nENCRYPTION_KEY=XXX\nPORT=8000\nFIEF_DOMAIN=localhost:8000\nCSRF_COOKIE_SECURE=False\nLOGIN_SESSION_COOKIE_SECURE=False\nSESSION_COOKIE_SECURE=False\nFIEF_ADMIN_SESSION_COOKIE_SECURE=False\n</code></pre> <p>Then, you can reference this file in the Docker command:</p> <pre><code>docker run \\\n  --name fief-server \\\n  -p 8000:8000 \\\n  -d \\\n  --env-file .env \\\n  ghcr.io/fief-dev/fief:latest\n</code></pre>"},{"location":"self-hosting/environment-variables/#other-methods-of-deployment","title":"Other methods of deployment","text":"<p>Depending on your method of deployment, the way of setting environment variables will be different. We show you several ways of deploying Fief in production in the previous section.</p>"},{"location":"self-hosting/environment-variables/#reference","title":"Reference","text":"<p>For each variable, we'll try to provide a sensible example value to help you configure it correctly. Throughout the examples, we'll assume that you host your Fief server on the sub-domain <code>fief.bretagne.duchy</code>.</p>"},{"location":"self-hosting/environment-variables/#general","title":"General","text":"Name Description Default Allowed values Example <code>ENVIRONMENT</code> Name of the deployment environment production development, staging, production production <code>LOG_LEVEL</code> Log verbosity <code>TELEMETRY_ENABLED</code> Whether to enable telemetry True <code>ALLOW_ORIGIN_REGEX</code> Regex used to control CORS access to your API http://.*localhost:[0-9]+ https://.*\\.bretagne.duchy <code>PORT</code> Internal port on which the Fief server is available 8000 8000 <code>FORWARDED_ALLOW_IPS</code> Comma separated list of IPs to trust with proxy headers. Read more 127.0.0.1"},{"location":"self-hosting/environment-variables/#secrets","title":"Secrets","text":"Name Description Default Allowed values Example <code>SECRET</code> Secret value used to sign reset password tokens. Any sufficiently long string <code>ENCRYPTION_KEY</code> Key used to encrypt the external databases credentials inside the main database A valid Fernet key encoded in UTF-8 <code>GENERATED_JWK_SIZE</code> Size in bits of the generated RSA key pair used to sign JWT. 4096 <p>Encryption key generator</p> <p> <pre><code>\n</code></pre> Generate key </p> <p>The encryption key should be a valid key for the Fernet encryption algorithm. Use the generator above to get yours! Keep it secret.</p>"},{"location":"self-hosting/environment-variables/#database","title":"Database","text":"Name Description Default Allowed values Example <code>DATABASE_TYPE</code> Type of the main database SQLITE POSTGRESQL, MYSQL, SQLITE POSTGRESQL <code>DATABASE_HOST</code> Host of the main database localhost <code>DATABASE_PORT</code> Listening port of the main database 5432 <code>DATABASE_USERNAME</code> Main database user fief <code>DATABASE_PASSWORD</code> Main database user's password fiefpassword <code>DATABASE_NAME</code> Main database name fief.db fief <code>DATABASE_SSL_MODE</code> Main database SSL mode Varies by database type require <code>DATABASE_LOCATION</code> For SQLite databases, path where to store the database files Current working directory <code>DATABASE_POOL_RECYCLE_SECONDS</code> Maximum lifetime in seconds of a database connection in the connection pool. Useful for servers cutting idle connections after some time. Read more. 600 (10 minutes) <code>DATABASE_POOL_PRE_PING</code> Whether to always issue a query before returning a database connection to make sure it's alive. Read more. False <code>DATABASE_POOL_SIZE</code> Number of connections to the database to keep alive. Read more. 5 <code>DATABASE_POOL_MAX_OVERFLOW</code> Maximum number of extra database connection to spawn when pool size is reached. Read more. 10 <code>DATABASE_URL</code> Full database connection string, useful for some cloud providers. It'll take precedence over the single parameters above. <p>More details about how to configure a database in the dedicated section.</p> <p>Configure database</p>"},{"location":"self-hosting/environment-variables/#redis","title":"Redis","text":"<p>We use a Redis instance to manage background jobs (send emails, heavy computations...). A Redis instance is already up-and-running in the official Docker image, but you can provide your own one if needed.</p> Name Description Default Allowed values Example <code>REDIS_URL</code> URL of a Redis server redis://localhost:6379"},{"location":"self-hosting/environment-variables/#email-provider","title":"Email provider","text":"Name Description Default Allowed values Example <code>EMAIL_PROVIDER</code> Type of email provider NULL NULL, SMTP, POSTMARK, SENDGRID POSTMARK <code>EMAIL_PROVIDER_PARAMS</code> Configuration dictionary of the email provider {} {\"server_token\": \"XXX-XXX\"} <code>DEFAULT_FROM_EMAIL</code> Default transactional emails sender email address contact@fief.dev contact@bretagne.duchy <code>DEFAULT_FROM_NAME</code> Default transactional emails sender name Fief Bretagne <p>More details about how to configure an email provider in the dedicated section.</p> <p>Configure email provider</p>"},{"location":"self-hosting/environment-variables/#webhooks","title":"Webhooks","text":"Name Description Default Allowed values Example <code>WEBHOOKS_MAX_ATTEMPTS</code> Maximum attempts to deliver a webhook event before giving up. 5"},{"location":"self-hosting/environment-variables/#csrf-cookie","title":"CSRF cookie","text":"<p>To protect against Cross-Site-Request-Forgery attacks on authentication pages, we use the double-submit cookie pattern.</p> Name Description Default Allowed values Example <code>CSRF_CHECK_ENABLED</code> Whether to enable the CSRF protection. In most cases, this should remain enabled. True <code>CSRF_COOKIE_NAME</code> Name of the CSRF token cookie fief_csrftoken <code>CSRF_COOKIE_SECURE</code> Secure flag of the login session cookie True <p><code>_COOKIE_SECURE</code> flag should be <code>True</code> in production</p> <p>Browser cookies support the <code>Secure</code> flag, which tells the browser to not forward the cookie if the site is not requested in HTTPS.</p> <p>For your convenience when starting Fief on your local machine, the Quickstart command will set those flags to <code>False</code> for every Fief cookies.</p> <p>However, for security reasons, it's strongly recommended to set those flags to <code>True</code> (the default if not specified) when deploying to production.</p>"},{"location":"self-hosting/environment-variables/#user-locale-cookie","title":"User locale cookie","text":"<p>The user locale cookie maintains the language of the user on the authentication pages.</p> Name Description Default Allowed values Example <code>USER_LOCALE_COOKIE_NAME</code> Name of the user locale cookie fief_locale <code>USER_LOCALE_COOKIE_DOMAIN</code> Domain of the user locale cookie Empty string <code>USER_LOCALE_COOKIE_SECURE</code> Secure flag of user locale cookie True <code>USER_LOCALE_LIFETIME_SECONDS</code> Lifetime of the user locale cookie in seconds 86400 * 30 (30 days) <p><code>_COOKIE_SECURE</code> flag should be <code>True</code> in production</p> <p>Browser cookies support the <code>Secure</code> flag, which tells the browser to not forward the cookie if the site is not requested in HTTPS.</p> <p>For your convenience when starting Fief on your local machine, the Quickstart command will set those flags to <code>False</code> for every Fief cookies.</p> <p>However, for security reasons, it's strongly recommended to set those flags to <code>True</code> (the default if not specified) when deploying to production.</p>"},{"location":"self-hosting/environment-variables/#login-hint-cookie","title":"Login hint cookie","text":"<p>The login hint cookie is used to remember the last method a user used to login. Its value can either be an email address or the ID of an OAuth Provider enabled on the user's tenant.</p> Name Description Default Allowed values Example <code>LOGIN_HINT_COOKIE_NAME</code> Name of the login hint cookie fief_login_hint <code>LOGIN_HINT_COOKIE_DOMAIN</code> Domain of the login hint cookie Empty string <code>LOGIN_HINT_COOKIE_SECURE</code> Secure flag of login hint cookie True <code>LOGIN_HINT_COOKIE_LIFETIME_SECONDS</code> Lifetime of the login hint cookie in seconds 86400 * 30 (30 days) <p><code>_COOKIE_SECURE</code> flag should be <code>True</code> in production</p> <p>Browser cookies support the <code>Secure</code> flag, which tells the browser to not forward the cookie if the site is not requested in HTTPS.</p> <p>For your convenience when starting Fief on your local machine, the Quickstart command will set those flags to <code>False</code> for every Fief cookies.</p> <p>However, for security reasons, it's strongly recommended to set those flags to <code>True</code> (the default if not specified) when deploying to production.</p>"},{"location":"self-hosting/environment-variables/#login-session","title":"Login session","text":"<p>A login session is a cookie used to maintain the state of the login flow of a user, from the login page until they're redirected to your application.</p> Name Description Default Allowed values Example <code>LOGIN_SESSION_COOKIE_NAME</code> Name of the login session cookie fief_login_session <code>LOGIN_SESSION_COOKIE_DOMAIN</code> Domain of the login session cookie Empty string <code>LOGIN_SESSION_COOKIE_SECURE</code> Secure flag of the login session cookie True <code>LOGIN_SESSION_LIFETIME_SECONDS</code> Lifetime of the login session cookie in seconds 600 (10 minutes) <p><code>_COOKIE_SECURE</code> flag should be <code>True</code> in production</p> <p>Browser cookies support the <code>Secure</code> flag, which tells the browser to not forward the cookie if the site is not requested in HTTPS.</p> <p>For your convenience when starting Fief on your local machine, the Quickstart command will set those flags to <code>False</code> for every Fief cookies.</p> <p>However, for security reasons, it's strongly recommended to set those flags to <code>True</code> (the default if not specified) when deploying to production.</p>"},{"location":"self-hosting/environment-variables/#registration-session","title":"Registration session","text":"<p>A registration session is a cookie used to maintain the state of the registration flow of a new user, from the registration page until their account is created.</p> Name Description Default Allowed values Example <code>REGISTRATION_SESSION_COOKIE_NAME</code> Name of the registration session cookie fief_registration_session <code>REGISTRATION_SESSION_COOKIE_DOMAIN</code> Domain of the registration session cookie Empty string <code>REGISTRATION_SESSION_COOKIE_SECURE</code> Secure flag of the registration session cookie True <code>REGISTRATION_SESSION_LIFETIME_SECONDS</code> Lifetime of the registration session cookie in seconds 600 (10 minutes) <p><code>_COOKIE_SECURE</code> flag should be <code>True</code> in production</p> <p>Browser cookies support the <code>Secure</code> flag, which tells the browser to not forward the cookie if the site is not requested in HTTPS.</p> <p>For your convenience when starting Fief on your local machine, the Quickstart command will set those flags to <code>False</code> for every Fief cookies.</p> <p>However, for security reasons, it's strongly recommended to set those flags to <code>True</code> (the default if not specified) when deploying to production.</p>"},{"location":"self-hosting/environment-variables/#email-verification","title":"Email verification","text":"<p>Users must verify their email address using a code sent by email. The code is a random string composed of letters and digits, e.g. <code>ABC123</code>.</p> Name Description Default Allowed values Example <code>EMAIL_VERIFICATION_CODE_LENGTH</code> Length of the verification code 6 <code>EMAIL_VERIFICATION_LIFETIME_SECONDS</code> Lifetime of the verification code in seconds 3600 (1 hour)"},{"location":"self-hosting/environment-variables/#oauth-session","title":"OAuth session","text":"<p>An OAuth session is used to maintain the state of an OAuth authentication with an OAuth Provider, from the moment they click on the Sign in with... button until they're redirected.</p> Name Description Default Allowed values Example <code>OAUTH_SESSION_LIFETIME_SECONDS</code> Lifetime of the OAuth session in seconds 600 (10 minutes)"},{"location":"self-hosting/environment-variables/#session","title":"Session","text":"<p>A session is a cookie used to maintain the session of a user on the Fief authentication pages. It's different from the session you'll maintain in your own application.</p> <p>Its purpose is to allow a user to re-authenticate quickly to your app without having them to input their credentials again.</p> Name Description Default Allowed values Example <code>SESSION_COOKIE_NAME</code> Name of the session cookie fief_session <code>SESSION_COOKIE_DOMAIN</code> Domain of the session cookie Empty string <code>SESSION_COOKIE_SECURE</code> Secure flag of the session cookie True <code>SESSION_LIFETIME_SECONDS</code> Lifetime of the session cookie in seconds 86400 * 30 (30 days) <p><code>_COOKIE_SECURE</code> flag should be <code>True</code> in production</p> <p>Browser cookies support the <code>Secure</code> flag, which tells the browser to not forward the cookie if the site is not requested in HTTPS.</p> <p>For your convenience when starting Fief on your local machine, the Quickstart command will set those flags to <code>False</code> for every Fief cookies.</p> <p>However, for security reasons, it's strongly recommended to set those flags to <code>True</code> (the default if not specified) when deploying to production.</p>"},{"location":"self-hosting/environment-variables/#client-redirect-uris","title":"Client redirect URIs","text":"Name Description Default Allowed values Example <code>CLIENT_REDIRECT_URI_SSL_REQUIRED</code> Whether to enforce the use of HTTPS URL for Client redirect URIs True <p>This flag should be <code>True</code> in production</p> <p>Using SSL/HTTPS URLs for the OAuth2 callback is critical for security. Allowing a non-encrypted redirection could enable malicious users to steal the authorization code during the process.</p> <p>This flag is provided for convenience when running Fief in development and testing environments.</p>"},{"location":"self-hosting/environment-variables/#authorization-codes-and-tokens-lifetimes","title":"Authorization codes and tokens lifetimes","text":"<p>Authorization codes are temporary codes generated during the OAuth2 authentication flow. Access tokens, ID tokens and refresh tokens are generated after a successful OAuth2 authentication flow.</p> <p>The variables below control the default lifetime for each one of them when a client is created. Those values can then be customized per client.</p> Name Description Default Allowed values Example <code>DEFAULT_AUTHORIZATION_CODE_LIFETIME_SECONDS</code> Default lifetime of the authorization code in seconds. For security reasons, this value should remain low. OAuth2 specification recommends a value of 10 minutes. 600 (10 minutes) <code>DEFAULT_ACCESS_ID_TOKEN_LIFETIME_SECONDS</code> Default lifetime of the access token and ID token in seconds. 86400 (24 hours) <code>DEFAULT_REFRESH_TOKEN_LIFETIME_SECONDS</code> Default lifetime of the refresh token in seconds. 2592000 (30 days)"},{"location":"self-hosting/environment-variables/#fief-ception","title":"Fief-ception","text":"<p>Fief-ception is a mind-fucking concept describing the fact that we actually use Fief to authenticate Fief admins \ud83e\udd2f</p> <p>That's why we set necessary variables to create the main client and first admin user, as described in the Getting started section.</p> <p>The variables below are here to configure the Fief server with a proper Fief client, as you would do in your own application!</p> Name Description Default Allowed values Example <code>FIEF_DOMAIN</code> Domain of your Fief instance localhost:8000 fief.bretagne.duchy <code>FIEF_CLIENT_ID</code> Client ID in your instance <code>FIEF_CLIENT_SECRET</code> Client secret in your instance <code>FIEF_ENCRYPTION_KEY</code> Optional RSA key used to encrypt the JWT tokens <code>FIEF_MAIN_USER_EMAIL</code> Email address of the first admin user. If provided, the user will be created automatically on startup. anne@bretagne.duchy <code>FIEF_MAIN_USER_PASSWORD</code> Password of the first admin user. If <code>FIEF_MAIN_USER_EMAIL</code> is provided, the user will be created automatically on startup with this password. Otherwise, a random password will be generated. SuperSecretAndStrongPassword <code>FIEF_MAIN_ADMIN_API_KEY</code> Admin API token to create at server startup SuperSecretAndStrongToken"},{"location":"self-hosting/environment-variables/#admin-session","title":"Admin session","text":"<p>An admin session is a cookie used to maintain the session of a user on the Fief admin dashboard.</p> Name Description Default Allowed values Example <code>FIEF_ADMIN_SESSION_COOKIE_NAME</code> Name of the admin session cookie fief_admin_session <code>FIEF_ADMIN_SESSION_COOKIE_DOMAIN</code> Domain of the admin session cookie Empty string <code>FIEF_ADMIN_SESSION_COOKIE_SECURE</code> Secure flag of the admin session cookie True <p><code>_COOKIE_SECURE</code> flag should be <code>True</code> in production</p> <p>Browser cookies support the <code>Secure</code> flag, which tells the browser to not forward the cookie if the site is not requested in HTTPS.</p> <p>For your convenience when starting Fief on your local machine, the Quickstart command will set those flags to <code>False</code> for every Fief cookies.</p> <p>However, for security reasons, it's strongly recommended to set those flags to <code>True</code> (the default if not specified) when deploying to production.</p>"},{"location":"self-hosting/environment-variables/#session-data","title":"Session data","text":"<p>The admin session data is a mechanism to store temporary data during the session of a user on the Fief admin dashboard.</p> Name Description Default Allowed values Example <code>SESSION_DATA_COOKIE_NAME</code> Name of the session data cookie fief_session_data <code>SESSION_DATA_COOKIE_DOMAIN</code> Domain of the session data cookie Empty string <code>SESSION_DATA_COOKIE_SECURE</code> Secure flag of the session data cookie True <code>SESSION_DATA_COOKIE_LIFETIME_SECONDS</code> Lifetime of the registration session cookie in seconds <code>None</code> (session cookie) <p><code>_COOKIE_SECURE</code> flag should be <code>True</code> in production</p> <p>Browser cookies support the <code>Secure</code> flag, which tells the browser to not forward the cookie if the site is not requested in HTTPS.</p> <p>For your convenience when starting Fief on your local machine, the Quickstart command will set those flags to <code>False</code> for every Fief cookies.</p> <p>However, for security reasons, it's strongly recommended to set those flags to <code>True</code> (the default if not specified) when deploying to production.</p>"},{"location":"self-hosting/configuration/database/","title":"Database","text":"<p>For production environments, your Fief server should store its data in a proper database server for better performance and reliability. Fief is compatible with PostgreSQL and MySQL databases.</p>"},{"location":"self-hosting/configuration/database/#setup-postgresql","title":"Setup PostgreSQL","text":"<p>We'll assume that you have a working PostgreSQL database running, either locally or in the cloud. All you need to do is to set the corresponding environment variables with your database credentials.</p> <pre><code>DATABASE_TYPE=POSTGRESQL\nDATABASE_HOST=localhost\nDATABASE_PORT=5432\nDATABASE_USERNAME=fief\nDATABASE_PASSWORD=fiefpassword\nDATABASE_NAME=fief\n</code></pre>"},{"location":"self-hosting/configuration/database/#setup-mysql","title":"Setup MySQL","text":"<p>We'll assume that you have a working MySQL database running, either locally or in the cloud. All you need to do is to set the corresponding environment variables with your database credentials.</p> <pre><code>DATABASE_TYPE=MYSQL\nDATABASE_HOST=localhost\nDATABASE_PORT=3306\nDATABASE_USERNAME=fief\nDATABASE_PASSWORD=fiefpassword\nDATABASE_NAME=fief\n</code></pre>"},{"location":"self-hosting/configuration/database/#use-a-connection-string","title":"Use a connection string","text":"<p>Some cloud providers like Heroku will provide you a full database connection string like the one below instead of each parts separately:</p> <pre><code>postgresql://fief:fiefpassword@localhost:5432/fief\n</code></pre> <p>Fief supports this kind of configuration with the <code>DATABASE_URL</code> environment variable.</p> <pre><code>DATABASE_TYPE=POSTGRESQL\nDATABASE_URL=postgresql://fief:fiefpassword@localhost:5432/fief\n</code></pre> <p>Warning</p> <p>This variable will always take precedence over the single parameters: if you define <code>DATABASE_URL</code>, it'll use this variable to connect to your database, even if other parameters are defined.</p>"},{"location":"self-hosting/configuration/email-provider/","title":"Email provider","text":"<p>As you surely now, users management imply a lot of transactional emails, like welcome emails or reset password emails. To be able to send them, Fief needs an email provider.</p> <p>Currently, Fief supports the following providers:</p> <ul> <li>SMTP server.</li> <li>Postmark, one of the leading email delivery service on the market.</li> <li>SendGrid, another highly popular choice for email delivery.</li> </ul> <p>There are two environment variables to configure the email provider: <code>EMAIL_PROVIDER</code>, to set the type of provider and <code>EMAIL_PROVIDER_PARAMS</code>, a configuration dictionary containing required configuration keys.</p>"},{"location":"self-hosting/configuration/email-provider/#null-provider","title":"NULL provider","text":"<p>The NULL provider is the default one if you don't set any. It means that no transactional email will be sent.</p> <pre><code>EMAIL_PROVIDER=NULL\n</code></pre>"},{"location":"self-hosting/configuration/email-provider/#smtp-provider","title":"SMTP provider","text":"<p>SMTP provider will send transactional emails through the configured SMTP server.</p> Parameter Description Default <code>host</code> Hostname of your SMTP server. <code>username</code> Username to authenticate to your SMTP server. <code>None</code> <code>password</code> Password to authenticate to your SMTP server. <code>None</code> <code>port</code> Port of your SMTP server. Typically, <code>25</code>, <code>485</code> or <code>587</code>. <code>587</code> <code>ssl</code> Whether to use SSL/TLS to connect to your SMTP server. <code>True</code> <pre><code>EMAIL_PROVIDER=SMTP\nEMAIL_PROVIDER_PARAMS={\"host\": \"smtp.bretagne.duchy\", \"username\": \"anne\", \"password\": \"herminetincture\"}\n</code></pre>"},{"location":"self-hosting/configuration/email-provider/#postmark-provider","title":"Postmark provider","text":"<p>Postmark provider will send transactional emails using Postmark.</p> Parameter Description Default <code>server_token</code> Your Postmark Server API token. <pre><code>EMAIL_PROVIDER=POSTMARK\nEMAIL_PROVIDER_PARAMS={\"server_token\": \"XXX-XXX\"}\n</code></pre>"},{"location":"self-hosting/configuration/email-provider/#sendgrid-provider","title":"SendGrid provider","text":"<p>SendGrid provider will send transactional emails using SendGrid.</p> Parameter Description Default <code>api_key</code> Your SendGrid API key. <pre><code>EMAIL_PROVIDER=SENDGRID\nEMAIL_PROVIDER_PARAMS={\"api_key\": \"XXX-XXX\"}\n</code></pre>"},{"location":"self-hosting/configuration/ssl/","title":"SSL and HTTPS","text":"<p>When deploying into production, you'll need to configure the Fief server so it correctly works with HTTPS/SSL. Usually, cloud providers or container orchestration tools use a reverse proxy that takes care of the SSL negotiation before handing over to the actual service. That's why our image doesn't come with a built-in mechanism to handle it.</p> <p>However, you'll need to set several environment variables to be sure everything works correctly with HTTPS/SSL.</p>"},{"location":"self-hosting/configuration/ssl/#trust-reverse-proxy-headers","title":"Trust reverse proxy headers","text":"<p>After the reverse proxy handled the HTTPS/SSL connection, it forwards the HTTP request to the underlying server and usually add <code>X-Forwarded-*</code> headers to tell the server it was correctly served over SSL.</p> <p>For security reasons, those headers are ignored by default. You need to tell Fief server to trust those headers if they come from specific IP addresses. To do this, you need to set the <code>FORWARDED_ALLOW_IPS</code> environment variable.</p> <p>This variable expects a comma separated list of IPs to trust. For example:</p> <pre><code>FORWARDED_ALLOW_IPS=10.0.0.2,10.0.0.3\n</code></pre> <p>In some circumstances, like cloud providers, you don't know the IP of the reverse proxy. In this case, you can set this value to <code>*</code> to tell the Fief server to trust any IP.</p> <pre><code>FORWARDED_ALLOW_IPS=*\n</code></pre> <p>Make sure your server is reachable only via the proxy</p> <p>With the value <code>*</code>, it's critical to make sure your Fief server is not reachable directly from the internet, without passing by the proxy. Otherwise, malicious users could make requests with arbitrary <code>X-Forwarded-*</code> headers.</p>"},{"location":"self-hosting/configuration/ssl/#cookie-secure-flags","title":"Cookie Secure flags","text":"<p>By default, all environment variables ending with <code>_COOKIE_SECURE</code> are set to <code>True</code>. Make sure you don't set them to <code>False</code> in production environment.</p>"},{"location":"self-hosting/deployment/docker-compose/","title":"Docker Compose","text":"<p>The quickstart Docker image is an all-in-one container launching the Fief server, the Fief worker for background jobs and a Redis server to schedule those jobs. While suitable for local development and testing, it's usually better in production to have dedicated containers for each purpose.</p> <p>Docker Compose greatly simplifies the configuration of multiple containers. This is probably the easiest way if you already know Docker and want to deploy on your own server. You'll find below a typical <code>docker-compose.yml</code> configuration for Fief.</p> docker-compose.yml.env <pre><code>version: \"3\"\n\nservices:\n  fief-server:\n    image: ghcr.io/fief-dev/fief:latest\n    command: fief run-server\n    env_file:\n      - .env\n    depends_on:\n      - postgres\n      - redis\n    labels:\n      - \"traefik.enable=true\"\n      # Set your domain name here\n      - \"traefik.http.routers.fief.rule=Host(`fief.mydomain.com`)\"\n      - \"traefik.http.routers.fief.entrypoints=websecure\"\n      - \"traefik.http.routers.fief.tls.certresolver=myresolver\"\n\n  fief-worker:\n    image: ghcr.io/fief-dev/fief:latest\n    command: fief run-worker -p 1 -t 1\n    env_file:\n      - .env\n    depends_on:\n      - postgres\n      - redis\n\n  postgres:\n    image: postgres:alpine\n    environment:\n      - POSTGRES_PASSWORD=fief\n      - POSTGRES_USER=fief\n      - POSTGRES_DB=fief\n    volumes:\n      - postgres-data:/var/lib/postgresql/data\n\n  redis:\n    image: redis:alpine\n    command: redis-server --save 60 1 --loglevel warning\n    volumes:\n      - redis-data:/data\n\n  traefik:\n    image: \"traefik:v2.11\"\n    container_name: \"traefik\"\n    command:\n      # Uncomment the lines below to debug and try with a self-signed certificate\n      # - \"--log.level=DEBUG\"\n      # - \"--certificatesresolvers.myresolver.acme.caserver=https://acme-staging-v02.api.letsencrypt.org/directory\"\n      - \"--api.insecure=true\"\n      - \"--providers.docker=true\"\n      - \"--providers.docker.exposedbydefault=false\"\n      - \"--entrypoints.websecure.address=:443\"\n      - \"--certificatesresolvers.myresolver.acme.tlschallenge=true\"\n      # Set your email address here\n      - \"--certificatesresolvers.myresolver.acme.email=admin@mydomain.com\"\n      - \"--certificatesresolvers.myresolver.acme.storage=/letsencrypt/acme.json\"\n    ports:\n      - \"443:443\"\n      - \"8080:8080\"\n    volumes:\n      - \"letsencrypt-data:/letsencrypt\"\n      - \"/var/run/docker.sock:/var/run/docker.sock:ro\"\n\nvolumes:\n  redis-data:\n  postgres-data:\n  letsencrypt-data:\n</code></pre> <pre><code># Reference: https://docs.fief.dev/self-hosting/environment-variables/\n\nSECRET=XXX\nFIEF_CLIENT_ID=XXX\nFIEF_CLIENT_SECRET=XXX\nENCRYPTION_KEY=XXX\nPORT=8000\n# Set your domain name here\nFIEF_DOMAIN=fief.mydomain.com\n# Set your email address here\nFIEF_MAIN_USER_EMAIL=admin@mydomain.com\nFIEF_MAIN_USER_PASSWORD=XXX\n\n# Read more: https://docs.fief.dev/self-hosting/configuration/database/\nDATABASE_TYPE=POSTGRESQL\nDATABASE_HOST=postgres\nDATABASE_PORT=5432\nDATABASE_USERNAME=fief\nDATABASE_PASSWORD=fief\nDATABASE_NAME=fief\n\n# Read more: https://docs.fief.dev/self-hosting/environment-variables/#redis\nREDIS_URL=redis://redis:6379\n\n# Read more: https://docs.fief.dev/self-hosting/configuration/ssl/\nFORWARDED_ALLOW_IPS=*\n</code></pre>"},{"location":"self-hosting/deployment/docker-compose/#fief-containers","title":"Fief containers","text":"<p>We have two Fief containers: one for the web server, <code>fief-server</code>, and one for the worker, <code>fief-worker</code>. Both are required to make Fief working correctly.</p>"},{"location":"self-hosting/deployment/docker-compose/#database-and-redis-containers","title":"Database and Redis containers","text":"<p>We also defined a dedicated database container, PostgreSQL, and a broker for passing job messages, Redis. Note how we defined and linked a volume for both of them. By doing this, we make sure we persist our data in a dedicated Docker volume that will persist even if we delete the containers.</p>"},{"location":"self-hosting/deployment/docker-compose/#traefik-reverse-proxy","title":"Traefik reverse proxy","text":"<p>A reverse proxy is a specialized software able to accept incoming HTTP requests and route them to the underlying applications. It acts as the unique HTTP entrypoint to our system. Here, it'll simply route requests with the domain <code>fief.mydomain.com</code> to the <code>fief-server</code> container.</p> <p>It's also in charge for managing SSL certificates. In this configuration, Traefik will automatically issue a free Let's Encrypt certificate for the domain <code>fief.mydomain.com</code>, using the TLS challenge. Traefik supports other types of challenge that may be more suitable for your use-case. The volume <code>letsencrypt-data</code> is here to store the generated certificates.</p> <p>We strongly suggest you to read more about how to configure Traefik with Docker Compose: https://doc.traefik.io/traefik/user-guides/docker-compose/basic-example/</p>"},{"location":"self-hosting/deployment/docker-compose/#env-file","title":"<code>.env</code> file","text":"<p>The <code>.env</code> file will contain all the environment variables for configuring Fief. You can have more details about the configuration of email provider in the dedicated sections.</p> <p>Configure email provider</p> <p>Backup the volumes</p> <p>You should probably think about a proper backup method for those volumes. A convenient solution is to use <code>docker-volume-backup</code>, a dedicated Docker image capable of archiving Docker volumes and send them to a distant storage.</p>"},{"location":"self-hosting/deployment/railway/","title":"Railway","text":"<p>Railway is a modern is a very popular Platform as a Service (PaaS). It allows to quickly host and serve your applications without worrying about server management.</p> <p>We provide an official template creating all the services you need to run Fief.</p>"},{"location":"self-hosting/deployment/railway/#get-started","title":"Get started","text":"<p>Click on the button below and follow the instructions.</p> <p></p> <p>You'll be prompted to configure two environment varialbles: <code>FIEF_MAIN_USER_EMAIL</code> and <code>FIEF_MAIN_USER_PASSWORD</code>. Those are the credentials of the first admin user that'll be created on server startup.</p> <p></p> <p>After a few minutes, your Fief server will be up-and-running on the default Railway subdomain!</p>"},{"location":"self-hosting/deployment/railway/#custom-domain","title":"Custom domain","text":"<p>By default, the project will be assigned a default Railway subdomain, like <code>server-production-4018.up.railway.app</code>.</p> <p>To add your domain, follow the instructions on Railway documentation: https://docs.railway.app/guides/public-networking#custom-domains</p> <p>Redeploy the server and worker afterwards</p> <p>To make sure Fief correctly takes into account the new domain, it's important to trigger a redeploy on the server and worker process.</p>"},{"location":"self-hosting/deployment/railway/#cost-estimation","title":"Cost estimation","text":"<p>Railway's pricing is based on memory, CPU and network usage. Thus, the pricing will highly vary depending on your workload.</p> <p>We estimate that for a small or medium sized-instance, the cost should be around 10 and 20 USD per month.</p>"},{"location":"self-hosting/deployment/render/","title":"Render","text":"<p>Render is a very popular Platform as a Service (PaaS). It allows to quickly host and serve your applications without worrying about server management.</p> <p>We provide an official blueprint creating all the services you need to run Fief.</p>"},{"location":"self-hosting/deployment/render/#before-starting","title":"Before starting","text":"<ol> <li>If you don't have one yet, create an account on Render.</li> <li>Go to https://dashboard.render.com/env-groups</li> <li>Create a New Environment Group and name it fief (all lowercase)</li> </ol> <p>You can then proceed to the blueprint!</p>"},{"location":"self-hosting/deployment/render/#apply-the-blueprint","title":"Apply the blueprint","text":"<p>We provide variations for each data center locations supported by Fief. The best practice is to choose the one closer to you and your users.</p> <p>Click on the links below to start creating the blueprint in the region of your choice:</p> <p>Deploy to Oregon (US West) Deploy to Ohio (US East) Deploy to Frankfurt (EU) Deploy to Singapore (Asia-Pacific)</p>"},{"location":"self-hosting/deployment/render/#fill-the-environment-variables","title":"Fill the environment variables","text":"<p>We already set most of the environment variables, but you still have to set a few ones.</p> <p>You can find the reference of those values in the environment variables section.</p> <p></p> <p>Encryption key generator</p> <p> Generate key </p> <p>The encryption key should be a valid key for the Fernet encryption algorithm. Use the generator above to get yours! Keep it secret.</p>"},{"location":"self-hosting/deployment/render/#set-the-custom-domain","title":"Set the custom domain","text":"<p>When the deployment is done, you need to link your domain with the <code>fief-server</code> service. Open the Settings of this service and in the Custom Domains section, add your domain.</p> <p></p>"},{"location":"self-hosting/deployment/render/#cost-estimation","title":"Cost estimation","text":"<p>Render bills each service individually. Fief needs four of them:</p> <ul> <li>A server process (starting at 7 USD per month)</li> <li>A worker process (starting at 7 USD per month)</li> <li>A PostgreSQL database (starting at 7 USD per month)</li> <li>A Redis database (starting at 10 USD per month)</li> </ul> <p>For a small or medium sized-instance, the cost should hence be around 31 USD per month.</p>"},{"location":"stronghold/","title":"Stronghold","text":"<p>Fief Stronghold is the private edition of Fief, accessible to our paid backers, which includes exclusive features.</p> <ul> <li> Hide Fief branding on authentication pages</li> <li> Override authentication page templates</li> </ul> <ul> <li> <p>Knight ($5 per month)</p> <p>Unlock premium content with exclusive tutorials and sneak peeks. As a gesture of appreciation, receive majestic stickers to proudly display your allegiance.</p> <ul> <li> Access to Stronghold, the private edition</li> <li> Stickers delivered to your mailbox</li> </ul> <p>Subscribe</p> </li> <li> <p>Baron ($20 per month)</p> <p>Revel in exclusive tutorials, sneak peeks, and command priority email support. Your noble journey includes majestic stickers, ensuring your status as a revered patron of Fief.</p> <ul> <li> Access to Stronghold, the private edition</li> <li> Priority email support</li> <li> Stickers delivered to your mailbox</li> </ul> <p>Subscribe</p> </li> </ul>"},{"location":"stronghold/#usage","title":"Usage","text":"<p>Fief Stronghold is only accessible through the Docker image. Since it's a private repository, you'll need to authenticate your Docker CLI to GitHub Registry.</p> <p>Basically, you'll need to generate a Personal access tokens (classic) on GitHub, with at least the <code>repo</code> and <code>read:packages</code> scopes.</p> <p>Then, you can authenticate your Docker CLI:</p> <pre><code>docker login ghcr.io\n</code></pre> <p>You'll then be prompted for your GitHub Username, and the token you just created as password.</p> <p>Finally, you'll be able to pull the image:</p> <pre><code>docker pull ghcr.io/fief-dev/stronghold:latest\n</code></pre> <p>You can now swap the Fief image by the Stronghold one. Configuration and usage is common.</p>"},{"location":"stronghold/#features","title":"Features","text":""},{"location":"stronghold/#hide-fief-branding","title":"Hide Fief branding","text":"<p>To hide Fief branding on authentication pages, you can set the environment variable <code>BRANDING</code> to <code>False</code>.</p> <pre><code># .env\nBRANDING=False\n</code></pre>"},{"location":"stronghold/#override-authentication-page-templates","title":"Override authentication page templates","text":"<p>If you want to fully customize authentication pages (login, registration, forgot password, etc.), you can override the built-in templates. Fief templates are powered by Jinja, a powerful templating system for Python.</p>"},{"location":"stronghold/#step-1-implement-your-templates","title":"Step 1: implement your templates","text":"<p>We recommend you to start from the built-in templates of Fief and copy them into a local folder. The files you override should have the same name as the original ones and nested in a folder named <code>auth</code>.</p> <p>Here is a simple example of an override of <code>layout.html</code>, which is the base layout for all authentication pages, using the Bootstrap framework.</p> templates/auth/layout.html<pre><code>{% extends \"auth/base.html\" %}\n\n{% block style %}\n&lt;link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css\" rel=\"stylesheet\" integrity=\"sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH\" crossorigin=\"anonymous\"&gt;\n&lt;script src=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js\" integrity=\"sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;\n{% endblock %}\n\n{% block body %}\n&lt;div class=\"px-4 py-5 my-5 text-center\"&gt;\n  {% if tenant.logo_url %}\n    &lt;img src=\"{{ tenant.logo_url }}\" alt=\"{{ tenant.name }}\" class=\"d-block mx-auto mb-4\" /&gt;\n  {% endif %}\n  &lt;h1 class=\"display-5 fw-bold text-body-emphasis\"&gt;{{ tenant.name }}&lt;/h1&gt;\n  &lt;div class=\"col-lg-6 mx-auto\"&gt;\n    {% if error is defined %}\n      &lt;p class=\"text-danger\"&gt;{{error}}&lt;/p&gt;\n    {% endif %}\n    {% if success is defined %}\n    &lt;p class=\"text-success\"&gt;{{success}}&lt;/p&gt;\n    {% endif %}\n    {% if not fatal_error %}\n      {% block auth_form %}\n      {% endblock %}\n    {% endif %}\n  &lt;/div&gt;\n&lt;/div&gt;\n{% endblock %}\n</code></pre>"},{"location":"stronghold/#step-2-adding-your-templates-to-your-docker-build","title":"Step 2: adding your templates to your Docker build","text":"<p>You should now add your templates to your Docker image. For this, create a <code>Dockerfile</code> (if not already) in your project. In its simplest form, it can look like this:</p> Dockerfile<pre><code>FROM ghcr.io/fief-dev/stronghold:latest\n\nCOPY templates /app/templates\nENV OVERRIDE_TEMPLATES_DIRECTORY=/app/templates\n</code></pre> <p>Basically, we start from the base Stronghold image, copy our templates and set the <code>OVERRIDE_TEMPLATES_DIRECTORY</code> environment variable.</p> <p>You don't need to override every files</p> <p>If you just want to override some files but not the others, you can just provide the one you're interested in. If some templates don't exist, Fief will simply fall back to the default ones.</p>"},{"location":"stronghold/#step-3-build-and-run-your-image","title":"Step 3: build and run your image","text":"<p>Now, all you need is to build and run your image to see the result.</p> <pre><code>docker build -t stronghold-templates .\n</code></pre> <p></p>"}]}