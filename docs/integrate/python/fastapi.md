# FastAPI

[FastAPI](https://fastapi.tiangolo.com/) is one of the fastest-growing Python web framework. It features impressive performance and top-notch developer experience. Actually, the Fief server itself is implemented with FastAPI!

The Fief Python client provides tools to help you integrate Fief authentication in your FastAPI project. Let's see how to use them!

## Install the client

Install the Fief client with the optional FastAPI dependencies:

```bash
pip install "fief-client[fastapi]"
```

## API example

!!! question "This is for you if..."
    - [x] Your FastAPI backend will work as a pure REST API.
    - [x] You have a separate frontend, like a JavaScript or mobile app, that'll take care of the OAuth2 flow.


In this first example, we'll leverage the interactive documentation generated by FastAPI to perform the OAuth2 authentication. The goal here is just to show you **how to protect your API route with a Fief access token**.

```py title="app.py"
--8<-- "examples/python/fastapi/api.py"
```

1. **Fief client instantiation**

    As we showed in the [standard Python section](./index.md), we instantiate here a Fief client here with the base tenant URL and client credentials.

    Notice here that we use the `FiefAsync` class. FastAPI being an ASGI framework, it's always nice to take advantage of `asyncio` capabilities.

2. **OpenAPI security scheme**

    FastAPI uses those security schemes to generate an interactive documentation showing the right interface to authenticate with the API. We use here a standard OAuth2 interface.

3. **Fief helper for FastAPI**

    This is the helper doing the tedious work for you with FastAPI. All it needs is an instance of the Fief client and the scheme.

4. **`current_user` dependency**

    This is where the magic happens: in pure FastAPI style, `FiefAuth` gives you a `current_user` dependency to check for the access token and optionally for required scopes.

    If everything goes well, you'll get a dictionary containing the ID of the user, the list of allowed scopes and the raw access token.

And that's about it!

### Test it

You can run this example just like you would do for any FastAPI app:

```bash
uvicorn app:app
```

Open [http://localhost:8000/docs](http://localhost:8000/docs) to access the interactive documentation.

![FastAPI interactive documentation](/assets/images/swagger-index.png)

Let's try first the `/user` endpoint:

![Unauthenticated request from the interactive documentation](/assets/images/swagger-unauthenticated.png)

We get an 401 error! That's expected: **we are not authenticated yet**!

Let's fix that: click on the **Authorize** button to start the authentication process. You'll need to provide your client ID and secret and select the scopes.

![Authorize from interactive documentation](/assets/images/swagger-authorize.png)

Click on the **Authorize** button: you are redirected to the Fief login page.

![Fief login page](/assets/images/fief-login.png)

Upon successful login, you will be redirected back to the interactive documentation: a valid access token has been generated!

![Authenticated interactive documentation](/assets/images/swagger-authenticated.png)

You can now try the `/user` endpoint to check the result:

![Authenticated request from the interactive documentation](/assets/images/swagger-request.png)

Notice how the interactive documentation passed the access token in the `Authorization` header of the request!

Besides, the response does contain the user ID, the list of allowed scopes and the access token itself.

### Checking for scopes

Building on the previous example, you can make your endpoint requires the access token to be granted a list of **scopes**. Simply add this list of scopes as a parameter of the `current_user` dependency.

```py title="app.py" hl_lines="26"
--8<-- "examples/python/fastapi/scope.py"
```

If one of the required scope is missing on the access token, a `403 Forbidden` error will automatically be returned.

## Web application example

!!! question "This is for you if..."
    - [x] Your FastAPI backend will render HTML pages.
    - [x] Your application is intended to be used in a browser.


The examples we showed previously are working well in a pure REST API context: a frontend, like the interactive documentation, a JavaScript application or a mobile app will take care of the OAuth2 authentication flow to retrieve an access token before making request to your API.

Another common context is traditional web application, where the server takes care of generating HTML pages before returning it to the browser. In this case, we'll need some routes to redirect the user to the Fief login page if they're not authenticated and take care of storing the access token somewhere. This is what'll show in this example.

Basically, here's what we'll do:

1. This time, we'll expect the access token to be passed through a traditional **cookie** instead of an HTTP header. Cookies are very convenient when designing web apps because they are handled automatically by the browser.
2. If the cookie is not present, we'll **redirect the user to the Fief login page**. Once again, the browser will help us a lot here since it'll automatically follow the redirection.
3. Upon successful login, Fief will automatically **redirect the user to the callback route**. This callback route will take care of **setting a new cookie containing the access token**. It means that the access token will be safely stored in the browser memory.
4. Finally, the user is redirected back to the protected route. The browser will automatically send the cookie containing the access token: our request is now authenticated!

```py title="app.py"
--8<-- "examples/python/fastapi/web.py"
```

1. **We customize the `FiefAuth` helper to fit our needs**

    The base class is implemented with an API scenario in mind. Nevertheless, it's designed in a way you can customize its behavior when the user is not authenticated or has not the required scope.

    That's what'll do with the `get_unauthorized_response`.

2. **We build the redirect URL**

    This points to our `/auth-callback` route that we define below.

3. **We generate an authorization URL on the Fief server**

    The base class is implemented with an API scenario in mind. Nevertheless, it's designed in a way you can customize its behavior when the user is not authenticated or has not the required scope.

    That's what'll do with the `get_unauthorized_response`.

4. **We build a redirect response**

    By setting a status code in the 3XX range, we tell the browser that it should redirect the user to another URL, specified in the `Location` header.

    You can read more about HTTP redirections on the [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections).

5. **This doesn't change from the previous example**

    The `FiefAsync` client is always at the heart of the integration ðŸ˜‰

6. **We use a scheme expecting a cookie**

    Contrary to the previous examples, we expect the access token to be passed in a cookie. Thus, we use a dedicated scheme for that.

    Notice that we set the name of this cookie through the `SESSION_COOKIE_NAME` constant.

    Besides, we set the `auto_error` argument to `False`. It tells FastAPI user to bypass its built-in error response if the cookie is not present: we have our own logic to handle this.

7. **We use our custom `CustomFiefAuth` class**

    Of course, now that we overloaded the behavior of this helper class, we shouldn't forget to actually use it!

8. **We implement an `/auth-callback` route**

    This is the route that'll take care of exchanging the authorization code with a fresh access token and save it in a cookie.

    Notice that we set its `name` parameter: this is how we can generate its URL automatically with the `request.url_for` method.

9.  **We generate an access token**

    We finish the OAuth2 flow by exchanging the authorization code with a fresh access token.


10. **We build a redirection to the `/protected` route**

    The user will now be correctly authenticated to our web application. Thus, we can redirect them to a protected page.


11. **We build a new cookie containing the access token**

    The response will contain a `Set-Cookie` header instructing the browser to save the access token in its memory. This method allows us to configure each properties of the cookie.

    You can read more about HTTP cookies on the [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies).

12. **Set the cookie as `HTTPOnly`**

    For such sensitive values, it's strongly recommended to set the cookie as `HTTPOnly`. It means that it won't be possible to read its value from JavaScript, reducing potential attacks.

13. **Set the cookie as secure in production**

    For such sensitive values, it's strongly recommended to set the cookie as `Secure`. It tells the browser to send the cookie **only on HTTPS (SSL)** connection, reducing the risk of the access token to be stolen by a attacker between the client and the server.

    However, in a local environment, you usually don't serve your application with SSL. That's why we set it to `False` in this example. A common approach to handle this is to have an environment variable to control this parameter, so you can disable it in local and enable it in production.

14. **Use the `current_user` dependency as usual**

    This doesn't change from the previous example. The dependency will check if the cookie is available in the request and proceed if everything goes well.

    Otherwise, our custom `get_unauthorized_response` will be called and the user will be redirected to the Fief login page.

That's it! If you run this application and go to [http://localhost:8000/protected](http://localhost:8000/protected), you'll be redirected to the Fief login page and experience the authentication flow before getting back to this route with a proper authentication cookie.
