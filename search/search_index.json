{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is Fief? \u00b6 Fief is an open-source platform to manage users and authentication in your applications. Our goal is to help you manage users and security in a matter of minutes, not days. Key features: Pre-built login and registration pages Users management dashboard SDK for the most popular languages and frameworks Integrations for the most popular no-code tools Bring Your Own Database : you can connect to any SQL database so you keep entire control of your data Cloud vs Self-hosted \u00b6 We are offering two ways of using Fief: Cloud : fair-priced hosted instance, maintained by the Fief's team; Self-hosted : you host the service yourself on your own infrastructure, for free. Project roadmap \u00b6 Fief is a young project and still has many features to implement and room for improvements! What we have now? \u00b6 User registration User authentication using OAuth2 and OpenID Connect protocols Forgot password process Bring your own database Official Docker image for self-hosting Official Python client with FastAPI and Flask integrations Official JavaScript client with browser and React integrations Admin dashboard ID Token encryption support PKCE support What we'll have in the future? \u00b6 Roles and permissions model Custom API scopes Custom user fields Customizable transactional emails Social authentication (Google, Facebook...) 2FA authentication with authenticator apps and U2F keys Official NodeJS Express integration Official Bubble integration ...and more \ud83d\ude80 View the project backlog","title":"What is Fief?"},{"location":"#what-is-fief","text":"Fief is an open-source platform to manage users and authentication in your applications. Our goal is to help you manage users and security in a matter of minutes, not days. Key features: Pre-built login and registration pages Users management dashboard SDK for the most popular languages and frameworks Integrations for the most popular no-code tools Bring Your Own Database : you can connect to any SQL database so you keep entire control of your data","title":"What is Fief?"},{"location":"#cloud-vs-self-hosted","text":"We are offering two ways of using Fief: Cloud : fair-priced hosted instance, maintained by the Fief's team; Self-hosted : you host the service yourself on your own infrastructure, for free.","title":"Cloud vs Self-hosted"},{"location":"#project-roadmap","text":"Fief is a young project and still has many features to implement and room for improvements!","title":"Project roadmap"},{"location":"#what-we-have-now","text":"User registration User authentication using OAuth2 and OpenID Connect protocols Forgot password process Bring your own database Official Docker image for self-hosting Official Python client with FastAPI and Flask integrations Official JavaScript client with browser and React integrations Admin dashboard ID Token encryption support PKCE support","title":"What we have now?"},{"location":"#what-well-have-in-the-future","text":"Roles and permissions model Custom API scopes Custom user fields Customizable transactional emails Social authentication (Google, Facebook...) 2FA authentication with authenticator apps and U2F keys Official NodeJS Express integration Official Bubble integration ...and more \ud83d\ude80 View the project backlog","title":"What we'll have in the future?"},{"location":"getting-started/admin-dashboard/","text":"Admin dashboard \u00b6 The admin dashboard is the interface where you'll be able to manage your Fief workspace and configuration. The left menu lets you access to the most important aspects of Fief: Tenants Clients Users API Keys Switch workspace \u00b6 If your account is linked to several workspaces, you can switch to another workspace using the menu on the top-right.","title":"Admin dashboard"},{"location":"getting-started/admin-dashboard/#admin-dashboard","text":"The admin dashboard is the interface where you'll be able to manage your Fief workspace and configuration. The left menu lets you access to the most important aspects of Fief: Tenants Clients Users API Keys","title":"Admin dashboard"},{"location":"getting-started/admin-dashboard/#switch-workspace","text":"If your account is linked to several workspaces, you can switch to another workspace using the menu on the top-right.","title":"Switch workspace"},{"location":"getting-started/api-keys/","text":"API Keys \u00b6 This is where you'll see and manage the api keys of your workspace. What is an API key? An API key is a secret token that'll allow you to make authenticated requests to the Fief Admin API . It'll be useful if you need, for example, to manage tenants or clients programmatically from your own application. Keep it secret and safe An API key gives complete accesss to your workspace data. Keep it somewhere safe and don't share it with anyone. Create a new API Key \u00b6 To create a new API Key, click on the Create API Key button. A modal will open where you'll be able to input the name of the API Key. Choose a name that'll help you remember where and how it's used. When you submit the form, a new modal will open with the actual API key token . For security reasons, it'll be shown only once . Copy and paste it somewhere safe before closing the modal. Delete an API Key \u00b6 If one of your API Key is not useful anymore, you can delete it by clicking on the Delete button in the list.","title":"API Keys"},{"location":"getting-started/api-keys/#api-keys","text":"This is where you'll see and manage the api keys of your workspace. What is an API key? An API key is a secret token that'll allow you to make authenticated requests to the Fief Admin API . It'll be useful if you need, for example, to manage tenants or clients programmatically from your own application. Keep it secret and safe An API key gives complete accesss to your workspace data. Keep it somewhere safe and don't share it with anyone.","title":"API Keys"},{"location":"getting-started/api-keys/#create-a-new-api-key","text":"To create a new API Key, click on the Create API Key button. A modal will open where you'll be able to input the name of the API Key. Choose a name that'll help you remember where and how it's used. When you submit the form, a new modal will open with the actual API key token . For security reasons, it'll be shown only once . Copy and paste it somewhere safe before closing the modal.","title":"Create a new API Key"},{"location":"getting-started/api-keys/#delete-an-api-key","text":"If one of your API Key is not useful anymore, you can delete it by clicking on the Delete button in the list.","title":"Delete an API Key"},{"location":"getting-started/clients/","text":"Clients \u00b6 This is where you'll see and manage the clients of your workspace. What is a client? A client is a central part of the OAuth2 protocol. It's the definition of an application authorized to request for access tokens and user information on Fief. In other words, your application will need one of those client to be able to authenticate users from your Fief workspace. Each client has a Client ID and a Client Secret. Those values are used during OAuth2 authentification to recognize the client. Each workspace comes with one client, tied to the default tenant . View client details \u00b6 If you click on one of the client in the list, you'll see its details on the right. Especially, you'll be able to copy its ID and Secret by using the clipboard buttons. Create a new client \u00b6 You can create a new client by clicking the Create Client button. A modal will open where you'll be able to input its name, if it's a first-party, its type, its redirect URIs and its associated tenant. When should I create a new client? If you have several applications authenticating to your Fief workspace, you should consider creating new clients. Typically, if you have both a web and a mobile application, it's usually a good idea to have a client for each one. This way, it's easier to track down where the tokens come from and mitigates the risk of compromising data if one of the application has a security breach. Edit an existing client \u00b6 You can edit an existing client by opening its details and click on the Edit Client button. A modal will open where you'll be able to change its name, if it's a first-party its type and its redirect URIs. First-party clients \u00b6 You probably noticed that your first client has a first-party badge. It means that this client is intended to be used by your own, official application. In this context, when users log in to your application, the traditional OAuth2 consent screen is bypassed . Since you are the developer of the application, it makes sense to not ask the user for their consent to use their data on the same application! For third-party applications, like developers from another company who want to integrate your API in their product, you'll provide them a client without this first-party flag. In this context, we want the user consent to be explicit. Client type \u00b6 OAuth2 protocol defines two types of clients, depending on the context they will be used. Confidential : clients where we can guarantee the safety of the client secret . It's suitable for server-based applications like Python or NodeJS web applications. Public : clients where the client secret would be exposed to the end-user. It's the case for browser-based JavaScript applications and mobile applications. Public clients \u00b6 For public clients, we consider that the client secret can never be safe. It's indeed fairly easy to find it in the JavaScript source code or in the application package. Therefore, it's recommended to not use it at all in your application . Fief will allow public clients to make token request without the client secret . However, it'll require a PKCE challenge for maximum security. Redirect URIs \u00b6 During an OAuth2 authentication flow , after the user has successfully logged in, Fief will redirect them to your application with a temporary code. At that point, your application will use this temporary code to obtain a valid token. For security reasons, Fief won't allow the user to be redirected to any URI . Instead, you have to explicitly allow every URI you'll need in your applications. For HTTP URIs, they need to use the https scheme; http URL are not allowed. The only exception to this rule is localhost , which can be in http for local development purposes.","title":"Clients"},{"location":"getting-started/clients/#clients","text":"This is where you'll see and manage the clients of your workspace. What is a client? A client is a central part of the OAuth2 protocol. It's the definition of an application authorized to request for access tokens and user information on Fief. In other words, your application will need one of those client to be able to authenticate users from your Fief workspace. Each client has a Client ID and a Client Secret. Those values are used during OAuth2 authentification to recognize the client. Each workspace comes with one client, tied to the default tenant .","title":"Clients"},{"location":"getting-started/clients/#view-client-details","text":"If you click on one of the client in the list, you'll see its details on the right. Especially, you'll be able to copy its ID and Secret by using the clipboard buttons.","title":"View client details"},{"location":"getting-started/clients/#create-a-new-client","text":"You can create a new client by clicking the Create Client button. A modal will open where you'll be able to input its name, if it's a first-party, its type, its redirect URIs and its associated tenant. When should I create a new client? If you have several applications authenticating to your Fief workspace, you should consider creating new clients. Typically, if you have both a web and a mobile application, it's usually a good idea to have a client for each one. This way, it's easier to track down where the tokens come from and mitigates the risk of compromising data if one of the application has a security breach.","title":"Create a new client"},{"location":"getting-started/clients/#edit-an-existing-client","text":"You can edit an existing client by opening its details and click on the Edit Client button. A modal will open where you'll be able to change its name, if it's a first-party its type and its redirect URIs.","title":"Edit an existing client"},{"location":"getting-started/clients/#first-party-clients","text":"You probably noticed that your first client has a first-party badge. It means that this client is intended to be used by your own, official application. In this context, when users log in to your application, the traditional OAuth2 consent screen is bypassed . Since you are the developer of the application, it makes sense to not ask the user for their consent to use their data on the same application! For third-party applications, like developers from another company who want to integrate your API in their product, you'll provide them a client without this first-party flag. In this context, we want the user consent to be explicit.","title":"First-party clients"},{"location":"getting-started/clients/#client-type","text":"OAuth2 protocol defines two types of clients, depending on the context they will be used. Confidential : clients where we can guarantee the safety of the client secret . It's suitable for server-based applications like Python or NodeJS web applications. Public : clients where the client secret would be exposed to the end-user. It's the case for browser-based JavaScript applications and mobile applications.","title":"Client type"},{"location":"getting-started/clients/#public-clients","text":"For public clients, we consider that the client secret can never be safe. It's indeed fairly easy to find it in the JavaScript source code or in the application package. Therefore, it's recommended to not use it at all in your application . Fief will allow public clients to make token request without the client secret . However, it'll require a PKCE challenge for maximum security.","title":"Public clients"},{"location":"getting-started/clients/#redirect-uris","text":"During an OAuth2 authentication flow , after the user has successfully logged in, Fief will redirect them to your application with a temporary code. At that point, your application will use this temporary code to obtain a valid token. For security reasons, Fief won't allow the user to be redirected to any URI . Instead, you have to explicitly allow every URI you'll need in your applications. For HTTP URIs, they need to use the https scheme; http URL are not allowed. The only exception to this rule is localhost , which can be in http for local development purposes.","title":"Redirect URIs"},{"location":"getting-started/introduction/","text":"Introduction \u00b6 Fief is what is usually called an identity provider : it provides and secures user identities to external apps. To allow this, Fief implements the OpenID Connect protocol, an identity layer on top of the well-known OAuth2 protocol . Basically, it describes a secure way for a user to give access to its data to an external app. So, how does everything will fit together? In a nutshell, Fief will store everything about your users data (email address, hashed passwords...) and give you a simple way to authenticate them in your application. graph TD U((User)) A{Your application} subgraph FIEF [Fief] F[Fief API] FL[Login page] FD[(Fief database)] end U -- is not authenticated ----> FL U -- is authenticated ----> A A -- checks user identity on --> F FL -. redirects to .-> A F -- stores users on --> FD Let's get started! \u00b6 The first thing to do is to create your workspace!","title":"Introduction"},{"location":"getting-started/introduction/#introduction","text":"Fief is what is usually called an identity provider : it provides and secures user identities to external apps. To allow this, Fief implements the OpenID Connect protocol, an identity layer on top of the well-known OAuth2 protocol . Basically, it describes a secure way for a user to give access to its data to an external app. So, how does everything will fit together? In a nutshell, Fief will store everything about your users data (email address, hashed passwords...) and give you a simple way to authenticate them in your application. graph TD U((User)) A{Your application} subgraph FIEF [Fief] F[Fief API] FL[Login page] FD[(Fief database)] end U -- is not authenticated ----> FL U -- is authenticated ----> A A -- checks user identity on --> F FL -. redirects to .-> A F -- stores users on --> FD","title":"Introduction"},{"location":"getting-started/introduction/#lets-get-started","text":"The first thing to do is to create your workspace!","title":"Let's get started!"},{"location":"getting-started/oauth2/","text":"Understand OAuth2 \u00b6 Fief uses the OpenID Connect protocol, an identity layer on top of the well-known OAuth2 protocol to securely authenticate users . If you understand the basics of this protocol, you'll better understand how to integrate Fief to your own application. You probably already used OAuth2 before: whenever you use a button like Sign In with Google or Sign In with Facebook on a website, you actually authenticate yourself using the OAuth2 protocol! Authentication flow \u00b6 Schematically, a complete OAuth2 flow looks like this: sequenceDiagram actor U as User participant A as Your app participant F as Fief U->>A: Wants to login A->>U: Redirects to Fief login page U->>F: Authenticates on Fief F->>A: Redirects with a temporary code A->>F: Exchanges the temporary code F->>A: Generates a valid token A->>U: Answers with a valid session You see that we have three actors in this flow: The user Your application that needs to know the authenticated user Fief , which is able to authenticate users and provide their information This flow relies a lot on redirections: The user first tries to access your application. If they're not logged in, they are redirected to the Fief login page. On this login page, the user will input its credentials, typically an email address and a password to authenticate themself. At this point, we don't have a valid user session yet . In traditional applications, after a successful login, we do obtain a valid user session. However, in this context, the application needing the user session, your application, is not the same as the one that provides authentication, Fief. That's why we have an additional step: Fief redirects to your application with a temporary code, called the authorization code . This code is then used by your application to call the Fief API and obtain a valid token in exchange. Finally, your application can save this token somewhere to maintain the user session. The benefit of this approach is that your application never has access to the user credentials: the sensitive and difficult part is handled by Fief. There are other OAuth2 variants OAuth2 proposes several ways to achieve this kind of authentication flow. We showed here the authorization code grant , which is the most widely-used and the default in Fief. Scopes \u00b6 A central part in OAuth2 is the concept of scopes . Basically, it determines what the application will be able to do or not with the user data. For the user, this translates to the famous consent screen : it's a special page after a successful login telling them what the application wants to do with their data. Once the access token is generated, it'll be tied to this specific list of scopes the user has granted. In your application, you'll be able to limit some actions based on those scopes. As we said in introduction, we use the OpenID Connect protocol on top of OAuth2. With this protocol, we always have at least one scope, openid . It's a core scope giving access to the basic information of the user. First-party clients Since you'll use Fief to authenticate users on your own, official application, we introduced the concept of first-party clients. When a user logs in on a client configured as first-party, the consent screen is bypassed and every scopes asked are implicitly granted. You can read more about this in the dedicated section . Limitations In the future, you'll be able to create your own set of scopes in Fief. Access Token and ID Token \u00b6 After a successful authentication flow, your application will get two different tokens: an access token and an ID token . The first one, the access token , is a secret value that'll authenticate the user on your application. It's tied to a specific user and a list of scopes. On the other hand, the ID token is a value containing all the basic information about the authenticated user, like its email and other personal information. It'll be very useful in your application if you need for example to display the email of the current user. For security reasons, both of them have a limited lifetime . At some point, we'll need to make another OAuth2 authentication flow again to retrieve fresh tokens. Those are JWT The access token and the ID token are both generated as JSON Web Tokens (JWT). JWT is a widely-used standard to secure data contained in a standard JSON object. Typically, JWT are cryptographically signed . It means that your application is able to certify that the tokens you get are true and authentic tokens generated by Fief, and not forged by a malicious attacker. This is critical since we use those to authenticate users into your app. The technical details around this are a bit complex but you can read more about on the official JWT documentation .","title":"Understand OAuth2"},{"location":"getting-started/oauth2/#understand-oauth2","text":"Fief uses the OpenID Connect protocol, an identity layer on top of the well-known OAuth2 protocol to securely authenticate users . If you understand the basics of this protocol, you'll better understand how to integrate Fief to your own application. You probably already used OAuth2 before: whenever you use a button like Sign In with Google or Sign In with Facebook on a website, you actually authenticate yourself using the OAuth2 protocol!","title":"Understand OAuth2"},{"location":"getting-started/oauth2/#authentication-flow","text":"Schematically, a complete OAuth2 flow looks like this: sequenceDiagram actor U as User participant A as Your app participant F as Fief U->>A: Wants to login A->>U: Redirects to Fief login page U->>F: Authenticates on Fief F->>A: Redirects with a temporary code A->>F: Exchanges the temporary code F->>A: Generates a valid token A->>U: Answers with a valid session You see that we have three actors in this flow: The user Your application that needs to know the authenticated user Fief , which is able to authenticate users and provide their information This flow relies a lot on redirections: The user first tries to access your application. If they're not logged in, they are redirected to the Fief login page. On this login page, the user will input its credentials, typically an email address and a password to authenticate themself. At this point, we don't have a valid user session yet . In traditional applications, after a successful login, we do obtain a valid user session. However, in this context, the application needing the user session, your application, is not the same as the one that provides authentication, Fief. That's why we have an additional step: Fief redirects to your application with a temporary code, called the authorization code . This code is then used by your application to call the Fief API and obtain a valid token in exchange. Finally, your application can save this token somewhere to maintain the user session. The benefit of this approach is that your application never has access to the user credentials: the sensitive and difficult part is handled by Fief. There are other OAuth2 variants OAuth2 proposes several ways to achieve this kind of authentication flow. We showed here the authorization code grant , which is the most widely-used and the default in Fief.","title":"Authentication flow"},{"location":"getting-started/oauth2/#scopes","text":"A central part in OAuth2 is the concept of scopes . Basically, it determines what the application will be able to do or not with the user data. For the user, this translates to the famous consent screen : it's a special page after a successful login telling them what the application wants to do with their data. Once the access token is generated, it'll be tied to this specific list of scopes the user has granted. In your application, you'll be able to limit some actions based on those scopes. As we said in introduction, we use the OpenID Connect protocol on top of OAuth2. With this protocol, we always have at least one scope, openid . It's a core scope giving access to the basic information of the user. First-party clients Since you'll use Fief to authenticate users on your own, official application, we introduced the concept of first-party clients. When a user logs in on a client configured as first-party, the consent screen is bypassed and every scopes asked are implicitly granted. You can read more about this in the dedicated section . Limitations In the future, you'll be able to create your own set of scopes in Fief.","title":"Scopes"},{"location":"getting-started/oauth2/#access-token-and-id-token","text":"After a successful authentication flow, your application will get two different tokens: an access token and an ID token . The first one, the access token , is a secret value that'll authenticate the user on your application. It's tied to a specific user and a list of scopes. On the other hand, the ID token is a value containing all the basic information about the authenticated user, like its email and other personal information. It'll be very useful in your application if you need for example to display the email of the current user. For security reasons, both of them have a limited lifetime . At some point, we'll need to make another OAuth2 authentication flow again to retrieve fresh tokens. Those are JWT The access token and the ID token are both generated as JSON Web Tokens (JWT). JWT is a widely-used standard to secure data contained in a standard JSON object. Typically, JWT are cryptographically signed . It means that your application is able to certify that the tokens you get are true and authentic tokens generated by Fief, and not forged by a malicious attacker. This is critical since we use those to authenticate users into your app. The technical details around this are a bit complex but you can read more about on the official JWT documentation .","title":"Access Token and ID Token"},{"location":"getting-started/tenants/","text":"Tenants \u00b6 This is where you'll see and manage the tenants of your workspace. What is a tenant? A tenant is a sub-division of your workspace. Each client and user is tied to a specific tenant. This is mostly useful if you want to create a product sold in white-label where each of your client has its own space. It allows for example for a user to have several accounts with the same email address inside one workspace, but actually tied to different tenants. From a user point-of-view, this is a different application on which they login with different credentials. If you don't plan to do this, that's okay: you'll always use a single tenant in your workspace. Each workspace has at least one default tenant. Base URL \u00b6 Each tenant is tied to a base URL : each routes, like login or registration, will be derived from this base. When you integrate Fief in your application, you'll need this base URL. Each workspace has one default tenant with a base URL pointing to your root subdomain, like https://example.fief.dev . Other tenants gets a path prefix, like https://example.fief.dev/other-tenant . Tip You can copy the base URL directly using the clipboard button in the list. Limitation At the moment, new tenants can't be created from the admin dashboard.","title":"Tenants"},{"location":"getting-started/tenants/#tenants","text":"This is where you'll see and manage the tenants of your workspace. What is a tenant? A tenant is a sub-division of your workspace. Each client and user is tied to a specific tenant. This is mostly useful if you want to create a product sold in white-label where each of your client has its own space. It allows for example for a user to have several accounts with the same email address inside one workspace, but actually tied to different tenants. From a user point-of-view, this is a different application on which they login with different credentials. If you don't plan to do this, that's okay: you'll always use a single tenant in your workspace. Each workspace has at least one default tenant.","title":"Tenants"},{"location":"getting-started/tenants/#base-url","text":"Each tenant is tied to a base URL : each routes, like login or registration, will be derived from this base. When you integrate Fief in your application, you'll need this base URL. Each workspace has one default tenant with a base URL pointing to your root subdomain, like https://example.fief.dev . Other tenants gets a path prefix, like https://example.fief.dev/other-tenant . Tip You can copy the base URL directly using the clipboard button in the list. Limitation At the moment, new tenants can't be created from the admin dashboard.","title":"Base URL"},{"location":"getting-started/users/","text":"Users \u00b6 This is where you'll see and manage the users of your workspace. What is a user? A user is the fundamental part of your Fief workspace: it represents the actual user that'll have access to your application! We store basic information about the user, like its email address and hashed password and take care of verifying its credentials upon login. Every user is tied to a tenant . It means that an individual can have several user accounts on your workspace, with the same email address, but tied to a different tenant. Create a new user \u00b6 In some circumstances, you might need to create a user manually from the admin dashboard. You can do so by clicking on the Create User button. A modal will open where you'll be able to input its email address, password and associated tenant. Info User created that way will receive the welcome email, as if they registered themselves.","title":"Users"},{"location":"getting-started/users/#users","text":"This is where you'll see and manage the users of your workspace. What is a user? A user is the fundamental part of your Fief workspace: it represents the actual user that'll have access to your application! We store basic information about the user, like its email address and hashed password and take care of verifying its credentials upon login. Every user is tied to a tenant . It means that an individual can have several user accounts on your workspace, with the same email address, but tied to a different tenant.","title":"Users"},{"location":"getting-started/users/#create-a-new-user","text":"In some circumstances, you might need to create a user manually from the admin dashboard. You can do so by clicking on the Create User button. A modal will open where you'll be able to input its email address, password and associated tenant. Info User created that way will receive the welcome email, as if they registered themselves.","title":"Create a new user"},{"location":"getting-started/workspace/","text":"Create your workspace \u00b6 The easiest way to get started is to create your workspace on our official Fief instance . After having created your user account, you'll be guided through the creation of your workspace . What is a workspace? A workspace is a place where all your Fief data lives: configuration, users data, etc. Each workspace has its own subdomain reserved for you, like https://example.fief.dev . If you are working on several projects or companies, we recommend to create several workspaces to keep things organized. Step 1: name your workspace \u00b6 The first step is to name your workspace. Use a name describing your application or company: it'll be used to generate your workspace subdomain. For example, a workspace named Bretagne Duchy will be assigned to the subdomain https://bretagne-duchy.fief.dev . Step 2: select your type of database \u00b6 One of the great strength of Fief is that you can bring your own database to store your workspace data. This way, you keep in total control of your data. Of course, we also propose you to store your data on our performand and secure cloud database. Your choice! At this step, you can make the choice between the Fief cloud database or configure your own. For the sake of simplicity, we'll choose here the cloud database . If you want to bring your own database, we recommend you to read the dedicated section . Ready to go! \u00b6 That's it! At this point, everything is ready to create your workspace! After that, you'll be redirected to your admin dashboard, where you'll be able to manage your workspace.","title":"Create your workspace"},{"location":"getting-started/workspace/#create-your-workspace","text":"The easiest way to get started is to create your workspace on our official Fief instance . After having created your user account, you'll be guided through the creation of your workspace . What is a workspace? A workspace is a place where all your Fief data lives: configuration, users data, etc. Each workspace has its own subdomain reserved for you, like https://example.fief.dev . If you are working on several projects or companies, we recommend to create several workspaces to keep things organized.","title":"Create your workspace"},{"location":"getting-started/workspace/#step-1-name-your-workspace","text":"The first step is to name your workspace. Use a name describing your application or company: it'll be used to generate your workspace subdomain. For example, a workspace named Bretagne Duchy will be assigned to the subdomain https://bretagne-duchy.fief.dev .","title":"Step 1: name your workspace"},{"location":"getting-started/workspace/#step-2-select-your-type-of-database","text":"One of the great strength of Fief is that you can bring your own database to store your workspace data. This way, you keep in total control of your data. Of course, we also propose you to store your data on our performand and secure cloud database. Your choice! At this step, you can make the choice between the Fief cloud database or configure your own. For the sake of simplicity, we'll choose here the cloud database . If you want to bring your own database, we recommend you to read the dedicated section .","title":"Step 2: select your type of database"},{"location":"getting-started/workspace/#ready-to-go","text":"That's it! At this point, everything is ready to create your workspace! After that, you'll be redirected to your admin dashboard, where you'll be able to manage your workspace.","title":"Ready to go!"},{"location":"going-further/byod/","text":"Bring your own database \u00b6 This is one of the most iconic feature of Fief. \"Bring your own database\" allows you to configure your very own SQL database , hosted anywhere you want, and let Fief stores all your data into it. This is especially useful if you have special requirements about where and how your data should be stored. Then, Fief will execute its logic by reading and writing data to your database, and nowhere else. I want to host everything myself! If you don't want to use our cloud instance at all, you can also host the entire Fief server on your own! You can find detailed instructions here . Setup your database \u00b6 You can configure your database during the creation of your workspace . At step 2, select the option My own database . Then, you'll need to enter the details about your database. Database type : you have the choice between a PostgreSQL and MySQL database. Host Port Username Password Database name Credentials are encrypted on Fief To protect your database credentials, we encrypt them using the Fernet method . It means that even if a malicious individual achieves to access our systems, they couldn't steal your credentials. After this step, we'll try to connect to your database and create the schema Fief needs to work. You'll then be redirected to your admin dashboard, where you'll be able to manage your workspace. How Fief uses your database? \u00b6 Schema \u00b6 Fief won't directly use the database instance you provide. Instead, it'll create another dedicated schema . For PostgreSQL servers, it'll create a schema , which could be more or less described as a \"sub-database\". For MySQL servers, it'll create another database instance. Migrations \u00b6 Fief maintain a migration table in your database to keep track of changes to the tables schema. When we deploy updates to Fief that needs to add or modify tables, we'll automatically apply migrations on your database. Don't edit data yourself! \u00b6 When you have access to the database, it might be tempting to manually add or modify data. DON'T DO THIS . If you make a mistake, you'll probably break your whole Fief workspace and your users won't be able to authenticate anymore. If you really need to make a special operation on your data, please ask us first , we'll help you to do it safely.","title":"Bring your own database"},{"location":"going-further/byod/#bring-your-own-database","text":"This is one of the most iconic feature of Fief. \"Bring your own database\" allows you to configure your very own SQL database , hosted anywhere you want, and let Fief stores all your data into it. This is especially useful if you have special requirements about where and how your data should be stored. Then, Fief will execute its logic by reading and writing data to your database, and nowhere else. I want to host everything myself! If you don't want to use our cloud instance at all, you can also host the entire Fief server on your own! You can find detailed instructions here .","title":"Bring your own database"},{"location":"going-further/byod/#setup-your-database","text":"You can configure your database during the creation of your workspace . At step 2, select the option My own database . Then, you'll need to enter the details about your database. Database type : you have the choice between a PostgreSQL and MySQL database. Host Port Username Password Database name Credentials are encrypted on Fief To protect your database credentials, we encrypt them using the Fernet method . It means that even if a malicious individual achieves to access our systems, they couldn't steal your credentials. After this step, we'll try to connect to your database and create the schema Fief needs to work. You'll then be redirected to your admin dashboard, where you'll be able to manage your workspace.","title":"Setup your database"},{"location":"going-further/byod/#how-fief-uses-your-database","text":"","title":"How Fief uses your database?"},{"location":"going-further/byod/#schema","text":"Fief won't directly use the database instance you provide. Instead, it'll create another dedicated schema . For PostgreSQL servers, it'll create a schema , which could be more or less described as a \"sub-database\". For MySQL servers, it'll create another database instance.","title":"Schema"},{"location":"going-further/byod/#migrations","text":"Fief maintain a migration table in your database to keep track of changes to the tables schema. When we deploy updates to Fief that needs to add or modify tables, we'll automatically apply migrations on your database.","title":"Migrations"},{"location":"going-further/byod/#dont-edit-data-yourself","text":"When you have access to the database, it might be tempting to manually add or modify data. DON'T DO THIS . If you make a mistake, you'll probably break your whole Fief workspace and your users won't be able to authenticate anymore. If you really need to make a special operation on your data, please ask us first , we'll help you to do it safely.","title":"Don't edit data yourself!"},{"location":"going-further/id-token-encryption/","text":"ID Token encryption \u00b6 Work in progress \ud83d\udc77","title":"ID Token encryption"},{"location":"going-further/id-token-encryption/#id-token-encryption","text":"Work in progress \ud83d\udc77","title":"ID Token encryption"},{"location":"going-further/pkce/","text":"PKCE \u00b6 Work in progress \ud83d\udc77","title":"PKCE"},{"location":"going-further/pkce/#pkce","text":"Work in progress \ud83d\udc77","title":"PKCE"},{"location":"integrate/javascript/","text":"JavaScript \u00b6 We provide an official client for JavaScript. You can install it with npm : npm install @fief/fief Create a Fief client \u00b6 The Fief client provides all the necessary methods to manage OAuth2 authentication, validate access tokens and refresh them. const fief = new Fief ({ baseURL : 'https://example.fief.dev' , // (1)! clientId : 'YOUR_CLIENT_ID' , // (2)! clientSecret : 'YOUR_CLIENT_SECRET' , // (3)! }); Base URL of your Fief tenant You can find it in the admin dashboard, in the Tenants list. More info ID of your Fief client You can find it in the admin dashboard, in the Clients list. More info Info A first client is always created for you when you create your workspace. When getting started, you should use this one. Secret of your Fief client You can find it in the admin dashboard, in the Clients list. More info Info A first client is always created for you when you create your workspace. When getting started, you should use this one. Client secret is not safe in browser-based applications If you build a browser-based application in JavaScript, the Client Secret is not safe: the end-user can easily find it in the source code. To circumvent this, Fief allows to omit the client secret for clients with the public type . However, a PKCE code challenge will be required during the authorization flow. What's next? \u00b6 JavaScript being a vast ecosystem both for browsers and servers, integration paths can be quite different following your use-case. To help you further, we provide you helpers and examples for popular JavaScript frameworks and technologies, like React. Integrate in browser with plain JavaScript Integrate with React Fief reference \u00b6 Constructor baseURL: string : Base URL of your Fief tenant. clientID: string : ID of your Fief client. clientSecret: string | undefined : Secret of your Fief client. It's not recommended to use it in the context of a browser app, since it can be easily found by the end-user in the source code. The recommended way is to use a Public client . encryptionKey: string | undefined : Encryption key of your Fief client. Necessary only if ID Token encryption is enabled. getAuthURL \u00b6 Returns an authorization URL. Parameters redirectURI: string : Your callback URI where the user will be redirected after Fief authentication. state: string | undefined : Optional string that will be returned back in the callback parameters to allow you to retrieve state information. scope: string[] | undefined : Optional list of scopes to ask for. codeChallenge: string | undefined : Optional code challenge for PKCE process . codeChallengeMethod: 'plain' | 'S256' | undefined : Method used to hash the PKCE code challenge. extras_params: Record<string, string> | undefined : Optional object containing specific parameters. Example const authURL = await fief . getAuthURL ({ redirectURI : 'http://localhost:8000/callback' , scope : [ 'openid' ], ); authCallback \u00b6 Returns valid tokens and user info in exchange of an authorization code. Parameters code: string : The authorization code. redirectURI: string : The exact same redirectURI you passed to the authorization URL. codeVerifier: string | undefined : The raw PCKE code used to generate the code challenge during authorization. Example const [ tokens , userinfo ] = await fief . authCallback ( 'CODE' , 'http://localhost:8000/callback' ); authRefreshToken \u00b6 Returns fresh tokens and user info in exchange of a refresh token. Parameters refresh_token: string : A valid refresh token. scope: string[] | undefined : Optional list of scopes to ask for. If not provided, the access token will share the same list of scopes as requested the first time. Otherwise, it should be a subset of the original list of scopes. Example const [ tokens , userinfo ] = await fief . authRefreshToken ( 'REFRESH_TOKEN' ); validateAccessToken \u00b6 Checks if an access token is valid and optionally that it has a required list of scopes. Parameters accessToken: string : The access token to validate. requireScopes: string[] | undefined : Optional list of scopes to check for. Example import { FiefAccessTokenExpired , FiefAccessTokenInvalid , FiefAccessTokenMissingScope } from '@fief/fief' ; try { accessTokenInfo = await fief . validateAccessToken ( 'ACCESS_TOKEN' , required_scope = [ 'required_scope' ]); console . log ( accessTokenInfo ); // {\"id\": \"USER_ID\", \"scope\": [\"openid\", \"required_scope\"], \"access_token\": \"ACCESS_TOKEN\"} } catch ( err ) { if ( err instanceof FiefAccessTokenInvalid ) { console . error ( 'Invalid access token' ); } else if ( err instanceof FiefAccessTokenExpired ) { console . error ( 'Expired access token' ); } else if ( err instanceof FiefAccessTokenMissingScope ) { console . error ( 'Missing required scope' ); } } userinfo \u00b6 Returns fresh user information from the Fief API using a valid access token. Parameters accessToken: string : A valid access token Example userinfo = await fief . userinfo ( 'ACCESS_TOKEN' ); getLogoutURL \u00b6 Returns a logout URL. If you redirect the user to this page, Fief will clear the session stored on its side. You're still responsible for clearing your own session mechanism if any. Parameters redirectURI: string : A valid URL where the user will be redirected after the logout process. Example const logoutURL = await fief . getLogoutURL ({ redirectURI : 'http://localhost:8000' , });","title":"JavaScript"},{"location":"integrate/javascript/#javascript","text":"We provide an official client for JavaScript. You can install it with npm : npm install @fief/fief","title":"JavaScript"},{"location":"integrate/javascript/#create-a-fief-client","text":"The Fief client provides all the necessary methods to manage OAuth2 authentication, validate access tokens and refresh them. const fief = new Fief ({ baseURL : 'https://example.fief.dev' , // (1)! clientId : 'YOUR_CLIENT_ID' , // (2)! clientSecret : 'YOUR_CLIENT_SECRET' , // (3)! }); Base URL of your Fief tenant You can find it in the admin dashboard, in the Tenants list. More info ID of your Fief client You can find it in the admin dashboard, in the Clients list. More info Info A first client is always created for you when you create your workspace. When getting started, you should use this one. Secret of your Fief client You can find it in the admin dashboard, in the Clients list. More info Info A first client is always created for you when you create your workspace. When getting started, you should use this one. Client secret is not safe in browser-based applications If you build a browser-based application in JavaScript, the Client Secret is not safe: the end-user can easily find it in the source code. To circumvent this, Fief allows to omit the client secret for clients with the public type . However, a PKCE code challenge will be required during the authorization flow.","title":"Create a Fief client"},{"location":"integrate/javascript/#whats-next","text":"JavaScript being a vast ecosystem both for browsers and servers, integration paths can be quite different following your use-case. To help you further, we provide you helpers and examples for popular JavaScript frameworks and technologies, like React. Integrate in browser with plain JavaScript Integrate with React","title":"What's next?"},{"location":"integrate/javascript/#fief-reference","text":"Constructor baseURL: string : Base URL of your Fief tenant. clientID: string : ID of your Fief client. clientSecret: string | undefined : Secret of your Fief client. It's not recommended to use it in the context of a browser app, since it can be easily found by the end-user in the source code. The recommended way is to use a Public client . encryptionKey: string | undefined : Encryption key of your Fief client. Necessary only if ID Token encryption is enabled.","title":"Fief reference"},{"location":"integrate/javascript/#getauthurl","text":"Returns an authorization URL. Parameters redirectURI: string : Your callback URI where the user will be redirected after Fief authentication. state: string | undefined : Optional string that will be returned back in the callback parameters to allow you to retrieve state information. scope: string[] | undefined : Optional list of scopes to ask for. codeChallenge: string | undefined : Optional code challenge for PKCE process . codeChallengeMethod: 'plain' | 'S256' | undefined : Method used to hash the PKCE code challenge. extras_params: Record<string, string> | undefined : Optional object containing specific parameters. Example const authURL = await fief . getAuthURL ({ redirectURI : 'http://localhost:8000/callback' , scope : [ 'openid' ], );","title":"getAuthURL"},{"location":"integrate/javascript/#authcallback","text":"Returns valid tokens and user info in exchange of an authorization code. Parameters code: string : The authorization code. redirectURI: string : The exact same redirectURI you passed to the authorization URL. codeVerifier: string | undefined : The raw PCKE code used to generate the code challenge during authorization. Example const [ tokens , userinfo ] = await fief . authCallback ( 'CODE' , 'http://localhost:8000/callback' );","title":"authCallback"},{"location":"integrate/javascript/#authrefreshtoken","text":"Returns fresh tokens and user info in exchange of a refresh token. Parameters refresh_token: string : A valid refresh token. scope: string[] | undefined : Optional list of scopes to ask for. If not provided, the access token will share the same list of scopes as requested the first time. Otherwise, it should be a subset of the original list of scopes. Example const [ tokens , userinfo ] = await fief . authRefreshToken ( 'REFRESH_TOKEN' );","title":"authRefreshToken"},{"location":"integrate/javascript/#validateaccesstoken","text":"Checks if an access token is valid and optionally that it has a required list of scopes. Parameters accessToken: string : The access token to validate. requireScopes: string[] | undefined : Optional list of scopes to check for. Example import { FiefAccessTokenExpired , FiefAccessTokenInvalid , FiefAccessTokenMissingScope } from '@fief/fief' ; try { accessTokenInfo = await fief . validateAccessToken ( 'ACCESS_TOKEN' , required_scope = [ 'required_scope' ]); console . log ( accessTokenInfo ); // {\"id\": \"USER_ID\", \"scope\": [\"openid\", \"required_scope\"], \"access_token\": \"ACCESS_TOKEN\"} } catch ( err ) { if ( err instanceof FiefAccessTokenInvalid ) { console . error ( 'Invalid access token' ); } else if ( err instanceof FiefAccessTokenExpired ) { console . error ( 'Expired access token' ); } else if ( err instanceof FiefAccessTokenMissingScope ) { console . error ( 'Missing required scope' ); } }","title":"validateAccessToken"},{"location":"integrate/javascript/#userinfo","text":"Returns fresh user information from the Fief API using a valid access token. Parameters accessToken: string : A valid access token Example userinfo = await fief . userinfo ( 'ACCESS_TOKEN' );","title":"userinfo"},{"location":"integrate/javascript/#getlogouturl","text":"Returns a logout URL. If you redirect the user to this page, Fief will clear the session stored on its side. You're still responsible for clearing your own session mechanism if any. Parameters redirectURI: string : A valid URL where the user will be redirected after the logout process. Example const logoutURL = await fief . getLogoutURL ({ redirectURI : 'http://localhost:8000' , });","title":"getLogoutURL"},{"location":"integrate/javascript/browser/","text":"Browser \u00b6 It's possible to manage authentication with Fief entirely within the browser, using a bit of JavaScript. To help you in this task, the Fief JavaScript client provides tools dedicated to the browser environment. Let's see how to use them! Install the client \u00b6 The recommended way to install the client is to use npm : npm install @fief/fief However, if you don't use a JavaScript bundler, like Webpack, you can include the package directly in a browser script, thanks to UNPKG CDN : < script src = \"https://unpkg.com/@fief/fief\" ></ script > <!-- (1)! --> < script > console . log ( fief ); // Module is available globally under the `fief` variable </ script > This will always load the latest version You should pin the version to avoid problems when we update the client and improve the loading time. For example, to load the version 0.6.1 : < script src = \"https://unpkg.com/@fief/fief@0.6.1/build/index.umd.js\" ></ script > Application example \u00b6 This is for you if... You want to handle all the OAuth authentication in the browser. Prerequisites Make sure your Fief Client is Public . Allow the following Redirect URI on your Fief Client: http://localhost:8080/callback.html Install http-server , a simple NodeJS HTTP server: npm i --global http-server In this example, we'll show you a very simple HTML and JavaScript application to perform the OAuth2 authentication. We'll define two pages: index.html : it'll show if the user is logged in or not, and display a Login button. callback.html : the page Fief will redirect the user to after a successful login to complete the OAuth authentication. Let's see the first one: index.html <!DOCTYPE html> < html > < head > < title > Fief JavaScript Browser example </ title > </ head > < body > < div id = \"logged-out\" style = \"display: none\" > <!-- (1)! --> < h1 > You are not logged in </ h1 > < button type = \"button\" id = \"login-button\" > Login </ button > </ div > < div id = \"logged-in\" style = \"display: none\" > <!-- (2)! --> < h1 > Hello < span id = \"user-email\" ></ span > \ud83d\udc4b </ h1 > < button type = \"button\" id = \"logout-button\" > Logout </ button > </ div > < script src = \"https://unpkg.com/@fief/fief\" ></ script > < script > const initialize = () => { const fiefClient = new fief . Fief ({ // (3)! baseURL : 'https://example.fief.dev' , clientId : 'YOUR_CLIENT_ID' , }); const fiefAuth = new fief . browser . FiefAuth ( fiefClient ); // (4)! document . getElementById ( 'login-button' ). addEventListener ( 'click' , () => { fiefAuth . redirectToLogin ( 'http://localhost:8080/callback.html' ); // (5)! }); document . getElementById ( 'logout-button' ). addEventListener ( 'click' , () => { fiefAuth . logout ( 'http://localhost:8080' ); // (6)! }); const userinfo = fiefAuth . getUserinfo (); // (7)! if ( userinfo !== null ) { // (8)! document . getElementById ( 'logged-in' ). style . display = 'block' ; document . getElementById ( 'logged-out' ). style . display = 'none' ; document . getElementById ( 'user-email' ). textContent = userinfo . email ; } else { // (9)! document . getElementById ( 'logged-in' ). style . display = 'none' ; document . getElementById ( 'logged-out' ). style . display = 'block' ; } }; document . addEventListener ( 'DOMContentLoaded' , initialize , false ); </ script > </ body > </ html > HTML block for when the user is not logged in It simply contains a generic title and a login button . HTML block for when the user is logged in We greet the logged in user with their email address and show them a logout button . Fief client instantiation As we showed in the JavaScript section , we instantiate here a Fief client here with the base tenant URL and client credentials. Notice here that we omit the Client Secret . Indeed, the secret can't be kept safe in the browser: the end-user can easily find it in the source code. That's why we set the Fief Client as Public : we allow it to make authentication requests without the Client Secret. Fief helper for the browser This is the helper doing the tedious work for you in the browser. All it needs is an instance of the Fief client. Under the hood, FiefAuth will store the user session data on the browser SessionStorage . This is how we'll maintain the logged-in state of the user during its visit. When the login button is clicked, redirect to Fief login page We simply add an event listener on the button to start the authorization process when it's clicked. We use the FiefAuth helper for this. All it needs is the redirect URL where the user will be redirected after a successful authentication on Fief: the callback.html page. Under the hood, FiefAuth takes care of generating a PKCE code challenge for maximum security! When the logout button is clicked, clear session and redirect to Fief logout page We simply add an event listener on the button to logout the user. The FiefAuth helper takes care of clearing the local session and redirect to the Fief logout page so that the session on Fief's side can also be cleared. All it needs is the redirect URL where the user will be redirected after a successful logout. Here, we go back to the index.html page. Get user information in session The getUserinfo method of FiefAuth allows to retrieve the user information stored in session, if any. User information is available The user is logged in \ud83d\udc4d We can show the right HTML block and fill the user email to greet them properly. User information is not available The user is not logged in \ud83d\ude14 We can show the right HTML block with the login button. As you can see, the JavaScript code is quite short! Most of the tedious work is done by the FiefAuth helper, which takes care of storing the session in the browser and authenticating the client with PKCE. Let's now see the callback.html page: callback.html <!DOCTYPE html> < html > < head > < title > Fief JavaScript Browser example </ title > </ head > < body > < script src = \"https://unpkg.com/@fief/fief\" ></ script > < script > const initialize = () => { const fiefClient = new fief . Fief ({ baseURL : 'https://example.fief.dev' , clientId : 'YOUR_CLIENT_ID' , }); const fiefAuth = new fief . browser . FiefAuth ( fiefClient ); // (1)! fiefAuth . authCallback ( 'http://localhost:8080/callback.html' ). then ( // (2)! () => { window . location . href = 'http://localhost:8080' ; } ); }; document . addEventListener ( 'DOMContentLoaded' , initialize , false ); </ script > </ body > </ html > This doesn't change We once again instantiate a Fief client and the browser helper. We call the authCallback method This method takes care of everything: retrieving the authorization code in the query parameters, exchanging it with a fresh access token and save it in the browser session. Once the promise is resolved, all we have to do is to redirect back to the index.html page. That's it! Assuming you have both files in a directory named app-directory , you can run this application using http-server : http-server app-directory/ It'll make it available on http://localhost:8080 . The first time you open it, you'll be logged out: If you click on the Login button, you'll be redirected to Fief to authenticate. Once done, you'll be redirected to your application and should be properly logged in: You can also try the Logout button to see how the session is cleared. FiefAuth reference \u00b6 Constructor client: Fief : Instance of a Fief client. storage: IFiefAuthStorage | undefined : Instance of a class implementing the IFiefAuthStorage interface . By default, it'll use an implementation based on the browser SessionStorage . isAuthenticated \u00b6 Returns whether there is a valid user session in the browser. Example const isAuthenticated = fiefAuth . isAuthenticated (); getUserinfo \u00b6 Returns the user information object available in session, or null if no current session. Example const userinfo = fiefAuth . getUserinfo (); console . log ( userinfo ); getTokenInfo \u00b6 Returns the token information object available in session, or null if no current session. Example const tokenInfo = fiefAuth . getTokenInfo (); console . log ( tokenInfo ); // {\"access_token\": \"ACCESS_TOKEN\", \"id_token\": \"ID_TOKEN\", \"token_type\": \"bearer\", \"expires_in\": 3600} redirectToLogin \u00b6 Starts a Fief authorization process and performs the redirection. Under the hood, it automatically generates a PKCE code challenge . Parameters redirectURI: string : Your callback URI where the user will be redirected after Fief authentication. Example fiefAuth . redirectToLogin ( 'http://localhost:8080/callback.html' ); authCallback \u00b6 Completes the Fief authentication process by exchanging the authorization code available in query parameters and stores the tokens and user information in the browser session. Under the hood, it automatically handles the PKCE code challenge . Parameters redirectURI: string : The exact same redirectURI you passed to the authorization URL. Example fiefAuth . authCallback ( 'http://localhost:8080/callback.html' ) . then (() => { window . location . href = 'http://localhost:8080' ; }) . catch (( err ) => { if ( err instance of fief . browser . FiefAuthAuthorizeError ) { console . error ( 'An error occured: ' , err . error , err . description ); } }) refreshUserinfo \u00b6 Refreshes user information from the Fief API using the access token available in session. The fresh user information is returned and automatically updated in the session storage. Example fiefAuth . refreshUserinfo ( 'http://localhost:8080/callback.html' ) . then (( userinfo ) => { console . log ( userinfo ); }) . catch (( err ) => { if ( err instance of fief . browser . FiefAuthNotAuthenticatedError ) { console . error ( 'User is not logged in' ); } }) logout \u00b6 Clears the access token and the user information from the browser storage and redirects to the Fief logout endpoint. Parameters redirectURI: string : A valid URL where the user will be redirected after the logout process. Example fiefAuth . logout ( 'http://localhost:8080' )","title":"Browser"},{"location":"integrate/javascript/browser/#browser","text":"It's possible to manage authentication with Fief entirely within the browser, using a bit of JavaScript. To help you in this task, the Fief JavaScript client provides tools dedicated to the browser environment. Let's see how to use them!","title":"Browser"},{"location":"integrate/javascript/browser/#install-the-client","text":"The recommended way to install the client is to use npm : npm install @fief/fief However, if you don't use a JavaScript bundler, like Webpack, you can include the package directly in a browser script, thanks to UNPKG CDN : < script src = \"https://unpkg.com/@fief/fief\" ></ script > <!-- (1)! --> < script > console . log ( fief ); // Module is available globally under the `fief` variable </ script > This will always load the latest version You should pin the version to avoid problems when we update the client and improve the loading time. For example, to load the version 0.6.1 : < script src = \"https://unpkg.com/@fief/fief@0.6.1/build/index.umd.js\" ></ script >","title":"Install the client"},{"location":"integrate/javascript/browser/#application-example","text":"This is for you if... You want to handle all the OAuth authentication in the browser. Prerequisites Make sure your Fief Client is Public . Allow the following Redirect URI on your Fief Client: http://localhost:8080/callback.html Install http-server , a simple NodeJS HTTP server: npm i --global http-server In this example, we'll show you a very simple HTML and JavaScript application to perform the OAuth2 authentication. We'll define two pages: index.html : it'll show if the user is logged in or not, and display a Login button. callback.html : the page Fief will redirect the user to after a successful login to complete the OAuth authentication. Let's see the first one: index.html <!DOCTYPE html> < html > < head > < title > Fief JavaScript Browser example </ title > </ head > < body > < div id = \"logged-out\" style = \"display: none\" > <!-- (1)! --> < h1 > You are not logged in </ h1 > < button type = \"button\" id = \"login-button\" > Login </ button > </ div > < div id = \"logged-in\" style = \"display: none\" > <!-- (2)! --> < h1 > Hello < span id = \"user-email\" ></ span > \ud83d\udc4b </ h1 > < button type = \"button\" id = \"logout-button\" > Logout </ button > </ div > < script src = \"https://unpkg.com/@fief/fief\" ></ script > < script > const initialize = () => { const fiefClient = new fief . Fief ({ // (3)! baseURL : 'https://example.fief.dev' , clientId : 'YOUR_CLIENT_ID' , }); const fiefAuth = new fief . browser . FiefAuth ( fiefClient ); // (4)! document . getElementById ( 'login-button' ). addEventListener ( 'click' , () => { fiefAuth . redirectToLogin ( 'http://localhost:8080/callback.html' ); // (5)! }); document . getElementById ( 'logout-button' ). addEventListener ( 'click' , () => { fiefAuth . logout ( 'http://localhost:8080' ); // (6)! }); const userinfo = fiefAuth . getUserinfo (); // (7)! if ( userinfo !== null ) { // (8)! document . getElementById ( 'logged-in' ). style . display = 'block' ; document . getElementById ( 'logged-out' ). style . display = 'none' ; document . getElementById ( 'user-email' ). textContent = userinfo . email ; } else { // (9)! document . getElementById ( 'logged-in' ). style . display = 'none' ; document . getElementById ( 'logged-out' ). style . display = 'block' ; } }; document . addEventListener ( 'DOMContentLoaded' , initialize , false ); </ script > </ body > </ html > HTML block for when the user is not logged in It simply contains a generic title and a login button . HTML block for when the user is logged in We greet the logged in user with their email address and show them a logout button . Fief client instantiation As we showed in the JavaScript section , we instantiate here a Fief client here with the base tenant URL and client credentials. Notice here that we omit the Client Secret . Indeed, the secret can't be kept safe in the browser: the end-user can easily find it in the source code. That's why we set the Fief Client as Public : we allow it to make authentication requests without the Client Secret. Fief helper for the browser This is the helper doing the tedious work for you in the browser. All it needs is an instance of the Fief client. Under the hood, FiefAuth will store the user session data on the browser SessionStorage . This is how we'll maintain the logged-in state of the user during its visit. When the login button is clicked, redirect to Fief login page We simply add an event listener on the button to start the authorization process when it's clicked. We use the FiefAuth helper for this. All it needs is the redirect URL where the user will be redirected after a successful authentication on Fief: the callback.html page. Under the hood, FiefAuth takes care of generating a PKCE code challenge for maximum security! When the logout button is clicked, clear session and redirect to Fief logout page We simply add an event listener on the button to logout the user. The FiefAuth helper takes care of clearing the local session and redirect to the Fief logout page so that the session on Fief's side can also be cleared. All it needs is the redirect URL where the user will be redirected after a successful logout. Here, we go back to the index.html page. Get user information in session The getUserinfo method of FiefAuth allows to retrieve the user information stored in session, if any. User information is available The user is logged in \ud83d\udc4d We can show the right HTML block and fill the user email to greet them properly. User information is not available The user is not logged in \ud83d\ude14 We can show the right HTML block with the login button. As you can see, the JavaScript code is quite short! Most of the tedious work is done by the FiefAuth helper, which takes care of storing the session in the browser and authenticating the client with PKCE. Let's now see the callback.html page: callback.html <!DOCTYPE html> < html > < head > < title > Fief JavaScript Browser example </ title > </ head > < body > < script src = \"https://unpkg.com/@fief/fief\" ></ script > < script > const initialize = () => { const fiefClient = new fief . Fief ({ baseURL : 'https://example.fief.dev' , clientId : 'YOUR_CLIENT_ID' , }); const fiefAuth = new fief . browser . FiefAuth ( fiefClient ); // (1)! fiefAuth . authCallback ( 'http://localhost:8080/callback.html' ). then ( // (2)! () => { window . location . href = 'http://localhost:8080' ; } ); }; document . addEventListener ( 'DOMContentLoaded' , initialize , false ); </ script > </ body > </ html > This doesn't change We once again instantiate a Fief client and the browser helper. We call the authCallback method This method takes care of everything: retrieving the authorization code in the query parameters, exchanging it with a fresh access token and save it in the browser session. Once the promise is resolved, all we have to do is to redirect back to the index.html page. That's it! Assuming you have both files in a directory named app-directory , you can run this application using http-server : http-server app-directory/ It'll make it available on http://localhost:8080 . The first time you open it, you'll be logged out: If you click on the Login button, you'll be redirected to Fief to authenticate. Once done, you'll be redirected to your application and should be properly logged in: You can also try the Logout button to see how the session is cleared.","title":"Application example"},{"location":"integrate/javascript/browser/#fiefauth-reference","text":"Constructor client: Fief : Instance of a Fief client. storage: IFiefAuthStorage | undefined : Instance of a class implementing the IFiefAuthStorage interface . By default, it'll use an implementation based on the browser SessionStorage .","title":"FiefAuth reference"},{"location":"integrate/javascript/browser/#isauthenticated","text":"Returns whether there is a valid user session in the browser. Example const isAuthenticated = fiefAuth . isAuthenticated ();","title":"isAuthenticated"},{"location":"integrate/javascript/browser/#getuserinfo","text":"Returns the user information object available in session, or null if no current session. Example const userinfo = fiefAuth . getUserinfo (); console . log ( userinfo );","title":"getUserinfo"},{"location":"integrate/javascript/browser/#gettokeninfo","text":"Returns the token information object available in session, or null if no current session. Example const tokenInfo = fiefAuth . getTokenInfo (); console . log ( tokenInfo ); // {\"access_token\": \"ACCESS_TOKEN\", \"id_token\": \"ID_TOKEN\", \"token_type\": \"bearer\", \"expires_in\": 3600}","title":"getTokenInfo"},{"location":"integrate/javascript/browser/#redirecttologin","text":"Starts a Fief authorization process and performs the redirection. Under the hood, it automatically generates a PKCE code challenge . Parameters redirectURI: string : Your callback URI where the user will be redirected after Fief authentication. Example fiefAuth . redirectToLogin ( 'http://localhost:8080/callback.html' );","title":"redirectToLogin"},{"location":"integrate/javascript/browser/#authcallback","text":"Completes the Fief authentication process by exchanging the authorization code available in query parameters and stores the tokens and user information in the browser session. Under the hood, it automatically handles the PKCE code challenge . Parameters redirectURI: string : The exact same redirectURI you passed to the authorization URL. Example fiefAuth . authCallback ( 'http://localhost:8080/callback.html' ) . then (() => { window . location . href = 'http://localhost:8080' ; }) . catch (( err ) => { if ( err instance of fief . browser . FiefAuthAuthorizeError ) { console . error ( 'An error occured: ' , err . error , err . description ); } })","title":"authCallback"},{"location":"integrate/javascript/browser/#refreshuserinfo","text":"Refreshes user information from the Fief API using the access token available in session. The fresh user information is returned and automatically updated in the session storage. Example fiefAuth . refreshUserinfo ( 'http://localhost:8080/callback.html' ) . then (( userinfo ) => { console . log ( userinfo ); }) . catch (( err ) => { if ( err instance of fief . browser . FiefAuthNotAuthenticatedError ) { console . error ( 'User is not logged in' ); } })","title":"refreshUserinfo"},{"location":"integrate/javascript/browser/#logout","text":"Clears the access token and the user information from the browser storage and redirects to the Fief logout endpoint. Parameters redirectURI: string : A valid URL where the user will be redirected after the logout process. Example fiefAuth . logout ( 'http://localhost:8080' )","title":"logout"},{"location":"integrate/javascript/react/","text":"React \u00b6 React is one of the most popular JavaScript framework to build dynamic applications for the browser. The Fief JavaScript client provides tools to help you integrate Fief authentication in your React project. Let's see how to use them! Install the client \u00b6 npm install @fief/fief Application example \u00b6 This is for you if... You want to handle all the OAuth authentication in your React application. Prerequisites You have a React project setup. Make sure your Fief Client is Public . Allow the following Redirect URI on your Fief Client: http://localhost:3000/callback In this example, we'll show you how to use the components and hooks provided by Fief to authenticate users and protect routes using React Router . Setup FiefAuthProvider \u00b6 The FiefAuthProvider is a component providing all the necessary context for Fief, especially the Fief client and user session state. Every component nested inside this component will have access to the Fief hooks. App.tsx import { FiefAuthProvider } from '@fief/fief/react' ; import { Routes , Route } from 'react-router-dom' ; import Callback from './Callback' ; import Public from './Public' ; import Private from './Private' ; import Header from './Header' ; import RequireAuth from './RequireAuth' ; function App () { return ( < FiefAuthProvider // (1)! baseURL = \"https://example.fief.dev\" clientId = \"YOUR_CLIENT_ID\" > < div className = \"App\" > < h1 > Fief React example < /h1> < Header /> { /* (2)! */ } < Routes > { /* (3)! */ } < Route path = \"/\" element = { < Public /> } /> { /* (4)! */ } < Route path = \"/private\" element = { < RequireAuth >< Private />< /RequireAuth>} / > { /* (5)! */ } < Route path = \"/callback\" element = { < Callback /> } /> { /* (6)! */ } < /Routes> < /div> < /FiefAuthProvider> ); } export default App ; Declare the FiefAuthProvider This is necessary to give to nested components the right Fief context and makes the hooks working. It takes as properties the same arguments as the Fief client. A Header component Contains the navigation. We'll detail it in a moment. The Routes component from React Router A public route This route will be accessible by any visitor, even if not logged in. A private route This route will be accessible only by logged in users. To do this, we wrap it in a RequireAuth component. We'll detail it in a moment. A callback route The route where Fief will redirect the user to after a successful login to complete the OAuth authentication. At this point, your React app has everything it needs to use Fief authentication tools! Implement callback route \u00b6 After the user has successfully logged in on Fief, they will be redirected to your callback route. It needs to exchange the authorization code with a proper access token. The role of this route is then just to perform this task before redirecting to another route. Callback.tsx import { useFiefAuth } from '@fief/fief/react' ; import { useEffect } from 'react' ; import { useNavigate } from 'react-router-dom' ; const Callback : React.FunctionComponent = () => { const fiefAuth = useFiefAuth (); // (1)! const navigate = useNavigate (); useEffect (() => { fiefAuth . authCallback ( ` ${ window . location . protocol } // ${ window . location . host } /callback` ). then (() => { // (2)! navigate ( '/' ); }); }, [ fiefAuth , navigate ]); return ( < p > Callback !< /p> ); }; export default Callback ; Hook to get the FiefAuth class This is the browser helper provided by the Fief JavaScript client. We call the authCallback method This method takes care of everything: retrieving the authorization code in the query parameters, exchanging it with a fresh access token and save it in the browser session. Once the promise is resolved, all we have to do is to redirect back to the index page. Protect private routes \u00b6 Usually, you'll need to prevent visitors from accessing a page if they're not logged in. To do this, we implement a simple component that'll check for the authentication state and automatically redirect to the Fief authentication page if the user is not logged in. RequireAuth.tsx import { useFiefAuth , useFiefIsAuthenticated } from '@fief/fief/react' ; import React , { useEffect } from 'react' ; const RequireAuth : React.FunctionComponent = ({ children }) => { const fiefAuth = useFiefAuth (); // (1)! const isAuthenticated = useFiefIsAuthenticated (); // (2)! useEffect (() => { if ( ! isAuthenticated ) { fiefAuth . redirectToLogin ( ` ${ window . location . protocol } // ${ window . location . host } /callback` ); // (3)! } }, [ fiefAuth , isAuthenticated ]); return ( <> { isAuthenticated && children } < /> ); }; export default RequireAuth ; Hook to get the FiefAuth class This is the browser helper provided by the Fief JavaScript client. Hook to get the authentication state This hook simply returns a boolean stating if a user is logged in or not. Redirect to Fief authentication page With this effect, we automatically redirect the user to the Fief authentication page so that they can log in. The redirectToLogin method only needs the redirect URL where the user will be redirected after a successful authentication on Fief: the /callback route. Manage authentication \u00b6 You have access to a set of hooks to help you manage the authentication state of the user, like retrieving their information, redirect them to the authentication page or logout them. In the example below, we show a simple header with navigation links and a login or logout button. Header.tsx import { useFiefAuth , useFiefIsAuthenticated , useFiefUserinfo } from '@fief/fief/react' ; import React , { useCallback } from 'react' ; import { Link } from 'react-router-dom' ; const Header : React.FunctionComponent = () => { const fiefAuth = useFiefAuth (); const isAuthenticated = useFiefIsAuthenticated (); const userinfo = useFiefUserinfo (); // (1)! const login = useCallback (() => { // (2)! fiefAuth . redirectToLogin ( ` ${ window . location . protocol } // ${ window . location . host } /callback` ); }, [ fiefAuth ]); const logout = useCallback (() => { // (3)! fiefAuth . logout ( ` ${ window . location . protocol } // ${ window . location . host } ` ); }, [ fiefAuth ]); return ( < ul > < li >< Link to = \"/\" > Public page < /Link></li> < li >< Link to = \"/private\" > Private page < /Link></li> < li > { ! isAuthenticated && < button type = \"button\" onClick = {() => login ()} > Login < /button>} { isAuthenticated && userinfo && ( < div > < span > { userinfo . email } < /span> < button type = \"button\" onClick = {() => logout ()} > Logout < /button> < /div> )} < /li> < /ul> ); }; export default Header ; Hook to get user information It'll return you an object with the user information, or null if no user is authenticated. Callback to redirect to Fief authentication page When the login button is clicked, this callback will redirect to the Fief authentication page. This is exactly the same thing we showed in the RequireAuth component. Callback to logout When the logout button is clicked, this callback will start the logout process. The FiefAuth helper takes care of clearing the local session and redirect to the Fief logout page so that the session on Fief's side can also be cleared. All it needs is the redirect URL where the user will be redirected after a successful logout. Here, we go back to the index route. React reference \u00b6 Components \u00b6 FiefAuthProvider \u00b6 Provides all the necessary context for Fief, especially the Fief client and user session state. Every component nested inside this component will have access to the Fief hooks. Parameters baseURL: string : Base URL of your Fief tenant. clientID: string : ID of your Fief client. clientSecret: string | undefined : Secret of your Fief client. It's not recommended to use it in the context of a browser app, since it can be easily found by the end-user in the source code. The recommended way is to use a Public client . encryptionKey: string | undefined : Encryption key of your Fief client. Necessary only if ID Token encryption is enabled. Hooks \u00b6 useFiefAuth \u00b6 Returns an instance of the FiefAuth browser helper . Example const fiefAuth = useFiefAuth (); useFiefIsAuthenticated \u00b6 Returns whether there is a valid user session. Example const isAuthenticated = useFiefIsAuthenticated (); useFiefTokenInfo \u00b6 Returns the token information object available in session, or null if no current session. Example const tokenInfo = useFiefTokenInfo () console . log ( tokenInfo ); // {\"access_token\": \"ACCESS_TOKEN\", \"id_token\": \"ID_TOKEN\", \"token_type\": \"bearer\", \"expires_in\": 3600} useFiefUserinfo \u00b6 Returns the user information object available in session, or null if no current session. Example const userinfo = useFiefUserinfo (); console . log ( userinfo );","title":"React"},{"location":"integrate/javascript/react/#react","text":"React is one of the most popular JavaScript framework to build dynamic applications for the browser. The Fief JavaScript client provides tools to help you integrate Fief authentication in your React project. Let's see how to use them!","title":"React"},{"location":"integrate/javascript/react/#install-the-client","text":"npm install @fief/fief","title":"Install the client"},{"location":"integrate/javascript/react/#application-example","text":"This is for you if... You want to handle all the OAuth authentication in your React application. Prerequisites You have a React project setup. Make sure your Fief Client is Public . Allow the following Redirect URI on your Fief Client: http://localhost:3000/callback In this example, we'll show you how to use the components and hooks provided by Fief to authenticate users and protect routes using React Router .","title":"Application example"},{"location":"integrate/javascript/react/#setup-fiefauthprovider","text":"The FiefAuthProvider is a component providing all the necessary context for Fief, especially the Fief client and user session state. Every component nested inside this component will have access to the Fief hooks. App.tsx import { FiefAuthProvider } from '@fief/fief/react' ; import { Routes , Route } from 'react-router-dom' ; import Callback from './Callback' ; import Public from './Public' ; import Private from './Private' ; import Header from './Header' ; import RequireAuth from './RequireAuth' ; function App () { return ( < FiefAuthProvider // (1)! baseURL = \"https://example.fief.dev\" clientId = \"YOUR_CLIENT_ID\" > < div className = \"App\" > < h1 > Fief React example < /h1> < Header /> { /* (2)! */ } < Routes > { /* (3)! */ } < Route path = \"/\" element = { < Public /> } /> { /* (4)! */ } < Route path = \"/private\" element = { < RequireAuth >< Private />< /RequireAuth>} / > { /* (5)! */ } < Route path = \"/callback\" element = { < Callback /> } /> { /* (6)! */ } < /Routes> < /div> < /FiefAuthProvider> ); } export default App ; Declare the FiefAuthProvider This is necessary to give to nested components the right Fief context and makes the hooks working. It takes as properties the same arguments as the Fief client. A Header component Contains the navigation. We'll detail it in a moment. The Routes component from React Router A public route This route will be accessible by any visitor, even if not logged in. A private route This route will be accessible only by logged in users. To do this, we wrap it in a RequireAuth component. We'll detail it in a moment. A callback route The route where Fief will redirect the user to after a successful login to complete the OAuth authentication. At this point, your React app has everything it needs to use Fief authentication tools!","title":"Setup FiefAuthProvider"},{"location":"integrate/javascript/react/#implement-callback-route","text":"After the user has successfully logged in on Fief, they will be redirected to your callback route. It needs to exchange the authorization code with a proper access token. The role of this route is then just to perform this task before redirecting to another route. Callback.tsx import { useFiefAuth } from '@fief/fief/react' ; import { useEffect } from 'react' ; import { useNavigate } from 'react-router-dom' ; const Callback : React.FunctionComponent = () => { const fiefAuth = useFiefAuth (); // (1)! const navigate = useNavigate (); useEffect (() => { fiefAuth . authCallback ( ` ${ window . location . protocol } // ${ window . location . host } /callback` ). then (() => { // (2)! navigate ( '/' ); }); }, [ fiefAuth , navigate ]); return ( < p > Callback !< /p> ); }; export default Callback ; Hook to get the FiefAuth class This is the browser helper provided by the Fief JavaScript client. We call the authCallback method This method takes care of everything: retrieving the authorization code in the query parameters, exchanging it with a fresh access token and save it in the browser session. Once the promise is resolved, all we have to do is to redirect back to the index page.","title":"Implement callback route"},{"location":"integrate/javascript/react/#protect-private-routes","text":"Usually, you'll need to prevent visitors from accessing a page if they're not logged in. To do this, we implement a simple component that'll check for the authentication state and automatically redirect to the Fief authentication page if the user is not logged in. RequireAuth.tsx import { useFiefAuth , useFiefIsAuthenticated } from '@fief/fief/react' ; import React , { useEffect } from 'react' ; const RequireAuth : React.FunctionComponent = ({ children }) => { const fiefAuth = useFiefAuth (); // (1)! const isAuthenticated = useFiefIsAuthenticated (); // (2)! useEffect (() => { if ( ! isAuthenticated ) { fiefAuth . redirectToLogin ( ` ${ window . location . protocol } // ${ window . location . host } /callback` ); // (3)! } }, [ fiefAuth , isAuthenticated ]); return ( <> { isAuthenticated && children } < /> ); }; export default RequireAuth ; Hook to get the FiefAuth class This is the browser helper provided by the Fief JavaScript client. Hook to get the authentication state This hook simply returns a boolean stating if a user is logged in or not. Redirect to Fief authentication page With this effect, we automatically redirect the user to the Fief authentication page so that they can log in. The redirectToLogin method only needs the redirect URL where the user will be redirected after a successful authentication on Fief: the /callback route.","title":"Protect private routes"},{"location":"integrate/javascript/react/#manage-authentication","text":"You have access to a set of hooks to help you manage the authentication state of the user, like retrieving their information, redirect them to the authentication page or logout them. In the example below, we show a simple header with navigation links and a login or logout button. Header.tsx import { useFiefAuth , useFiefIsAuthenticated , useFiefUserinfo } from '@fief/fief/react' ; import React , { useCallback } from 'react' ; import { Link } from 'react-router-dom' ; const Header : React.FunctionComponent = () => { const fiefAuth = useFiefAuth (); const isAuthenticated = useFiefIsAuthenticated (); const userinfo = useFiefUserinfo (); // (1)! const login = useCallback (() => { // (2)! fiefAuth . redirectToLogin ( ` ${ window . location . protocol } // ${ window . location . host } /callback` ); }, [ fiefAuth ]); const logout = useCallback (() => { // (3)! fiefAuth . logout ( ` ${ window . location . protocol } // ${ window . location . host } ` ); }, [ fiefAuth ]); return ( < ul > < li >< Link to = \"/\" > Public page < /Link></li> < li >< Link to = \"/private\" > Private page < /Link></li> < li > { ! isAuthenticated && < button type = \"button\" onClick = {() => login ()} > Login < /button>} { isAuthenticated && userinfo && ( < div > < span > { userinfo . email } < /span> < button type = \"button\" onClick = {() => logout ()} > Logout < /button> < /div> )} < /li> < /ul> ); }; export default Header ; Hook to get user information It'll return you an object with the user information, or null if no user is authenticated. Callback to redirect to Fief authentication page When the login button is clicked, this callback will redirect to the Fief authentication page. This is exactly the same thing we showed in the RequireAuth component. Callback to logout When the logout button is clicked, this callback will start the logout process. The FiefAuth helper takes care of clearing the local session and redirect to the Fief logout page so that the session on Fief's side can also be cleared. All it needs is the redirect URL where the user will be redirected after a successful logout. Here, we go back to the index route.","title":"Manage authentication"},{"location":"integrate/javascript/react/#react-reference","text":"","title":"React reference"},{"location":"integrate/javascript/react/#components","text":"","title":"Components"},{"location":"integrate/javascript/react/#fiefauthprovider","text":"Provides all the necessary context for Fief, especially the Fief client and user session state. Every component nested inside this component will have access to the Fief hooks. Parameters baseURL: string : Base URL of your Fief tenant. clientID: string : ID of your Fief client. clientSecret: string | undefined : Secret of your Fief client. It's not recommended to use it in the context of a browser app, since it can be easily found by the end-user in the source code. The recommended way is to use a Public client . encryptionKey: string | undefined : Encryption key of your Fief client. Necessary only if ID Token encryption is enabled.","title":"FiefAuthProvider"},{"location":"integrate/javascript/react/#hooks","text":"","title":"Hooks"},{"location":"integrate/javascript/react/#usefiefauth","text":"Returns an instance of the FiefAuth browser helper . Example const fiefAuth = useFiefAuth ();","title":"useFiefAuth"},{"location":"integrate/javascript/react/#usefiefisauthenticated","text":"Returns whether there is a valid user session. Example const isAuthenticated = useFiefIsAuthenticated ();","title":"useFiefIsAuthenticated"},{"location":"integrate/javascript/react/#usefieftokeninfo","text":"Returns the token information object available in session, or null if no current session. Example const tokenInfo = useFiefTokenInfo () console . log ( tokenInfo ); // {\"access_token\": \"ACCESS_TOKEN\", \"id_token\": \"ID_TOKEN\", \"token_type\": \"bearer\", \"expires_in\": 3600}","title":"useFiefTokenInfo"},{"location":"integrate/javascript/react/#usefiefuserinfo","text":"Returns the user information object available in session, or null if no current session. Example const userinfo = useFiefUserinfo (); console . log ( userinfo );","title":"useFiefUserinfo"},{"location":"integrate/python/","text":"Python \u00b6 We provide an official client for Python. You can install it with pip : pip install fief-client Create a Fief client \u00b6 Prerequisites Allow the following Redirect URI on your Fief Client: http://localhost:8000/callback The Fief client provides all the necessary methods to manage OAuth2 authentication, validate access tokens and refresh them. client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) Base URL of your Fief tenant You can find it in the admin dashboard, in the Tenants list. More info ID of your Fief client You can find it in the admin dashboard, in the Clients list. More info Info A first client is always created for you when you create your workspace. When getting started, you should use this one. Secret of your Fief client You can find it in the admin dashboard, in the Clients list. More info Info A first client is always created for you when you create your workspace. When getting started, you should use this one. Avoid to hardcode your secrets in your code It's usually not recommended to hardcode secrets like Client ID and Secret in your code like this. If your code gets published on the web, for example on GitHub, the security of your workspace would be compromised. Besides, it'll be harder if you need to deploy on several environments, like a staging or testing one, in addition to your production environment. A standard and widely-used approach is to use environment variables . Async support For asyncio enthusiasts, we also provide a FiefAsync class with the same methods. Perform an OAuth2 flow manually \u00b6 The simple script below shows you how to authenticate with OAuth2 \"manually\". The goal is to show you how to use the client. You'll then be able to integrate it in your own project with your framework and stack. The first step is to generate an authorization URL , which is an URL on the Fief server that'll ask you for your email address and password. client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) Then, we make the script prompt for the authorization code . client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) This temporary code is generated by Fief upon successful login and can be used to obtain valid tokens. Fief returns both an access token and an ID token , which contains information about the user. client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) Test it \u00b6 You can run this script from a command line: python client.py You'll get the following output: Open this URL in your browser: https://example.fief.dev/authorize?response_type=code&client_id=YOUR_CLIENT_ID&redirect_uri=http%3A%2F%2Flocalhost%3A8000%2Fcallback&scope=openid Paste the callback code: You can copy and paste this URL manually in your browser . You'll be redirected to a Fief login page. Upon successful login, Fief will redirect to the redirect URL you defined above, including a query parameter named code . It'll look like this: http://localhost:8000/redirect?code=wPEDiSRkoYOtA-4QCJHpsLne0P2PXVYAlW6hcH5OVBg Your browser will probably show an error at this point In this simple implementation, we don't have a web server running on our local machine, so the browser won't be able to open the redirect URL. It's not a problem: what we care about is retrieving the authorization code by hand. Copy the code value, get back to the command line where the script is running and paste it. You'll get the following output: Paste the callback code: wPEDiSRkoYOtA-4QCJHpsLne0P2PXVYAlW6hcH5OVBg Tokens: {'access_token': 'eyJhbGciOiJSUzI1NiJ9.eyJhdWQiOlsiRE9JaGpfNzJIYTlyWWg5dURnbmRTdTYyRVhKdUZmUTVsa2t4MS1rc1VJbyJdLCJhenAiOiJET0loal83MkhhOXJZaDl1RGduZFN1NjJFWEp1RmZRNWxra3gxLWtzVUlvIiwiZXhwIjoxNjQ4MDUwNDIzLCJpYXQiOjE2NDgwNDY4MjMsImlzcyI6Imh0dHBzOi8vZXhhbXBsZS5maWVmLmRldiIsInNjb3BlIjoib3BlbmlkIiwic3ViIjoiYTM4NDZjYzEtN2MwOC00Mzg5LThjOGUtYzBlNzlmNzA3NWZlIn0.R5JnZW9Vq6lWai-FZcqsihYxmtFRbIjZ7D0Ck9XAG0d2YnQQ7ms3bUwtXEAnLhos4C3paGDa0PzQRtXSAx4IH85ZdeVJoBk9GrOj1ZV7E6dtZZSZlvtY2msMeXFC9gNg-A86R9ZU_T0PoROof0u1eJHYVlmo_dv2fodyNqkDB8V6HK3vqf7jaqNQtk8Fg6eHKhwb-3bAtjb5cpWAAWhMSrHZzTWIYUvYsvwAas5ihgenv3UOkpcl_p7b7G9SDhGE5abPQQ7lvyfhYZE7CV1DzVRU6UL4N0D2l4uI3RJNOQoECvltfo2etYzp5viwAwvg9LUS3466Ra1i8beBKXsPFQ', 'id_token': 'eyJhbGciOiJSUzI1NiJ9.eyJhdWQiOlsiRE9JaGpfNzJIYTlyWWg5dURnbmRTdTYyRVhKdUZmUTVsa2t4MS1rc1VJbyJdLCJhenAiOiJET0loal83MkhhOXJZaDl1RGduZFN1NjJFWEp1RmZRNWxra3gxLWtzVUlvIiwiZW1haWwiOiJmcmFuY29pcyt0ZXN0QGZpZWYuZGV2IiwiZXhwIjoxNjQ4MDUwNDIzLCJpYXQiOjE2NDgwNDY4MjMsImlzcyI6Imh0dHBzOi8vZXhhbXBsZS5maWVmLmRldiIsInN1YiI6ImEzODQ2Y2MxLTdjMDgtNDM4OS04YzhlLWMwZTc5ZjcwNzVmZSIsInRlbmFudF9pZCI6IjcwNDEzNWI2LTRiZmQtNGM1NS04MDkwLWM2MzhhNmJhNTNhMiJ9.ULQy7TlgF5_oQwwgA6ydTahTYE31obr4F3olJy-mgyPw67XstoJLM1VwUNawzyz2Iu2QDmgcBrH3OMVfgCkBAFk2sp-QQIDr9arIF1QXNKG65El3zgPQ5-niTTsIuAkemyjNGcpdrcN2b9FaeodzauO5eOjno60h5dTBbcLnqv00V-Jv6sq8lB8_o5JXHKWUoZZA2VFEDox9MXfhDqrvyHcitsIRWIy7XhILKcZ-JG_AMcXnuDcyMnsoy91-gJznvMk7_ty9eNWs8Cm0ZhK3nMqEKML4tXIREmIN-vYUGDtbDWX3O45N98ovu9gJi9S3aVOh-gZQsnwauJmlW82ZQQ', 'token_type': 'bearer', 'expires_in': 3600} Userinfo: {'aud': ['YOUR_CLIENT_ID'], 'azp': 'YOUR_CLIENT_ID', 'email': 'anne@bretagne.duchy', 'exp': 1648050423, 'iat': 1648046823, 'iss': 'https://example.fief.dev', 'sub': 'a3846cc1-7c08-4389-8c8e-c0e79f7075fe', 'tenant_id': '704135b6-4bfd-4c55-8090-c638a6ba53a2'} As you can see, we obtained a first dictionary tokens containing an access token, an ID token and other standard OAuth2 information. The second variable, userinfo , is a dictionary with the user data. It's actually the information contained in the ID token that the client decoded for you. What's next? \u00b6 You have the fundamental basics for performing an OAuth2 authentication with the Fief Python client. To help you further, we provide you helpers and examples for popular Python frameworks like Flask or FastAPI. Integrate with FastAPI Integrate with Flask Fief reference \u00b6 Initializer base_url: str : Base URL of your Fief tenant. client_id: str : ID of your Fief client. client_secret: str : Secret of your Fief client. encryption_key: Optional[str] = None : Encryption key of your Fief client. Necessary only if ID Token encryption is enabled. auth_url \u00b6 Returns an authorization URL. Parameters redirect_uri: str : Your callback URI where the user will be redirected after Fief authentication. state: str = None : Optional string that will be returned back in the callback parameters to allow you to retrieve state information. scope: Optional[List[str]] = None : Optional list of scopes to ask for. code_challenge: Optional[str] = None : Optional code challenge for PKCE process . code_challenge_method: Optional[str] = None : Method used to hash the PKCE code challenge. extras_params: Optional[Dict[str, Any]] = None : Optional dictionary containing specific parameters. Example auth_url = fief . auth_url ( \"http://localhost:8000/callback\" , scope = [ \"openid\" ]) auth_callback \u00b6 Returns valid tokens and user info in exchange of an authorization code. Parameters code: str : The authorization code. redirect_uri: str : The exact same redirect_uri you passed to the authorization URL. code_verifier: Optional[str] = None : The raw PCKE code used to generate the code challenge during authorization. Example tokens , userinfo = fief . auth_callback ( \"CODE\" , \"http://localhost:8000/callback\" ) auth_refresh_token \u00b6 Returns fresh tokens and user info in exchange of a refresh token. Parameters refresh_token: str : A valid refresh token. scope: Optional[List[str]] = None : Optional list of scopes to ask for. If not provided, the access token will share the same list of scopes as requested the first time. Otherwise, it should be a subset of the original list of scopes. Example tokens , userinfo = fief . auth_refresh_token ( \"REFRESH_TOKEN\" ) validate_access_token \u00b6 Checks if an access token is valid and optionally that it has a required list of scopes. Parameters access_token: str : The access token to validate. required_scope: Optional[List[str]] = None : Optional list of scopes to check for. Example from fief_client import FiefAccessTokenInvalid , FiefAccessTokenExpired , FiefAccessTokenMissingScope try : access_token_info = fief . validate_access_token ( \"ACCESS_TOKEN\" , required_scope = [ \"required_scope\" ]) except FiefAccessTokenInvalid : print ( \"Invalid access token\" ) except FiefAccessTokenExpired : print ( \"Expired access token\" ) except FiefAccessTokenMissingScope : print ( \"Missing required scope\" ) print ( access_token_info ) # {\"id\": \"USER_ID\", \"scope\": [\"openid\", \"required_scope\"], \"access_token\": \"ACCESS_TOKEN\"} userinfo \u00b6 Returns fresh user information from the Fief API using a valid access token. Parameters access_token: str : A valid access token Example userinfo = fief . userinfo ( \"ACCESS_TOKEN\" ) logout_url \u00b6 Returns a logout URL. If you redirect the user to this page, Fief will clear the session stored on its side. You're still responsible for clearing your own session mechanism if any. Parameters redirect_uri: str : A valid URL where the user will be redirected after the logout process Example logout_url = fief . logout_url ( \"http://localhost:8000\" )","title":"Python"},{"location":"integrate/python/#python","text":"We provide an official client for Python. You can install it with pip : pip install fief-client","title":"Python"},{"location":"integrate/python/#create-a-fief-client","text":"Prerequisites Allow the following Redirect URI on your Fief Client: http://localhost:8000/callback The Fief client provides all the necessary methods to manage OAuth2 authentication, validate access tokens and refresh them. client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) Base URL of your Fief tenant You can find it in the admin dashboard, in the Tenants list. More info ID of your Fief client You can find it in the admin dashboard, in the Clients list. More info Info A first client is always created for you when you create your workspace. When getting started, you should use this one. Secret of your Fief client You can find it in the admin dashboard, in the Clients list. More info Info A first client is always created for you when you create your workspace. When getting started, you should use this one. Avoid to hardcode your secrets in your code It's usually not recommended to hardcode secrets like Client ID and Secret in your code like this. If your code gets published on the web, for example on GitHub, the security of your workspace would be compromised. Besides, it'll be harder if you need to deploy on several environments, like a staging or testing one, in addition to your production environment. A standard and widely-used approach is to use environment variables . Async support For asyncio enthusiasts, we also provide a FiefAsync class with the same methods.","title":"Create a Fief client"},{"location":"integrate/python/#perform-an-oauth2-flow-manually","text":"The simple script below shows you how to authenticate with OAuth2 \"manually\". The goal is to show you how to use the client. You'll then be able to integrate it in your own project with your framework and stack. The first step is to generate an authorization URL , which is an URL on the Fief server that'll ask you for your email address and password. client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) Then, we make the script prompt for the authorization code . client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) This temporary code is generated by Fief upon successful login and can be used to obtain valid tokens. Fief returns both an access token and an ID token , which contains information about the user. client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" )","title":"Perform an OAuth2 flow manually"},{"location":"integrate/python/#test-it","text":"You can run this script from a command line: python client.py You'll get the following output: Open this URL in your browser: https://example.fief.dev/authorize?response_type=code&client_id=YOUR_CLIENT_ID&redirect_uri=http%3A%2F%2Flocalhost%3A8000%2Fcallback&scope=openid Paste the callback code: You can copy and paste this URL manually in your browser . You'll be redirected to a Fief login page. Upon successful login, Fief will redirect to the redirect URL you defined above, including a query parameter named code . It'll look like this: http://localhost:8000/redirect?code=wPEDiSRkoYOtA-4QCJHpsLne0P2PXVYAlW6hcH5OVBg Your browser will probably show an error at this point In this simple implementation, we don't have a web server running on our local machine, so the browser won't be able to open the redirect URL. It's not a problem: what we care about is retrieving the authorization code by hand. Copy the code value, get back to the command line where the script is running and paste it. You'll get the following output: Paste the callback code: wPEDiSRkoYOtA-4QCJHpsLne0P2PXVYAlW6hcH5OVBg Tokens: {'access_token': 'eyJhbGciOiJSUzI1NiJ9.eyJhdWQiOlsiRE9JaGpfNzJIYTlyWWg5dURnbmRTdTYyRVhKdUZmUTVsa2t4MS1rc1VJbyJdLCJhenAiOiJET0loal83MkhhOXJZaDl1RGduZFN1NjJFWEp1RmZRNWxra3gxLWtzVUlvIiwiZXhwIjoxNjQ4MDUwNDIzLCJpYXQiOjE2NDgwNDY4MjMsImlzcyI6Imh0dHBzOi8vZXhhbXBsZS5maWVmLmRldiIsInNjb3BlIjoib3BlbmlkIiwic3ViIjoiYTM4NDZjYzEtN2MwOC00Mzg5LThjOGUtYzBlNzlmNzA3NWZlIn0.R5JnZW9Vq6lWai-FZcqsihYxmtFRbIjZ7D0Ck9XAG0d2YnQQ7ms3bUwtXEAnLhos4C3paGDa0PzQRtXSAx4IH85ZdeVJoBk9GrOj1ZV7E6dtZZSZlvtY2msMeXFC9gNg-A86R9ZU_T0PoROof0u1eJHYVlmo_dv2fodyNqkDB8V6HK3vqf7jaqNQtk8Fg6eHKhwb-3bAtjb5cpWAAWhMSrHZzTWIYUvYsvwAas5ihgenv3UOkpcl_p7b7G9SDhGE5abPQQ7lvyfhYZE7CV1DzVRU6UL4N0D2l4uI3RJNOQoECvltfo2etYzp5viwAwvg9LUS3466Ra1i8beBKXsPFQ', 'id_token': 'eyJhbGciOiJSUzI1NiJ9.eyJhdWQiOlsiRE9JaGpfNzJIYTlyWWg5dURnbmRTdTYyRVhKdUZmUTVsa2t4MS1rc1VJbyJdLCJhenAiOiJET0loal83MkhhOXJZaDl1RGduZFN1NjJFWEp1RmZRNWxra3gxLWtzVUlvIiwiZW1haWwiOiJmcmFuY29pcyt0ZXN0QGZpZWYuZGV2IiwiZXhwIjoxNjQ4MDUwNDIzLCJpYXQiOjE2NDgwNDY4MjMsImlzcyI6Imh0dHBzOi8vZXhhbXBsZS5maWVmLmRldiIsInN1YiI6ImEzODQ2Y2MxLTdjMDgtNDM4OS04YzhlLWMwZTc5ZjcwNzVmZSIsInRlbmFudF9pZCI6IjcwNDEzNWI2LTRiZmQtNGM1NS04MDkwLWM2MzhhNmJhNTNhMiJ9.ULQy7TlgF5_oQwwgA6ydTahTYE31obr4F3olJy-mgyPw67XstoJLM1VwUNawzyz2Iu2QDmgcBrH3OMVfgCkBAFk2sp-QQIDr9arIF1QXNKG65El3zgPQ5-niTTsIuAkemyjNGcpdrcN2b9FaeodzauO5eOjno60h5dTBbcLnqv00V-Jv6sq8lB8_o5JXHKWUoZZA2VFEDox9MXfhDqrvyHcitsIRWIy7XhILKcZ-JG_AMcXnuDcyMnsoy91-gJznvMk7_ty9eNWs8Cm0ZhK3nMqEKML4tXIREmIN-vYUGDtbDWX3O45N98ovu9gJi9S3aVOh-gZQsnwauJmlW82ZQQ', 'token_type': 'bearer', 'expires_in': 3600} Userinfo: {'aud': ['YOUR_CLIENT_ID'], 'azp': 'YOUR_CLIENT_ID', 'email': 'anne@bretagne.duchy', 'exp': 1648050423, 'iat': 1648046823, 'iss': 'https://example.fief.dev', 'sub': 'a3846cc1-7c08-4389-8c8e-c0e79f7075fe', 'tenant_id': '704135b6-4bfd-4c55-8090-c638a6ba53a2'} As you can see, we obtained a first dictionary tokens containing an access token, an ID token and other standard OAuth2 information. The second variable, userinfo , is a dictionary with the user data. It's actually the information contained in the ID token that the client decoded for you.","title":"Test it"},{"location":"integrate/python/#whats-next","text":"You have the fundamental basics for performing an OAuth2 authentication with the Fief Python client. To help you further, we provide you helpers and examples for popular Python frameworks like Flask or FastAPI. Integrate with FastAPI Integrate with Flask","title":"What's next?"},{"location":"integrate/python/#fief-reference","text":"Initializer base_url: str : Base URL of your Fief tenant. client_id: str : ID of your Fief client. client_secret: str : Secret of your Fief client. encryption_key: Optional[str] = None : Encryption key of your Fief client. Necessary only if ID Token encryption is enabled.","title":"Fief reference"},{"location":"integrate/python/#auth_url","text":"Returns an authorization URL. Parameters redirect_uri: str : Your callback URI where the user will be redirected after Fief authentication. state: str = None : Optional string that will be returned back in the callback parameters to allow you to retrieve state information. scope: Optional[List[str]] = None : Optional list of scopes to ask for. code_challenge: Optional[str] = None : Optional code challenge for PKCE process . code_challenge_method: Optional[str] = None : Method used to hash the PKCE code challenge. extras_params: Optional[Dict[str, Any]] = None : Optional dictionary containing specific parameters. Example auth_url = fief . auth_url ( \"http://localhost:8000/callback\" , scope = [ \"openid\" ])","title":"auth_url"},{"location":"integrate/python/#auth_callback","text":"Returns valid tokens and user info in exchange of an authorization code. Parameters code: str : The authorization code. redirect_uri: str : The exact same redirect_uri you passed to the authorization URL. code_verifier: Optional[str] = None : The raw PCKE code used to generate the code challenge during authorization. Example tokens , userinfo = fief . auth_callback ( \"CODE\" , \"http://localhost:8000/callback\" )","title":"auth_callback"},{"location":"integrate/python/#auth_refresh_token","text":"Returns fresh tokens and user info in exchange of a refresh token. Parameters refresh_token: str : A valid refresh token. scope: Optional[List[str]] = None : Optional list of scopes to ask for. If not provided, the access token will share the same list of scopes as requested the first time. Otherwise, it should be a subset of the original list of scopes. Example tokens , userinfo = fief . auth_refresh_token ( \"REFRESH_TOKEN\" )","title":"auth_refresh_token"},{"location":"integrate/python/#validate_access_token","text":"Checks if an access token is valid and optionally that it has a required list of scopes. Parameters access_token: str : The access token to validate. required_scope: Optional[List[str]] = None : Optional list of scopes to check for. Example from fief_client import FiefAccessTokenInvalid , FiefAccessTokenExpired , FiefAccessTokenMissingScope try : access_token_info = fief . validate_access_token ( \"ACCESS_TOKEN\" , required_scope = [ \"required_scope\" ]) except FiefAccessTokenInvalid : print ( \"Invalid access token\" ) except FiefAccessTokenExpired : print ( \"Expired access token\" ) except FiefAccessTokenMissingScope : print ( \"Missing required scope\" ) print ( access_token_info ) # {\"id\": \"USER_ID\", \"scope\": [\"openid\", \"required_scope\"], \"access_token\": \"ACCESS_TOKEN\"}","title":"validate_access_token"},{"location":"integrate/python/#userinfo","text":"Returns fresh user information from the Fief API using a valid access token. Parameters access_token: str : A valid access token Example userinfo = fief . userinfo ( \"ACCESS_TOKEN\" )","title":"userinfo"},{"location":"integrate/python/#logout_url","text":"Returns a logout URL. If you redirect the user to this page, Fief will clear the session stored on its side. You're still responsible for clearing your own session mechanism if any. Parameters redirect_uri: str : A valid URL where the user will be redirected after the logout process Example logout_url = fief . logout_url ( \"http://localhost:8000\" )","title":"logout_url"},{"location":"integrate/python/fastapi/","text":"FastAPI \u00b6 FastAPI is one of the fastest-growing Python web framework. It features impressive performance and top-notch developer experience. Actually, the Fief server itself is implemented with FastAPI! The Fief Python client provides tools to help you integrate Fief authentication in your FastAPI project. Let's see how to use them! Install the client \u00b6 Install the Fief client with the optional FastAPI dependencies: pip install \"fief-client[fastapi]\" API example \u00b6 This is for you if... Your FastAPI backend will work as a pure REST API. You have a separate frontend, like a JavaScript or mobile app, that'll take care of the OAuth2 flow. Prerequisites Check that the following Redirect URI is allowed on your Fief Client: http://localhost:8000/docs/oauth2-redirect In this first example, we'll leverage the interactive documentation generated by FastAPI to perform the OAuth2 authentication. The goal here is just to show you how to protect your API route with a Fief access token . app.py from fastapi import Depends , FastAPI from fastapi.security import OAuth2AuthorizationCodeBearer from fief_client import FiefAccessTokenInfo , FiefAsync from fief_client.integrations.fastapi import FiefAuth fief = FiefAsync ( # (1)! \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) scheme = OAuth2AuthorizationCodeBearer ( # (2)! \"https://example.fief.dev/authorize\" , \"https://example.fief.dev/api/token\" , scopes = { \"openid\" : \"openid\" , \"offline_access\" : \"offline_access\" }, ) auth = FiefAuth ( fief , scheme ) # (3)! app = FastAPI () @app . get ( \"/user\" ) async def get_user ( access_token_info : FiefAccessTokenInfo = Depends ( auth . current_user ()), # (4)! ): return access_token_info Fief client instantiation As we showed in the standard Python section , we instantiate here a Fief client here with the base tenant URL and client credentials. Notice here that we use the FiefAsync class. FastAPI being an ASGI framework, it's always nice to take advantage of asyncio capabilities. OpenAPI security scheme FastAPI uses those security schemes to generate an interactive documentation showing the right interface to authenticate with the API. We use here a standard OAuth2 interface. Fief helper for FastAPI This is the helper doing the tedious work for you with FastAPI. All it needs is an instance of the Fief client and the scheme. current_user dependency This is where the magic happens: in pure FastAPI style, FiefAuth gives you a current_user dependency to check for the access token and optionally for required scopes. If everything goes well, you'll get a dictionary containing the ID of the user, the list of allowed scopes and the raw access token. And that's about it! Test it \u00b6 You can run this example just like you would do for any FastAPI app: uvicorn app:app Open http://localhost:8000/docs to access the interactive documentation. Let's try first the /user endpoint: We get an 401 error! That's expected: we are not authenticated yet ! Let's fix that: click on the Authorize button to start the authentication process. You'll need to provide your client ID and secret and select the scopes. Click on the Authorize button: you are redirected to the Fief login page. Upon successful login, you will be redirected back to the interactive documentation: a valid access token has been generated! You can now try the /user endpoint to check the result: Notice how the interactive documentation passed the access token in the Authorization header of the request! Besides, the response does contain the user ID, the list of allowed scopes and the access token itself. Checking for scopes \u00b6 Building on the previous example, you can make your endpoint requires the access token to be granted a list of scopes . Simply add this list of scopes as a parameter of the current_user dependency. app.py from fastapi import Depends , FastAPI from fastapi.security import OAuth2AuthorizationCodeBearer from fief_client import FiefAccessTokenInfo , FiefAsync from fief_client.integrations.fastapi import FiefAuth fief = FiefAsync ( \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) scheme = OAuth2AuthorizationCodeBearer ( \"https://example.fief.dev/authorize\" , \"https://example.fief.dev/api/token\" , scopes = { \"openid\" : \"openid\" , \"offline_access\" : \"offline_access\" }, ) auth = FiefAuth ( fief , scheme ) app = FastAPI () @app . get ( \"/user\" ) async def get_user ( access_token_info : FiefAccessTokenInfo = Depends ( auth . current_user ([ \"openid\" , \"required_scope\" ]) ), ): return access_token_info If one of the required scope is missing on the access token, a 403 Forbidden error will automatically be returned. Web application example \u00b6 This is for you if... Your FastAPI backend will render HTML pages. Your application is intended to be used in a browser. Prerequisites Allow the following Redirect URI on your Fief Client: http://localhost:8000/auth-callback The examples we showed previously are working well in a pure REST API context: a frontend, like interactive documentation, a JavaScript application or a mobile app will take care of the OAuth2 authentication flow to retrieve an access token before making request to your API. Another common context is traditional web application , where the server takes care of generating HTML pages before returning it to the browser. In this case, we'll need some routes to redirect the user to the Fief login page if they're not authenticated and take care of storing the access token somewhere. This is what'll show in this example. Basically, here's what we'll do: This time, we'll expect the access token to be passed through a traditional cookie instead of an HTTP header. Cookies are very convenient when designing web apps because they are handled automatically by the browser. If the cookie is not present, we'll redirect the user to the Fief login page . Once again, the browser will help us a lot here since it'll automatically follow the redirection. Upon successful login, Fief will automatically redirect the user to the callback route . This callback route will take care of setting a new cookie containing the access token . It means that the access token will be safely stored in the browser memory. Finally, the user is redirected back to the protected route. The browser will automatically send the cookie containing the access token: our request is now authenticated! app.py from datetime import datetime from fastapi import Depends , FastAPI , HTTPException , Query , Request , Response , status from fastapi.responses import HTMLResponse , RedirectResponse from fastapi.security import APIKeyCookie from fief_client import FiefAccessTokenInfo , FiefAsync from fief_client.integrations.fastapi import FiefAuth class CustomFiefAuth ( FiefAuth ): # (1)! client : FiefAsync async def get_unauthorized_response ( self , request : Request , response : Response ): redirect_uri = request . url_for ( \"auth_callback\" ) # (2)! auth_url = await self . client . auth_url ( redirect_uri , scope = [ \"openid\" ]) # (3)! raise HTTPException ( status_code = status . HTTP_307_TEMPORARY_REDIRECT , # (4)! headers = { \"Location\" : auth_url }, ) fief = FiefAsync ( # (5)! \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) SESSION_COOKIE_NAME = \"user_session\" scheme = APIKeyCookie ( name = SESSION_COOKIE_NAME , auto_error = False ) # (6)! auth = CustomFiefAuth ( fief , scheme ) # (7)! app = FastAPI () @app . get ( \"/auth-callback\" , name = \"auth_callback\" ) # (8)! async def auth_callback ( request : Request , response : Response , code : str = Query ( ... )): redirect_uri = request . url_for ( \"auth_callback\" ) tokens , _ = await fief . auth_callback ( code , redirect_uri ) # (9)! response = RedirectResponse ( request . url_for ( \"protected\" )) # (10)! response . set_cookie ( # (11)! SESSION_COOKIE_NAME , tokens [ \"access_token\" ], expires = int ( datetime . now () . timestamp () + tokens [ \"expires_in\" ]), httponly = True , # (12)! secure = False , # \u274c Set this to `True` in production (13)! ) return response @app . get ( \"/protected\" , name = \"protected\" ) async def protected ( access_token_info : FiefAccessTokenInfo = Depends ( auth . current_user ()), # (14)! ): return HTMLResponse ( f \"<h1>You are authenticated. Your user ID is { access_token_info [ 'id' ] } </h1>\" ) We customize the FiefAuth helper to fit our needs The base class is implemented with an API scenario in mind. Nevertheless, it's designed in a way you can customize its behavior when the user is not authenticated or has not the required scope. That's what'll do with the get_unauthorized_response . We build the redirect URL This points to our /auth-callback route that we define below. We generate an authorization URL on the Fief server Thanks to the auth_url method on the Fief client, we can automatically generate the authorization URL on the Fief server. We build a redirect response By setting a status code in the 3XX range, we tell the browser that it should redirect the user to another URL, specified in the Location header. You can read more about HTTP redirections on the MDN documentation . This doesn't change from the previous example The FiefAsync client is always at the heart of the integration \ud83d\ude09 We use a scheme expecting a cookie Contrary to the previous examples, we expect the access token to be passed in a cookie. Thus, we use a dedicated scheme for that. Notice that we set the name of this cookie through the SESSION_COOKIE_NAME constant. Besides, we set the auto_error argument to False . It tells FastAPI user to bypass its built-in error response if the cookie is not present: we have our own logic to handle this. We use our custom CustomFiefAuth class Of course, now that we overloaded the behavior of this helper class, we shouldn't forget to actually use it! We implement an /auth-callback route This is the route that'll take care of exchanging the authorization code with a fresh access token and save it in a cookie. Notice that we set its name parameter: this is how we can generate its URL automatically with the request.url_for method. We generate an access token We finish the OAuth2 flow by exchanging the authorization code with a fresh access token. We build a redirection to the /protected route The user will now be correctly authenticated to our web application. Thus, we can redirect them to a protected page. We build a new cookie containing the access token The response will contain a Set-Cookie header instructing the browser to save the access token in its memory. This method allows us to configure each properties of the cookie. You can read more about HTTP cookies on the MDN documentation . Set the cookie as HTTPOnly For such sensitive values, it's strongly recommended to set the cookie as HTTPOnly . It means that it won't be possible to read its value from JavaScript, reducing potential attacks. Set the cookie as secure in production For such sensitive values, it's strongly recommended to set the cookie as Secure . It tells the browser to send the cookie only on HTTPS (SSL) connection, reducing the risk of the access token to be stolen by a attacker between the client and the server. However, in a local environment, you usually don't serve your application with SSL. That's why we set it to False in this example. A common approach to handle this is to have an environment variable to control this parameter, so you can disable it in local and enable it in production. Use the current_user dependency as usual This doesn't change from the previous example. The dependency will check if the cookie is available in the request and proceed if everything goes well. Otherwise, our custom get_unauthorized_response will be called and the user will be redirected to the Fief login page. That's it! If you run this application and go to http://localhost:8000/protected , you'll be redirected to the Fief login page and experience the authentication flow before getting back to this route with a proper authentication cookie.","title":"FastAPI"},{"location":"integrate/python/fastapi/#fastapi","text":"FastAPI is one of the fastest-growing Python web framework. It features impressive performance and top-notch developer experience. Actually, the Fief server itself is implemented with FastAPI! The Fief Python client provides tools to help you integrate Fief authentication in your FastAPI project. Let's see how to use them!","title":"FastAPI"},{"location":"integrate/python/fastapi/#install-the-client","text":"Install the Fief client with the optional FastAPI dependencies: pip install \"fief-client[fastapi]\"","title":"Install the client"},{"location":"integrate/python/fastapi/#api-example","text":"This is for you if... Your FastAPI backend will work as a pure REST API. You have a separate frontend, like a JavaScript or mobile app, that'll take care of the OAuth2 flow. Prerequisites Check that the following Redirect URI is allowed on your Fief Client: http://localhost:8000/docs/oauth2-redirect In this first example, we'll leverage the interactive documentation generated by FastAPI to perform the OAuth2 authentication. The goal here is just to show you how to protect your API route with a Fief access token . app.py from fastapi import Depends , FastAPI from fastapi.security import OAuth2AuthorizationCodeBearer from fief_client import FiefAccessTokenInfo , FiefAsync from fief_client.integrations.fastapi import FiefAuth fief = FiefAsync ( # (1)! \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) scheme = OAuth2AuthorizationCodeBearer ( # (2)! \"https://example.fief.dev/authorize\" , \"https://example.fief.dev/api/token\" , scopes = { \"openid\" : \"openid\" , \"offline_access\" : \"offline_access\" }, ) auth = FiefAuth ( fief , scheme ) # (3)! app = FastAPI () @app . get ( \"/user\" ) async def get_user ( access_token_info : FiefAccessTokenInfo = Depends ( auth . current_user ()), # (4)! ): return access_token_info Fief client instantiation As we showed in the standard Python section , we instantiate here a Fief client here with the base tenant URL and client credentials. Notice here that we use the FiefAsync class. FastAPI being an ASGI framework, it's always nice to take advantage of asyncio capabilities. OpenAPI security scheme FastAPI uses those security schemes to generate an interactive documentation showing the right interface to authenticate with the API. We use here a standard OAuth2 interface. Fief helper for FastAPI This is the helper doing the tedious work for you with FastAPI. All it needs is an instance of the Fief client and the scheme. current_user dependency This is where the magic happens: in pure FastAPI style, FiefAuth gives you a current_user dependency to check for the access token and optionally for required scopes. If everything goes well, you'll get a dictionary containing the ID of the user, the list of allowed scopes and the raw access token. And that's about it!","title":"API example"},{"location":"integrate/python/fastapi/#test-it","text":"You can run this example just like you would do for any FastAPI app: uvicorn app:app Open http://localhost:8000/docs to access the interactive documentation. Let's try first the /user endpoint: We get an 401 error! That's expected: we are not authenticated yet ! Let's fix that: click on the Authorize button to start the authentication process. You'll need to provide your client ID and secret and select the scopes. Click on the Authorize button: you are redirected to the Fief login page. Upon successful login, you will be redirected back to the interactive documentation: a valid access token has been generated! You can now try the /user endpoint to check the result: Notice how the interactive documentation passed the access token in the Authorization header of the request! Besides, the response does contain the user ID, the list of allowed scopes and the access token itself.","title":"Test it"},{"location":"integrate/python/fastapi/#checking-for-scopes","text":"Building on the previous example, you can make your endpoint requires the access token to be granted a list of scopes . Simply add this list of scopes as a parameter of the current_user dependency. app.py from fastapi import Depends , FastAPI from fastapi.security import OAuth2AuthorizationCodeBearer from fief_client import FiefAccessTokenInfo , FiefAsync from fief_client.integrations.fastapi import FiefAuth fief = FiefAsync ( \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) scheme = OAuth2AuthorizationCodeBearer ( \"https://example.fief.dev/authorize\" , \"https://example.fief.dev/api/token\" , scopes = { \"openid\" : \"openid\" , \"offline_access\" : \"offline_access\" }, ) auth = FiefAuth ( fief , scheme ) app = FastAPI () @app . get ( \"/user\" ) async def get_user ( access_token_info : FiefAccessTokenInfo = Depends ( auth . current_user ([ \"openid\" , \"required_scope\" ]) ), ): return access_token_info If one of the required scope is missing on the access token, a 403 Forbidden error will automatically be returned.","title":"Checking for scopes"},{"location":"integrate/python/fastapi/#web-application-example","text":"This is for you if... Your FastAPI backend will render HTML pages. Your application is intended to be used in a browser. Prerequisites Allow the following Redirect URI on your Fief Client: http://localhost:8000/auth-callback The examples we showed previously are working well in a pure REST API context: a frontend, like interactive documentation, a JavaScript application or a mobile app will take care of the OAuth2 authentication flow to retrieve an access token before making request to your API. Another common context is traditional web application , where the server takes care of generating HTML pages before returning it to the browser. In this case, we'll need some routes to redirect the user to the Fief login page if they're not authenticated and take care of storing the access token somewhere. This is what'll show in this example. Basically, here's what we'll do: This time, we'll expect the access token to be passed through a traditional cookie instead of an HTTP header. Cookies are very convenient when designing web apps because they are handled automatically by the browser. If the cookie is not present, we'll redirect the user to the Fief login page . Once again, the browser will help us a lot here since it'll automatically follow the redirection. Upon successful login, Fief will automatically redirect the user to the callback route . This callback route will take care of setting a new cookie containing the access token . It means that the access token will be safely stored in the browser memory. Finally, the user is redirected back to the protected route. The browser will automatically send the cookie containing the access token: our request is now authenticated! app.py from datetime import datetime from fastapi import Depends , FastAPI , HTTPException , Query , Request , Response , status from fastapi.responses import HTMLResponse , RedirectResponse from fastapi.security import APIKeyCookie from fief_client import FiefAccessTokenInfo , FiefAsync from fief_client.integrations.fastapi import FiefAuth class CustomFiefAuth ( FiefAuth ): # (1)! client : FiefAsync async def get_unauthorized_response ( self , request : Request , response : Response ): redirect_uri = request . url_for ( \"auth_callback\" ) # (2)! auth_url = await self . client . auth_url ( redirect_uri , scope = [ \"openid\" ]) # (3)! raise HTTPException ( status_code = status . HTTP_307_TEMPORARY_REDIRECT , # (4)! headers = { \"Location\" : auth_url }, ) fief = FiefAsync ( # (5)! \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) SESSION_COOKIE_NAME = \"user_session\" scheme = APIKeyCookie ( name = SESSION_COOKIE_NAME , auto_error = False ) # (6)! auth = CustomFiefAuth ( fief , scheme ) # (7)! app = FastAPI () @app . get ( \"/auth-callback\" , name = \"auth_callback\" ) # (8)! async def auth_callback ( request : Request , response : Response , code : str = Query ( ... )): redirect_uri = request . url_for ( \"auth_callback\" ) tokens , _ = await fief . auth_callback ( code , redirect_uri ) # (9)! response = RedirectResponse ( request . url_for ( \"protected\" )) # (10)! response . set_cookie ( # (11)! SESSION_COOKIE_NAME , tokens [ \"access_token\" ], expires = int ( datetime . now () . timestamp () + tokens [ \"expires_in\" ]), httponly = True , # (12)! secure = False , # \u274c Set this to `True` in production (13)! ) return response @app . get ( \"/protected\" , name = \"protected\" ) async def protected ( access_token_info : FiefAccessTokenInfo = Depends ( auth . current_user ()), # (14)! ): return HTMLResponse ( f \"<h1>You are authenticated. Your user ID is { access_token_info [ 'id' ] } </h1>\" ) We customize the FiefAuth helper to fit our needs The base class is implemented with an API scenario in mind. Nevertheless, it's designed in a way you can customize its behavior when the user is not authenticated or has not the required scope. That's what'll do with the get_unauthorized_response . We build the redirect URL This points to our /auth-callback route that we define below. We generate an authorization URL on the Fief server Thanks to the auth_url method on the Fief client, we can automatically generate the authorization URL on the Fief server. We build a redirect response By setting a status code in the 3XX range, we tell the browser that it should redirect the user to another URL, specified in the Location header. You can read more about HTTP redirections on the MDN documentation . This doesn't change from the previous example The FiefAsync client is always at the heart of the integration \ud83d\ude09 We use a scheme expecting a cookie Contrary to the previous examples, we expect the access token to be passed in a cookie. Thus, we use a dedicated scheme for that. Notice that we set the name of this cookie through the SESSION_COOKIE_NAME constant. Besides, we set the auto_error argument to False . It tells FastAPI user to bypass its built-in error response if the cookie is not present: we have our own logic to handle this. We use our custom CustomFiefAuth class Of course, now that we overloaded the behavior of this helper class, we shouldn't forget to actually use it! We implement an /auth-callback route This is the route that'll take care of exchanging the authorization code with a fresh access token and save it in a cookie. Notice that we set its name parameter: this is how we can generate its URL automatically with the request.url_for method. We generate an access token We finish the OAuth2 flow by exchanging the authorization code with a fresh access token. We build a redirection to the /protected route The user will now be correctly authenticated to our web application. Thus, we can redirect them to a protected page. We build a new cookie containing the access token The response will contain a Set-Cookie header instructing the browser to save the access token in its memory. This method allows us to configure each properties of the cookie. You can read more about HTTP cookies on the MDN documentation . Set the cookie as HTTPOnly For such sensitive values, it's strongly recommended to set the cookie as HTTPOnly . It means that it won't be possible to read its value from JavaScript, reducing potential attacks. Set the cookie as secure in production For such sensitive values, it's strongly recommended to set the cookie as Secure . It tells the browser to send the cookie only on HTTPS (SSL) connection, reducing the risk of the access token to be stolen by a attacker between the client and the server. However, in a local environment, you usually don't serve your application with SSL. That's why we set it to False in this example. A common approach to handle this is to have an environment variable to control this parameter, so you can disable it in local and enable it in production. Use the current_user dependency as usual This doesn't change from the previous example. The dependency will check if the cookie is available in the request and proceed if everything goes well. Otherwise, our custom get_unauthorized_response will be called and the user will be redirected to the Fief login page. That's it! If you run this application and go to http://localhost:8000/protected , you'll be redirected to the Fief login page and experience the authentication flow before getting back to this route with a proper authentication cookie.","title":"Web application example"},{"location":"integrate/python/flask/","text":"Flask \u00b6 Flask is probably the most popular Python web framework. The Fief Python client provides tools to help you integrate Fief authentication in your Flask project. Let's see how to use them! Install the client \u00b6 Install the Fief client with the optional Flask dependencies: pip install \"fief-client[flask]\" API example \u00b6 This is for you if... Your Flask backend will work as a pure REST API. You have a separate frontend, like a JavaScript or mobile app, that'll take care of the OAuth2 flow. In this first example, we won't implement routes to perform the OAuth2 authentication. The goal here is just to show you how to protect your API route with a Fief access token . app.py from fief_client import Fief from fief_client.integrations.flask import ( FiefAuth , FiefAuthForbidden , FiefAuthUnauthorized , get_authorization_scheme_token , ) from flask import Flask , g fief = Fief ( # (1)! \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) auth = FiefAuth ( fief , get_authorization_scheme_token ()) # (2)! app = Flask ( __name__ ) @app . errorhandler ( FiefAuthUnauthorized ) # (3)! def fief_unauthorized_error ( e ): return \"\" , 401 @app . errorhandler ( FiefAuthForbidden ) # (4)! def fief_forbidden_error ( e ): return \"\" , 403 @app . get ( \"/user\" ) @auth . current_user () # (5)! def get_user (): return g . user # (6)! @app . get ( \"/user-scope\" ) @auth . current_user ( scope = [ \"openid\" , \"required_scope\" ]) # (7)! def get_user_scope (): return g . user Fief client instantiation As we showed in the standard Python section , we instantiate here a Fief client here with the base tenant URL and client credentials. Fief helper for Flask This is the helper doing the tedious work for you with Flask. It first needs an instance of the Fief client we created above and a function retrieving the access token from the Flask request . It's a simple function which can use the global request object to retrieve the access token. For convenience, we provide two of them: get_authorization_scheme_token and get_cookie . Error handler for FiefAuthUnauthorized When a protected route is called without a valid access token, the Fief helper will raise the FiefAuthUnauthorized . By registering a Flask error handler, we can catch this error and customize the response returned to the user. Here, we just return an empty response with the 401 status code. Error handler for FiefAuthForbidden When a request is made with a valid access token but without the required scope, the Fief helper will raise the FiefAuthForbidden . By registering a Flask error handler, we can catch this error and customize the response returned to the user. Here, we just return an empty response with the 403 status code. current_user decorator This is where the magic happens: FiefAuth gives you a current_user decorator to check for the access token and optionally for required scopes. If everything goes well, the route logic will be executed. user dictionary is available in g When a valid access token is found in the request, the current_user decorator will automatically add the user property to the global g application context of Flask . This user property is a dictionary containing the ID of the user, the list of allowed scopes and the raw access token. Check for scopes The current_user decorator accepts an optional scope argument where you can list the scope required to access this route. If the access token doesn't have the required scope, the FiefAuthForbidden is raised. And that's about it! Web application example \u00b6 This is for you if... Your Flask backend will render HTML pages. Your application is intended to be used in a browser. Prerequisites Allow the following Redirect URI on your Fief Client: http://localhost:8000/auth-callback The examples we showed previously are working well in a pure REST API context: a frontend, like interactive documentation, a JavaScript application or a mobile app will take care of the OAuth2 authentication flow to retrieve an access token before making request to your API. Another common context is traditional web application , where the server takes care of generating HTML pages before returning it to the browser. In this case, we'll need some routes to redirect the user to the Fief login page if they're not authenticated and take care of storing the access token somewhere. This is what'll show in this example. Basically, here's what we'll do: This time, we'll expect the access token to be passed through a traditional cookie instead of an HTTP header. Cookies are very convenient when designing web apps because they are handled automatically by the browser. If the cookie is not present, we'll redirect the user to the Fief login page . Once again, the browser will help us a lot here since it'll automatically follow the redirection. Upon successful login, Fief will automatically redirect the user to the callback route . This callback route will take care of setting a new cookie containing the access token . It means that the access token will be safely stored in the browser memory. Finally, the user is redirected back to the protected route. The browser will automatically send the cookie containing the access token: our request is now authenticated! app.py from datetime import datetime from fief_client import Fief from fief_client.integrations.flask import ( FiefAuth , FiefAuthForbidden , FiefAuthUnauthorized , get_cookie , ) from flask import Flask , g , redirect , request , url_for SESSION_COOKIE_NAME = \"user_session\" fief = Fief ( # (1)! \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) auth = FiefAuth ( fief , get_cookie ( SESSION_COOKIE_NAME )) # (2)! app = Flask ( __name__ ) @app . errorhandler ( FiefAuthUnauthorized ) # (3)! def fief_unauthorized_error ( e ): redirect_uri = url_for ( \"auth_callback\" , _external = True ) # (4)! auth_url = fief . auth_url ( redirect_uri , scope = [ \"openid\" ]) # (5)! return redirect ( auth_url ) # (6)! @app . errorhandler ( FiefAuthForbidden ) def fief_forbidden_error ( e ): return \"\" , 403 @app . get ( \"/auth-callback\" ) # (7)! def auth_callback (): redirect_uri = url_for ( \"auth_callback\" , _external = True ) code = request . args [ \"code\" ] tokens , _ = fief . auth_callback ( code , redirect_uri ) # (8)! response = redirect ( url_for ( \"protected\" )) # (9)! response . set_cookie ( # (10)! SESSION_COOKIE_NAME , tokens [ \"access_token\" ], expires = int ( datetime . now () . timestamp () + tokens [ \"expires_in\" ]), httponly = True , # (11)! secure = False , # \u274c Set this to `True` in production (12)! ) return response @app . get ( \"/protected\" ) @auth . current_user () # (13)! def protected (): user = g . user return f \"<h1>You are authenticated. Your user ID is { user [ 'id' ] } </h1>\" This doesn't change from the previous example The Fief client is always at the heart of the integration \ud83d\ude09 We use a cookie getter Contrary to the previous examples, we expect the access token to be passed in a cookie. Thus, we use the get_cookie getter. Notice that we set the name of this cookie through the SESSION_COOKIE_NAME constant. We change the error handler for FiefAuthUnauthorized This time, we'll generate a redirect response so the user can login on Fief. We build the redirect URL This points to our /auth-callback route that we define below. We generate an authorization URL on the Fief server Thanks to the auth_url method on the Fief client, we can automatically generate the authorization URL on the Fief server. We build a redirect response We redirect the user to the Fief authorization URL. We implement an /auth-callback route This is the route that'll take care of exchanging the authorization code with a fresh access token and save it in a cookie. We generate an access token We finish the OAuth2 flow by exchanging the authorization code with a fresh access token. We build a redirection to the /protected route The user will now be correctly authenticated to our web application. Thus, we can redirect them to a protected page. We build a new cookie containing the access token The response will contain a Set-Cookie header instructing the browser to save the access token in its memory. This method allows us to configure each properties of the cookie. You can read more about HTTP cookies on the MDN documentation . Set the cookie as HTTPOnly For such sensitive values, it's strongly recommended to set the cookie as HTTPOnly . It means that it won't be possible to read its value from JavaScript, reducing potential attacks. Set the cookie as secure in production For such sensitive values, it's strongly recommended to set the cookie as Secure . It tells the browser to send the cookie only on HTTPS (SSL) connection, reducing the risk of the access token to be stolen by a attacker between the client and the server. However, in a local environment, you usually don't serve your application with SSL. That's why we set it to False in this example. A common approach to handle this is to have an environment variable to control this parameter, so you can disable it in local and enable it in production. Use the current_user decorator as usual This doesn't change from the previous example. The dependency will check if the cookie is available in the request and proceed if everything goes well. Otherwise, an FiefAuthUnauthorized error will be raised and the user will be redirected to the Fief login page. That's it! If you run this application and go to http://localhost:8000/protected , you'll be redirected to the Fief login page and experience the authentication flow before getting back to this route with a proper authentication cookie.","title":"Flask"},{"location":"integrate/python/flask/#flask","text":"Flask is probably the most popular Python web framework. The Fief Python client provides tools to help you integrate Fief authentication in your Flask project. Let's see how to use them!","title":"Flask"},{"location":"integrate/python/flask/#install-the-client","text":"Install the Fief client with the optional Flask dependencies: pip install \"fief-client[flask]\"","title":"Install the client"},{"location":"integrate/python/flask/#api-example","text":"This is for you if... Your Flask backend will work as a pure REST API. You have a separate frontend, like a JavaScript or mobile app, that'll take care of the OAuth2 flow. In this first example, we won't implement routes to perform the OAuth2 authentication. The goal here is just to show you how to protect your API route with a Fief access token . app.py from fief_client import Fief from fief_client.integrations.flask import ( FiefAuth , FiefAuthForbidden , FiefAuthUnauthorized , get_authorization_scheme_token , ) from flask import Flask , g fief = Fief ( # (1)! \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) auth = FiefAuth ( fief , get_authorization_scheme_token ()) # (2)! app = Flask ( __name__ ) @app . errorhandler ( FiefAuthUnauthorized ) # (3)! def fief_unauthorized_error ( e ): return \"\" , 401 @app . errorhandler ( FiefAuthForbidden ) # (4)! def fief_forbidden_error ( e ): return \"\" , 403 @app . get ( \"/user\" ) @auth . current_user () # (5)! def get_user (): return g . user # (6)! @app . get ( \"/user-scope\" ) @auth . current_user ( scope = [ \"openid\" , \"required_scope\" ]) # (7)! def get_user_scope (): return g . user Fief client instantiation As we showed in the standard Python section , we instantiate here a Fief client here with the base tenant URL and client credentials. Fief helper for Flask This is the helper doing the tedious work for you with Flask. It first needs an instance of the Fief client we created above and a function retrieving the access token from the Flask request . It's a simple function which can use the global request object to retrieve the access token. For convenience, we provide two of them: get_authorization_scheme_token and get_cookie . Error handler for FiefAuthUnauthorized When a protected route is called without a valid access token, the Fief helper will raise the FiefAuthUnauthorized . By registering a Flask error handler, we can catch this error and customize the response returned to the user. Here, we just return an empty response with the 401 status code. Error handler for FiefAuthForbidden When a request is made with a valid access token but without the required scope, the Fief helper will raise the FiefAuthForbidden . By registering a Flask error handler, we can catch this error and customize the response returned to the user. Here, we just return an empty response with the 403 status code. current_user decorator This is where the magic happens: FiefAuth gives you a current_user decorator to check for the access token and optionally for required scopes. If everything goes well, the route logic will be executed. user dictionary is available in g When a valid access token is found in the request, the current_user decorator will automatically add the user property to the global g application context of Flask . This user property is a dictionary containing the ID of the user, the list of allowed scopes and the raw access token. Check for scopes The current_user decorator accepts an optional scope argument where you can list the scope required to access this route. If the access token doesn't have the required scope, the FiefAuthForbidden is raised. And that's about it!","title":"API example"},{"location":"integrate/python/flask/#web-application-example","text":"This is for you if... Your Flask backend will render HTML pages. Your application is intended to be used in a browser. Prerequisites Allow the following Redirect URI on your Fief Client: http://localhost:8000/auth-callback The examples we showed previously are working well in a pure REST API context: a frontend, like interactive documentation, a JavaScript application or a mobile app will take care of the OAuth2 authentication flow to retrieve an access token before making request to your API. Another common context is traditional web application , where the server takes care of generating HTML pages before returning it to the browser. In this case, we'll need some routes to redirect the user to the Fief login page if they're not authenticated and take care of storing the access token somewhere. This is what'll show in this example. Basically, here's what we'll do: This time, we'll expect the access token to be passed through a traditional cookie instead of an HTTP header. Cookies are very convenient when designing web apps because they are handled automatically by the browser. If the cookie is not present, we'll redirect the user to the Fief login page . Once again, the browser will help us a lot here since it'll automatically follow the redirection. Upon successful login, Fief will automatically redirect the user to the callback route . This callback route will take care of setting a new cookie containing the access token . It means that the access token will be safely stored in the browser memory. Finally, the user is redirected back to the protected route. The browser will automatically send the cookie containing the access token: our request is now authenticated! app.py from datetime import datetime from fief_client import Fief from fief_client.integrations.flask import ( FiefAuth , FiefAuthForbidden , FiefAuthUnauthorized , get_cookie , ) from flask import Flask , g , redirect , request , url_for SESSION_COOKIE_NAME = \"user_session\" fief = Fief ( # (1)! \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) auth = FiefAuth ( fief , get_cookie ( SESSION_COOKIE_NAME )) # (2)! app = Flask ( __name__ ) @app . errorhandler ( FiefAuthUnauthorized ) # (3)! def fief_unauthorized_error ( e ): redirect_uri = url_for ( \"auth_callback\" , _external = True ) # (4)! auth_url = fief . auth_url ( redirect_uri , scope = [ \"openid\" ]) # (5)! return redirect ( auth_url ) # (6)! @app . errorhandler ( FiefAuthForbidden ) def fief_forbidden_error ( e ): return \"\" , 403 @app . get ( \"/auth-callback\" ) # (7)! def auth_callback (): redirect_uri = url_for ( \"auth_callback\" , _external = True ) code = request . args [ \"code\" ] tokens , _ = fief . auth_callback ( code , redirect_uri ) # (8)! response = redirect ( url_for ( \"protected\" )) # (9)! response . set_cookie ( # (10)! SESSION_COOKIE_NAME , tokens [ \"access_token\" ], expires = int ( datetime . now () . timestamp () + tokens [ \"expires_in\" ]), httponly = True , # (11)! secure = False , # \u274c Set this to `True` in production (12)! ) return response @app . get ( \"/protected\" ) @auth . current_user () # (13)! def protected (): user = g . user return f \"<h1>You are authenticated. Your user ID is { user [ 'id' ] } </h1>\" This doesn't change from the previous example The Fief client is always at the heart of the integration \ud83d\ude09 We use a cookie getter Contrary to the previous examples, we expect the access token to be passed in a cookie. Thus, we use the get_cookie getter. Notice that we set the name of this cookie through the SESSION_COOKIE_NAME constant. We change the error handler for FiefAuthUnauthorized This time, we'll generate a redirect response so the user can login on Fief. We build the redirect URL This points to our /auth-callback route that we define below. We generate an authorization URL on the Fief server Thanks to the auth_url method on the Fief client, we can automatically generate the authorization URL on the Fief server. We build a redirect response We redirect the user to the Fief authorization URL. We implement an /auth-callback route This is the route that'll take care of exchanging the authorization code with a fresh access token and save it in a cookie. We generate an access token We finish the OAuth2 flow by exchanging the authorization code with a fresh access token. We build a redirection to the /protected route The user will now be correctly authenticated to our web application. Thus, we can redirect them to a protected page. We build a new cookie containing the access token The response will contain a Set-Cookie header instructing the browser to save the access token in its memory. This method allows us to configure each properties of the cookie. You can read more about HTTP cookies on the MDN documentation . Set the cookie as HTTPOnly For such sensitive values, it's strongly recommended to set the cookie as HTTPOnly . It means that it won't be possible to read its value from JavaScript, reducing potential attacks. Set the cookie as secure in production For such sensitive values, it's strongly recommended to set the cookie as Secure . It tells the browser to send the cookie only on HTTPS (SSL) connection, reducing the risk of the access token to be stolen by a attacker between the client and the server. However, in a local environment, you usually don't serve your application with SSL. That's why we set it to False in this example. A common approach to handle this is to have an environment variable to control this parameter, so you can disable it in local and enable it in production. Use the current_user decorator as usual This doesn't change from the previous example. The dependency will check if the cookie is available in the request and proceed if everything goes well. Otherwise, an FiefAuthUnauthorized error will be raised and the user will be redirected to the Fief login page. That's it! If you run this application and go to http://localhost:8000/protected , you'll be redirected to the Fief login page and experience the authentication flow before getting back to this route with a proper authentication cookie.","title":"Web application example"},{"location":"miscellaneous/resources/","text":"Resources \u00b6 RFC7517 (JSON Web Key): https://datatracker.ietf.org/doc/html/rfc7517 RFC7636 (OAuth2 PKCE): https://datatracker.ietf.org/doc/html/rfc7636 RFC8414 (OAuth2 Metadata): https://datatracker.ietf.org/doc/html/rfc8414 OpenID Connect 1.0 specification: https://openid.net/specs/openid-connect-core-1_0.html JWCrypto's library documentation: https://jwcrypto.readthedocs.io/","title":"Resources"},{"location":"miscellaneous/resources/#resources","text":"RFC7517 (JSON Web Key): https://datatracker.ietf.org/doc/html/rfc7517 RFC7636 (OAuth2 PKCE): https://datatracker.ietf.org/doc/html/rfc7636 RFC8414 (OAuth2 Metadata): https://datatracker.ietf.org/doc/html/rfc8414 OpenID Connect 1.0 specification: https://openid.net/specs/openid-connect-core-1_0.html JWCrypto's library documentation: https://jwcrypto.readthedocs.io/","title":"Resources"},{"location":"self-hosting/environment-variables/","text":"Environment variables \u00b6 Fief server relies heavily on environment variables for configuration. You'll likely need to adjust those settings for your deployment. Set environment variables \u00b6 Using docker run \u00b6 When running Fief server with Docker, the most straightforward way is to use the -e option on the command line, as shown in the Quickstart section. docker run \\ --name fief-server \\ -p 8000 :8000 -d \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ ghcr.io/fief-dev/fief:latest However, it may become hard to maintain when having lot of variables to set. An alternative way is to use a .env file. It's a simple file where each line consists of a key and a value separated by an equal sign: .env SECRET = XXX FIEF_CLIENT_ID = XXX FIEF_CLIENT_SECRET = XXX ENCRYPTION_KEY = XXX Then, you can reference this file in the Docker command: docker run \\ --name fief-server \\ -p 8000 :8000 -d \\ --env-file .env \\ ghcr.io/fief-dev/fief:latest Using Docker Compose \u00b6 For more complex setups, you may need to configure a Docker Compose file to help you manage all your containers. You can directly define your environment variables in the Compose file. You'll find below an example of a Docker Compose file to run the Fief server. docker-compose.yml version : \"3.9\" services : fief : image : ghcr.io/fief-dev/fief:latest ports : - \"8000:8000\" environment : - SECRET=XXX - FIEF_CLIENT_ID=XXX - FIEF_CLIENT_SECRET=XXX - ENCRYPTION_KEY=XXX Reference \u00b6 For each variable, we'll try to provide a sensible example value to help you configure it correctly. Throughout the examples, we'll assume that you host your Fief server on the sub-domain fief.bretagne.duchy . General \u00b6 Name Description Default Allowed values Example ENVIRONMENT Name of the deployment environment development development, staging, production production LOG_LEVEL Log verbosity DEBUG DEBUG, INFO, WARNING, ERROR INFO ROOT_DOMAIN Root domain where your server will be running. Mainly used for generating workspace subdomains. localhost:8000 bretagne.duchy ALLOW_ORIGIN_REGEX Regex used to control CORS access to your API http://.*localhost:[0-9]+ https://.*\\.bretagne.duchy Secrets \u00b6 Name Description Default Allowed values Example SECRET Secret value used to sign reset password tokens. Any sufficiently long string ENCRYPTION_KEY Key used to encrypt the external databases credentials inside the main database A valid Fernet key encoded in UTF-8 Database \u00b6 Name Description Default Allowed values Example DATABASE_TYPE Type of the main database SQLITE POSTGRESQL, MYSQL, SQLITE POSTGRESQL DATABASE_HOST Host of the main database localhost DATABASE_PORT Listening port of the main database 5432 DATABASE_USERNAME Main database user fief DATABASE_PASSWORD Main database user's password fiefpassword DATABASE_NAME Main database name fief.db fief DATABASE_LOCATION For SQLite databases, path where to store the database files Current working directory DATABASE_URL Full database connection string, useful for some cloud providers. It'll take precedence over the single parameters above. More details about how to setup a database in the dedicated section. Setup database Redis \u00b6 We use a Redis instance to manage background jobs (send emails, heavy computations...). A Redis instance is already up-and-running in the official Docker image, but you can provide your own one if needed. Name Description Default Allowed values Example REDIS_URL URL of a Redis server redis://localhost:6379 Email provider \u00b6 Name Description Default Allowed values Example EMAIL_PROVIDER Type of email provider NULL NULL, POSTMARK POSTMARK EMAIL_PROVIDER_PARAMS Configuration dictionary of the email provider {} {\"server_token\": \"XXX-XXX\"} More details about how to setup an email provider in the dedicated section. Setup email provider CSRF cookie \u00b6 To protect against Cross-Site-Request-Forgery attacks on authentication pages, we use the double-submit cookie pattern. Name Description Default Allowed values Example CSRF_COOKIE_NAME Name of the CSRF token cookie fief_csrftoken CSRF_COOKIE_SECURE Secure flag of the login session cookie True Login session \u00b6 A login session is a cookie used to maintain the state of the login flow of a user, from the login page until they're redirected to your application. Name Description Default Allowed values Example LOGIN_SESSION_COOKIE_NAME Name of the login session cookie fief_login_session LOGIN_SESSION_COOKIE_DOMAIN Domain of the login session cookie Empty string LOGIN_SESSION_COOKIE_SECURE Secure flag of the login session cookie True Session \u00b6 A session is a cookie used to maintain the session of a user on the Fief authentication pages . It's different from the session you'll maintain in your own application. Its purpose is to allow a user to re-authenticate quickly to your app without having them to input their credentials again. Name Description Default Allowed values Example SESSION_COOKIE_NAME Name of the session cookie fief_session SESSION_COOKIE_DOMAIN Domain of the session cookie Empty string SESSION_COOKIE_SECURE Secure flag of the session cookie True SESSION_LIFETIME_SECONDS Lifetime of the session cookie in seconds 86400 * 30 (30 days ) Authorization code \u00b6 Authorization codes are temporary codes generated during the OAuth2 authentication flow . Name Description Default Allowed values Example AUTHORIZATION_CODE_LIFETIME_SECONDS Lifetime of the authorization code in seconds. For security reasons, this value should remain low. OAuth2 specification recommends a value of 10 minutes . 600 (10 minutes) Fief-ception \u00b6 Fief-ception is a mind-fucking concept describing the fact that we actually use Fief to authenticate Fief users to the app \ud83e\udd2f That's why we necessarily need to create a first workspace and an admin user before being able to use Fief, as described in the Quickstart section. The variables below are here to configure the Fief server with a proper Fief client, as you would do in your own application! Name Description Default Allowed values Example FIEF_DOMAIN Domain of your main Fief workspace localhost:8000 fief.bretagne.duchy FIEF_BASE_URL URL of the main Fief workspace. It calls itself! http://localhost:8000 https://fief.bretagne.duchy FIEF_CLIENT_ID Client ID in your main Fief workspace FIEF_CLIENT_SECRET Client secret in your main Fief workspace FIEF_ENCRYPTION_KEY Optional RSA key used to encrypt the JWT tokens Admin session \u00b6 An admin session is a cookie used to maintain the session of a user on the Fief admin dashboard. Name Description Default Allowed values Example FIEF_ADMIN_SESSION_COOKIE_NAME Name of the admin session cookie fief_admin_session FIEF_ADMIN_SESSION_COOKIE_DOMAIN Domain of the admin session cookie Empty string FIEF_ADMIN_SESSION_COOKIE_SECURE Secure flag of the admin session cookie True","title":"Environment variables"},{"location":"self-hosting/environment-variables/#environment-variables","text":"Fief server relies heavily on environment variables for configuration. You'll likely need to adjust those settings for your deployment.","title":"Environment variables"},{"location":"self-hosting/environment-variables/#set-environment-variables","text":"","title":"Set environment variables"},{"location":"self-hosting/environment-variables/#using-docker-run","text":"When running Fief server with Docker, the most straightforward way is to use the -e option on the command line, as shown in the Quickstart section. docker run \\ --name fief-server \\ -p 8000 :8000 -d \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ ghcr.io/fief-dev/fief:latest However, it may become hard to maintain when having lot of variables to set. An alternative way is to use a .env file. It's a simple file where each line consists of a key and a value separated by an equal sign: .env SECRET = XXX FIEF_CLIENT_ID = XXX FIEF_CLIENT_SECRET = XXX ENCRYPTION_KEY = XXX Then, you can reference this file in the Docker command: docker run \\ --name fief-server \\ -p 8000 :8000 -d \\ --env-file .env \\ ghcr.io/fief-dev/fief:latest","title":"Using docker run"},{"location":"self-hosting/environment-variables/#using-docker-compose","text":"For more complex setups, you may need to configure a Docker Compose file to help you manage all your containers. You can directly define your environment variables in the Compose file. You'll find below an example of a Docker Compose file to run the Fief server. docker-compose.yml version : \"3.9\" services : fief : image : ghcr.io/fief-dev/fief:latest ports : - \"8000:8000\" environment : - SECRET=XXX - FIEF_CLIENT_ID=XXX - FIEF_CLIENT_SECRET=XXX - ENCRYPTION_KEY=XXX","title":"Using Docker Compose"},{"location":"self-hosting/environment-variables/#reference","text":"For each variable, we'll try to provide a sensible example value to help you configure it correctly. Throughout the examples, we'll assume that you host your Fief server on the sub-domain fief.bretagne.duchy .","title":"Reference"},{"location":"self-hosting/environment-variables/#general","text":"Name Description Default Allowed values Example ENVIRONMENT Name of the deployment environment development development, staging, production production LOG_LEVEL Log verbosity DEBUG DEBUG, INFO, WARNING, ERROR INFO ROOT_DOMAIN Root domain where your server will be running. Mainly used for generating workspace subdomains. localhost:8000 bretagne.duchy ALLOW_ORIGIN_REGEX Regex used to control CORS access to your API http://.*localhost:[0-9]+ https://.*\\.bretagne.duchy","title":"General"},{"location":"self-hosting/environment-variables/#secrets","text":"Name Description Default Allowed values Example SECRET Secret value used to sign reset password tokens. Any sufficiently long string ENCRYPTION_KEY Key used to encrypt the external databases credentials inside the main database A valid Fernet key encoded in UTF-8","title":"Secrets"},{"location":"self-hosting/environment-variables/#database","text":"Name Description Default Allowed values Example DATABASE_TYPE Type of the main database SQLITE POSTGRESQL, MYSQL, SQLITE POSTGRESQL DATABASE_HOST Host of the main database localhost DATABASE_PORT Listening port of the main database 5432 DATABASE_USERNAME Main database user fief DATABASE_PASSWORD Main database user's password fiefpassword DATABASE_NAME Main database name fief.db fief DATABASE_LOCATION For SQLite databases, path where to store the database files Current working directory DATABASE_URL Full database connection string, useful for some cloud providers. It'll take precedence over the single parameters above. More details about how to setup a database in the dedicated section. Setup database","title":"Database"},{"location":"self-hosting/environment-variables/#redis","text":"We use a Redis instance to manage background jobs (send emails, heavy computations...). A Redis instance is already up-and-running in the official Docker image, but you can provide your own one if needed. Name Description Default Allowed values Example REDIS_URL URL of a Redis server redis://localhost:6379","title":"Redis"},{"location":"self-hosting/environment-variables/#email-provider","text":"Name Description Default Allowed values Example EMAIL_PROVIDER Type of email provider NULL NULL, POSTMARK POSTMARK EMAIL_PROVIDER_PARAMS Configuration dictionary of the email provider {} {\"server_token\": \"XXX-XXX\"} More details about how to setup an email provider in the dedicated section. Setup email provider","title":"Email provider"},{"location":"self-hosting/environment-variables/#csrf-cookie","text":"To protect against Cross-Site-Request-Forgery attacks on authentication pages, we use the double-submit cookie pattern. Name Description Default Allowed values Example CSRF_COOKIE_NAME Name of the CSRF token cookie fief_csrftoken CSRF_COOKIE_SECURE Secure flag of the login session cookie True","title":"CSRF cookie"},{"location":"self-hosting/environment-variables/#login-session","text":"A login session is a cookie used to maintain the state of the login flow of a user, from the login page until they're redirected to your application. Name Description Default Allowed values Example LOGIN_SESSION_COOKIE_NAME Name of the login session cookie fief_login_session LOGIN_SESSION_COOKIE_DOMAIN Domain of the login session cookie Empty string LOGIN_SESSION_COOKIE_SECURE Secure flag of the login session cookie True","title":"Login session"},{"location":"self-hosting/environment-variables/#session","text":"A session is a cookie used to maintain the session of a user on the Fief authentication pages . It's different from the session you'll maintain in your own application. Its purpose is to allow a user to re-authenticate quickly to your app without having them to input their credentials again. Name Description Default Allowed values Example SESSION_COOKIE_NAME Name of the session cookie fief_session SESSION_COOKIE_DOMAIN Domain of the session cookie Empty string SESSION_COOKIE_SECURE Secure flag of the session cookie True SESSION_LIFETIME_SECONDS Lifetime of the session cookie in seconds 86400 * 30 (30 days )","title":"Session"},{"location":"self-hosting/environment-variables/#authorization-code","text":"Authorization codes are temporary codes generated during the OAuth2 authentication flow . Name Description Default Allowed values Example AUTHORIZATION_CODE_LIFETIME_SECONDS Lifetime of the authorization code in seconds. For security reasons, this value should remain low. OAuth2 specification recommends a value of 10 minutes . 600 (10 minutes)","title":"Authorization code"},{"location":"self-hosting/environment-variables/#fief-ception","text":"Fief-ception is a mind-fucking concept describing the fact that we actually use Fief to authenticate Fief users to the app \ud83e\udd2f That's why we necessarily need to create a first workspace and an admin user before being able to use Fief, as described in the Quickstart section. The variables below are here to configure the Fief server with a proper Fief client, as you would do in your own application! Name Description Default Allowed values Example FIEF_DOMAIN Domain of your main Fief workspace localhost:8000 fief.bretagne.duchy FIEF_BASE_URL URL of the main Fief workspace. It calls itself! http://localhost:8000 https://fief.bretagne.duchy FIEF_CLIENT_ID Client ID in your main Fief workspace FIEF_CLIENT_SECRET Client secret in your main Fief workspace FIEF_ENCRYPTION_KEY Optional RSA key used to encrypt the JWT tokens","title":"Fief-ception"},{"location":"self-hosting/environment-variables/#admin-session","text":"An admin session is a cookie used to maintain the session of a user on the Fief admin dashboard. Name Description Default Allowed values Example FIEF_ADMIN_SESSION_COOKIE_NAME Name of the admin session cookie fief_admin_session FIEF_ADMIN_SESSION_COOKIE_DOMAIN Domain of the admin session cookie Empty string FIEF_ADMIN_SESSION_COOKIE_SECURE Secure flag of the admin session cookie True","title":"Admin session"},{"location":"self-hosting/quickstart/","text":"Quickstart \u00b6 We provide a Docker image to help you start the Fief server locally in no time! Run the following command: docker run --rm ghcr.io/fief-dev/fief:latest fief quickstart --docker The result of this command is a complete docker run command with the required secrets generated to help you get started. It'll look like the following: docker run \\ --name fief-server \\ -p 8000 :8000 -d \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ ghcr.io/fief-dev/fief:latest Save those secrets somewhere safe! If you need restart or recreate your container, you'll probably need to set the same secrets again. If you lose them, you'll likely lose access to data or have a bad configuration. Read more about secrets and environment variables. Info The container is exposed on the port 8000 of your local machine by default, but you can set any port you want. Create main workspace \u00b6 Next, you'll need to create the main workspace . Simply run the following command: docker exec fief-server fief create-main-workspace You should see the following output: Main Fief workspace created Create admin user \u00b6 Finally, you need to create an admin user for this main workspace that'll have access to the admin dashboard. Run the following command: docker exec -it fief-server fief create-main-user --user-email anne@bretagne.duchy Tip Of course, make sure to replace --user-email value with your own email address! You'll then be prompted for a password. If everything goes well, you should see the following output: Main Fief user created Good to go! \u00b6 At this point, your Fief server should be up-and-running! Open http://localhost:8000/admin/ to access the admin dashboard. You'll be redirected to a login page. Authenticate with the user credentials you created in the previous section. You'll then be redirected to the admin dashboard. Congratulations! Your Fief server instance is up-and-running \ud83c\udf89 You can now try Fief features and start to integrate authentication in your app. Tip For production deployment, we strongly recommend you to read the next sections. Limitations \u00b6 While quick and convenient, this way of running Fief is not suitable for production environments . Under the hood, it stores the data in the form of SQLite databases . If you ever happen to destroy your container, you'll lose all your data. The best way is of course to configure a proper PostgreSQL or MySQL database for your Fief server, as described in the dedicated section. Setup database Use a Docker volume to persist SQLite data \u00b6 If you really want to use SQLite, or mitigate the risk of losing data in your local environment, you can attach your container to a Docker volume . This way, even if the container is destroyed, you can create a new one and attach again the data. The first thing to do is to create a Docker volume: docker volume create fief-server-data Then, create your Fief server container and attach this volume to the /data folder on the container: docker run \\ --name fief-server \\ -p 8000 :8000 -d \\ -v fief-server-volume:/data \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ ghcr.io/fief-dev/fief:latest Warning If you created your container with the instructions in the previous section, you'll need to recreate one from scratch to bind the volume.","title":"Quickstart"},{"location":"self-hosting/quickstart/#quickstart","text":"We provide a Docker image to help you start the Fief server locally in no time! Run the following command: docker run --rm ghcr.io/fief-dev/fief:latest fief quickstart --docker The result of this command is a complete docker run command with the required secrets generated to help you get started. It'll look like the following: docker run \\ --name fief-server \\ -p 8000 :8000 -d \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ ghcr.io/fief-dev/fief:latest Save those secrets somewhere safe! If you need restart or recreate your container, you'll probably need to set the same secrets again. If you lose them, you'll likely lose access to data or have a bad configuration. Read more about secrets and environment variables. Info The container is exposed on the port 8000 of your local machine by default, but you can set any port you want.","title":"Quickstart"},{"location":"self-hosting/quickstart/#create-main-workspace","text":"Next, you'll need to create the main workspace . Simply run the following command: docker exec fief-server fief create-main-workspace You should see the following output: Main Fief workspace created","title":"Create main workspace"},{"location":"self-hosting/quickstart/#create-admin-user","text":"Finally, you need to create an admin user for this main workspace that'll have access to the admin dashboard. Run the following command: docker exec -it fief-server fief create-main-user --user-email anne@bretagne.duchy Tip Of course, make sure to replace --user-email value with your own email address! You'll then be prompted for a password. If everything goes well, you should see the following output: Main Fief user created","title":"Create admin user"},{"location":"self-hosting/quickstart/#good-to-go","text":"At this point, your Fief server should be up-and-running! Open http://localhost:8000/admin/ to access the admin dashboard. You'll be redirected to a login page. Authenticate with the user credentials you created in the previous section. You'll then be redirected to the admin dashboard. Congratulations! Your Fief server instance is up-and-running \ud83c\udf89 You can now try Fief features and start to integrate authentication in your app. Tip For production deployment, we strongly recommend you to read the next sections.","title":"Good to go!"},{"location":"self-hosting/quickstart/#limitations","text":"While quick and convenient, this way of running Fief is not suitable for production environments . Under the hood, it stores the data in the form of SQLite databases . If you ever happen to destroy your container, you'll lose all your data. The best way is of course to configure a proper PostgreSQL or MySQL database for your Fief server, as described in the dedicated section. Setup database","title":"Limitations"},{"location":"self-hosting/quickstart/#use-a-docker-volume-to-persist-sqlite-data","text":"If you really want to use SQLite, or mitigate the risk of losing data in your local environment, you can attach your container to a Docker volume . This way, even if the container is destroyed, you can create a new one and attach again the data. The first thing to do is to create a Docker volume: docker volume create fief-server-data Then, create your Fief server container and attach this volume to the /data folder on the container: docker run \\ --name fief-server \\ -p 8000 :8000 -d \\ -v fief-server-volume:/data \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ ghcr.io/fief-dev/fief:latest Warning If you created your container with the instructions in the previous section, you'll need to recreate one from scratch to bind the volume.","title":"Use a Docker volume to persist SQLite data"},{"location":"self-hosting/setup-database/","text":"Setup database \u00b6 For production environments, your Fief server should store its data in a proper database server for better performance and reliability. Fief is compatible with PostgreSQL and MySQL databases. Setup PostgreSQL \u00b6 We'll assume that you have a working PostgreSQL database running, either locally or in the cloud. All you need to do is to set the corresponding environment variables with your database credentials. DATABASE_TYPE = POSTGRESQL DATABASE_HOST = localhost DATABASE_PORT = 5432 DATABASE_USERNAME = fief DATABASE_PASSWORD = fiefpassword DATABASE_NAME = fief Tip You can read about different ways of setting environment variables in the dedicated section . Setup MySQL \u00b6 We'll assume that you have a working MySQL database running, either locally or in the cloud. All you need to do is to set the corresponding environment variables with your database credentials. DATABASE_TYPE = MYSQL DATABASE_HOST = localhost DATABASE_PORT = 3306 DATABASE_USERNAME = fief DATABASE_PASSWORD = fiefpassword DATABASE_NAME = fief Tip You can read about different ways of setting environment variables in the dedicated section . Use a connection string \u00b6 Some cloud providers like Heroku will provide you a full database connection string like the one below instead of each parts separately: postgresql://fief:fiefpassword@localhost:5432/fief Fief supports this kind of configuration with the DATABASE_URL environment variable. DATABASE_TYPE = POSTGRESQL DATABASE_URL = postgresql://fief:fiefpassword@localhost:5432/fief Warning This variable will always take precedence over the single parameters: if you define DATABASE_URL , it'll use this variable to connect to your database, even if other parameters are defined. Create main workspace and admin user \u00b6 Once your database is configured, don't forget to create the main workspace and admin user, as described in the Quickstart section.","title":"Setup database"},{"location":"self-hosting/setup-database/#setup-database","text":"For production environments, your Fief server should store its data in a proper database server for better performance and reliability. Fief is compatible with PostgreSQL and MySQL databases.","title":"Setup database"},{"location":"self-hosting/setup-database/#setup-postgresql","text":"We'll assume that you have a working PostgreSQL database running, either locally or in the cloud. All you need to do is to set the corresponding environment variables with your database credentials. DATABASE_TYPE = POSTGRESQL DATABASE_HOST = localhost DATABASE_PORT = 5432 DATABASE_USERNAME = fief DATABASE_PASSWORD = fiefpassword DATABASE_NAME = fief Tip You can read about different ways of setting environment variables in the dedicated section .","title":"Setup PostgreSQL"},{"location":"self-hosting/setup-database/#setup-mysql","text":"We'll assume that you have a working MySQL database running, either locally or in the cloud. All you need to do is to set the corresponding environment variables with your database credentials. DATABASE_TYPE = MYSQL DATABASE_HOST = localhost DATABASE_PORT = 3306 DATABASE_USERNAME = fief DATABASE_PASSWORD = fiefpassword DATABASE_NAME = fief Tip You can read about different ways of setting environment variables in the dedicated section .","title":"Setup MySQL"},{"location":"self-hosting/setup-database/#use-a-connection-string","text":"Some cloud providers like Heroku will provide you a full database connection string like the one below instead of each parts separately: postgresql://fief:fiefpassword@localhost:5432/fief Fief supports this kind of configuration with the DATABASE_URL environment variable. DATABASE_TYPE = POSTGRESQL DATABASE_URL = postgresql://fief:fiefpassword@localhost:5432/fief Warning This variable will always take precedence over the single parameters: if you define DATABASE_URL , it'll use this variable to connect to your database, even if other parameters are defined.","title":"Use a connection string"},{"location":"self-hosting/setup-database/#create-main-workspace-and-admin-user","text":"Once your database is configured, don't forget to create the main workspace and admin user, as described in the Quickstart section.","title":"Create main workspace and admin user"},{"location":"self-hosting/setup-email-provider/","text":"Setup email provider \u00b6 As you surely now, users management imply a lot of transactional emails, like welcome emails or reset password emails. To be able to send them, Fief needs an email provider. Currently, Fief only supports Postmark , one of the leading email delivery service on the market, but we may support more in the future. There are two environment variables to configure the email provider: EMAIL_PROVIDER , to set the type of provider and EMAIL_PROVIDER_PARAMS , a configuration dictionary containing required configuration keys. NULL provider \u00b6 The NULL provider is the default one if you don't set any. It means that no transactional email will be sent . EMAIL_PROVIDER = NULL Postmark provider \u00b6 Postmark provider will send transactional emails using Postmark . Parameter Description server_token Your Postmark Server API token EMAIL_PROVIDER = POSTMARK EMAIL_PROVIDER_PARAMS = {\"server_token\": \"XXX-XXX\"} Tip You can read about different ways of setting environment variables in the dedicated section .","title":"Setup email provider"},{"location":"self-hosting/setup-email-provider/#setup-email-provider","text":"As you surely now, users management imply a lot of transactional emails, like welcome emails or reset password emails. To be able to send them, Fief needs an email provider. Currently, Fief only supports Postmark , one of the leading email delivery service on the market, but we may support more in the future. There are two environment variables to configure the email provider: EMAIL_PROVIDER , to set the type of provider and EMAIL_PROVIDER_PARAMS , a configuration dictionary containing required configuration keys.","title":"Setup email provider"},{"location":"self-hosting/setup-email-provider/#null-provider","text":"The NULL provider is the default one if you don't set any. It means that no transactional email will be sent . EMAIL_PROVIDER = NULL","title":"NULL provider"},{"location":"self-hosting/setup-email-provider/#postmark-provider","text":"Postmark provider will send transactional emails using Postmark . Parameter Description server_token Your Postmark Server API token EMAIL_PROVIDER = POSTMARK EMAIL_PROVIDER_PARAMS = {\"server_token\": \"XXX-XXX\"} Tip You can read about different ways of setting environment variables in the dedicated section .","title":"Postmark provider"}]}