{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is Fief? \u00b6 Fief is an open-source platform to manage users and authentication in your applications. Our goal is to help you manage users and security in a matter of minutes, not days. Key features: Pre-built login and registration pages Users management dashboard SDK for the most popular languages and frameworks Integrations for the most popular no-code tools Bring Your Own Database : you can connect to any SQL database so you keep entire control of your data Cloud vs Self-hosted \u00b6 We are offering two ways of using Fief: Cloud : fair-priced hosted instance, maintained by the Fief's team; Self-hosted : you host the service yourself on your own infrastructure, for free. Project roadmap \u00b6 Fief is a young project and still has many features to implement and room for improvements! What we have now? \u00b6 User registration User authentication using OAuth2 and OpenID Connect protocols Forgot password process Bring your own database Custom user fields Roles and permissions access control Official Docker image for self-hosting Official Python client with FastAPI and Flask integrations Official JavaScript client with browser and React integrations Admin dashboard ID Token encryption support PKCE support What we'll have in the future? \u00b6 Custom API scopes Customizable transactional emails Social authentication (Google, Facebook...) 2FA authentication with authenticator apps and U2F keys Official NodeJS Express integration Official Bubble integration ...and more \ud83d\ude80 View the project backlog","title":"What is Fief?"},{"location":"#what-is-fief","text":"Fief is an open-source platform to manage users and authentication in your applications. Our goal is to help you manage users and security in a matter of minutes, not days. Key features: Pre-built login and registration pages Users management dashboard SDK for the most popular languages and frameworks Integrations for the most popular no-code tools Bring Your Own Database : you can connect to any SQL database so you keep entire control of your data","title":"What is Fief?"},{"location":"#cloud-vs-self-hosted","text":"We are offering two ways of using Fief: Cloud : fair-priced hosted instance, maintained by the Fief's team; Self-hosted : you host the service yourself on your own infrastructure, for free.","title":"Cloud vs Self-hosted"},{"location":"#project-roadmap","text":"Fief is a young project and still has many features to implement and room for improvements!","title":"Project roadmap"},{"location":"#what-we-have-now","text":"User registration User authentication using OAuth2 and OpenID Connect protocols Forgot password process Bring your own database Custom user fields Roles and permissions access control Official Docker image for self-hosting Official Python client with FastAPI and Flask integrations Official JavaScript client with browser and React integrations Admin dashboard ID Token encryption support PKCE support","title":"What we have now?"},{"location":"#what-well-have-in-the-future","text":"Custom API scopes Customizable transactional emails Social authentication (Google, Facebook...) 2FA authentication with authenticator apps and U2F keys Official NodeJS Express integration Official Bubble integration ...and more \ud83d\ude80 View the project backlog","title":"What we'll have in the future?"},{"location":"getting-started/access-control/","text":"Access control \u00b6 This is where you'll see and manage the permissions and roles of your workspace. What are permissions and roles? Permissions are a way to list the actions a user will be allowed to perform in your application. For example, if you have a resource in your application called Castle , we can define the permissions Read Castle and Create Castle . Then, those permissions can be assigned to users . You'll then be able to control this list of permissions in your app to determine if the current user is able to perform the action they request. Assigning permissions directly to users can be tedious and error-prone. To help with this, Fief also supports the concept of Roles . A role consists of a set of permissions . Following our previous example, we can imagine to have the roles Castle Visitor , which only have the Read Castle permission and a Castle Manager role, which have both Read Castle and Create Castle permissions. Those roles can also be assigned to users . Then, they'll be automatically granted with the set of associated permissions . The good thing is that if you modify a role to add or remove permissions, it'll be automatically be passed on every users with this role. Said another way, it's a way to easily organize and assing permissions. Permissions \u00b6 The first item in the menu is the permissions page, showing you a list of all your permissions. Create a new permission \u00b6 To create a new permission, fill the fields above the list: the name and the codename of your permission. The codename is what will be used to identify your permission in the access tokens. It must be unique across your workspace . Submit the form by clicking on Create Permission . The newly created permission will appear in the list. Naming your permissions You are completely free to choose the name and codenames you wish for your permissions. However, we suggest you to establish a convention so it'll be easy for you and your teams to remember them. Typically, you'll have a common set of actions (read, create, update, delete...) for each resources (Post, Product, Meeting...) in your app. A common practice is to prefix the codename with the name of the resource and append the corresponding action: post:read , post:create , post:update ... Delete a permission \u00b6 If one of your permission is not useful anymore, you can delete it by clicking on the Delete button in the list. The permission will be removed from all the associated roles and users When you delete a permission, it'll be removed from all the roles associated to this permission and all the users who were granted this permission. Before deleting it, make sure you don't need it anymore in your application. Roles \u00b6 The second item in the menu is the roles page, showing you a list of all your roles. Create a new role \u00b6 You can create a new role by clicking the Create Role button. A modal will open where you'll be able to input its name, if it's granted by default and its list of associated permissions. Edit an existing role \u00b6 If you click on one of the role in the list, you'll see its details on the right. You'll be able to edit its name, granted by default option and associated permissions. Permissions are automatically propagated to users with this role If you add or remove a permission from a role, the permissions of the users having this role will also be updated accordingly. Delete a role \u00b6 If one of your role is not useful anymore, you can delete it by clicking on it on the list and click on the Delete button on the right. The role will be removed from all the associated users When you delete a role, it'll be removed from all the users who were granted this role. Before deleting it, make sure you don't need it anymore in your application. Granted by default \u00b6 When you mark a role as Granted by default , it'll be automatically assigned to new users upon their registration. It's especially useful if you need your users to be able to perform basic actions directly on signup.","title":"Access control"},{"location":"getting-started/access-control/#access-control","text":"This is where you'll see and manage the permissions and roles of your workspace. What are permissions and roles? Permissions are a way to list the actions a user will be allowed to perform in your application. For example, if you have a resource in your application called Castle , we can define the permissions Read Castle and Create Castle . Then, those permissions can be assigned to users . You'll then be able to control this list of permissions in your app to determine if the current user is able to perform the action they request. Assigning permissions directly to users can be tedious and error-prone. To help with this, Fief also supports the concept of Roles . A role consists of a set of permissions . Following our previous example, we can imagine to have the roles Castle Visitor , which only have the Read Castle permission and a Castle Manager role, which have both Read Castle and Create Castle permissions. Those roles can also be assigned to users . Then, they'll be automatically granted with the set of associated permissions . The good thing is that if you modify a role to add or remove permissions, it'll be automatically be passed on every users with this role. Said another way, it's a way to easily organize and assing permissions.","title":"Access control"},{"location":"getting-started/access-control/#permissions","text":"The first item in the menu is the permissions page, showing you a list of all your permissions.","title":"Permissions"},{"location":"getting-started/access-control/#create-a-new-permission","text":"To create a new permission, fill the fields above the list: the name and the codename of your permission. The codename is what will be used to identify your permission in the access tokens. It must be unique across your workspace . Submit the form by clicking on Create Permission . The newly created permission will appear in the list. Naming your permissions You are completely free to choose the name and codenames you wish for your permissions. However, we suggest you to establish a convention so it'll be easy for you and your teams to remember them. Typically, you'll have a common set of actions (read, create, update, delete...) for each resources (Post, Product, Meeting...) in your app. A common practice is to prefix the codename with the name of the resource and append the corresponding action: post:read , post:create , post:update ...","title":"Create a new permission"},{"location":"getting-started/access-control/#delete-a-permission","text":"If one of your permission is not useful anymore, you can delete it by clicking on the Delete button in the list. The permission will be removed from all the associated roles and users When you delete a permission, it'll be removed from all the roles associated to this permission and all the users who were granted this permission. Before deleting it, make sure you don't need it anymore in your application.","title":"Delete a permission"},{"location":"getting-started/access-control/#roles","text":"The second item in the menu is the roles page, showing you a list of all your roles.","title":"Roles"},{"location":"getting-started/access-control/#create-a-new-role","text":"You can create a new role by clicking the Create Role button. A modal will open where you'll be able to input its name, if it's granted by default and its list of associated permissions.","title":"Create a new role"},{"location":"getting-started/access-control/#edit-an-existing-role","text":"If you click on one of the role in the list, you'll see its details on the right. You'll be able to edit its name, granted by default option and associated permissions. Permissions are automatically propagated to users with this role If you add or remove a permission from a role, the permissions of the users having this role will also be updated accordingly.","title":"Edit an existing role"},{"location":"getting-started/access-control/#delete-a-role","text":"If one of your role is not useful anymore, you can delete it by clicking on it on the list and click on the Delete button on the right. The role will be removed from all the associated users When you delete a role, it'll be removed from all the users who were granted this role. Before deleting it, make sure you don't need it anymore in your application.","title":"Delete a role"},{"location":"getting-started/access-control/#granted-by-default","text":"When you mark a role as Granted by default , it'll be automatically assigned to new users upon their registration. It's especially useful if you need your users to be able to perform basic actions directly on signup.","title":"Granted by default"},{"location":"getting-started/admin-dashboard/","text":"Admin dashboard \u00b6 The admin dashboard is the interface where you'll be able to manage your Fief workspace and configuration. The left menu lets you access to the most important aspects of Fief: Tenants Clients Users User fields API Keys Switch workspace \u00b6 If your account is linked to several workspaces, you can switch to another workspace using the menu on the top-right.","title":"Admin dashboard"},{"location":"getting-started/admin-dashboard/#admin-dashboard","text":"The admin dashboard is the interface where you'll be able to manage your Fief workspace and configuration. The left menu lets you access to the most important aspects of Fief: Tenants Clients Users User fields API Keys","title":"Admin dashboard"},{"location":"getting-started/admin-dashboard/#switch-workspace","text":"If your account is linked to several workspaces, you can switch to another workspace using the menu on the top-right.","title":"Switch workspace"},{"location":"getting-started/api-keys/","text":"API Keys \u00b6 This is where you'll see and manage the api keys of your workspace. What is an API key? An API key is a secret token that'll allow you to make authenticated requests to the Fief Admin API . It'll be useful if you need, for example, to manage tenants or clients programmatically from your own application. Keep it secret and safe An API key gives complete accesss to your workspace data. Keep it somewhere safe and don't share it with anyone. Create a new API Key \u00b6 To create a new API Key, click on the Create API Key button. A modal will open where you'll be able to input the name of the API Key. Choose a name that'll help you remember where and how it's used. When you submit the form, a new modal will open with the actual API key token . For security reasons, it'll be shown only once . Copy and paste it somewhere safe before closing the modal. Delete an API Key \u00b6 If one of your API Key is not useful anymore, you can delete it by clicking on the Delete button in the list.","title":"API Keys"},{"location":"getting-started/api-keys/#api-keys","text":"This is where you'll see and manage the api keys of your workspace. What is an API key? An API key is a secret token that'll allow you to make authenticated requests to the Fief Admin API . It'll be useful if you need, for example, to manage tenants or clients programmatically from your own application. Keep it secret and safe An API key gives complete accesss to your workspace data. Keep it somewhere safe and don't share it with anyone.","title":"API Keys"},{"location":"getting-started/api-keys/#create-a-new-api-key","text":"To create a new API Key, click on the Create API Key button. A modal will open where you'll be able to input the name of the API Key. Choose a name that'll help you remember where and how it's used. When you submit the form, a new modal will open with the actual API key token . For security reasons, it'll be shown only once . Copy and paste it somewhere safe before closing the modal.","title":"Create a new API Key"},{"location":"getting-started/api-keys/#delete-an-api-key","text":"If one of your API Key is not useful anymore, you can delete it by clicking on the Delete button in the list.","title":"Delete an API Key"},{"location":"getting-started/clients/","text":"Clients \u00b6 This is where you'll see and manage the clients of your workspace. What is a client? A client is a central part of the OAuth2 protocol. It's the definition of an application authorized to request for access tokens and user information on Fief. In other words, your application will need one of those client to be able to authenticate users from your Fief workspace. Each client has a Client ID and a Client Secret. Those values are used during OAuth2 authentification to recognize the client. Each workspace comes with one client, tied to the default tenant . View client details \u00b6 If you click on one of the client in the list, you'll see its details on the right. Especially, you'll be able to copy its ID and Secret by using the clipboard buttons. Create a new client \u00b6 You can create a new client by clicking the Create Client button. A modal will open where you'll be able to input its name, if it's a first-party, its type, its redirect URIs and its associated tenant. When should I create a new client? If you have several applications authenticating to your Fief workspace, you should consider creating new clients. Typically, if you have both a web and a mobile application, it's usually a good idea to have a client for each one. This way, it's easier to track down where the tokens come from and mitigates the risk of compromising data if one of the application has a security breach. Edit an existing client \u00b6 You can edit an existing client by opening its details and click on the Edit Client button. A modal will open where you'll be able to change its name, if it's a first-party its type and its redirect URIs. First-party clients \u00b6 You probably noticed that your first client has a first-party badge. It means that this client is intended to be used by your own, official application. In this context, when users log in to your application, the traditional OAuth2 consent screen is bypassed . Since you are the developer of the application, it makes sense to not ask the user for their consent to use their data on the same application! For third-party applications, like developers from another company who want to integrate your API in their product, you'll provide them a client without this first-party flag. In this context, we want the user consent to be explicit. Client type \u00b6 OAuth2 protocol defines two types of clients, depending on the context they will be used. Confidential : clients where we can guarantee the safety of the client secret . It's suitable for server-based applications like Python or NodeJS web applications. Public : clients where the client secret would be exposed to the end-user. It's the case for browser-based JavaScript applications and mobile applications. Public clients \u00b6 For public clients, we consider that the client secret can never be safe. It's indeed fairly easy to find it in the JavaScript source code or in the application package. Therefore, it's recommended to not use it at all in your application . Fief will allow public clients to make token request without the client secret . However, it'll require a PKCE challenge for maximum security. Redirect URIs \u00b6 During an OAuth2 authentication flow , after the user has successfully logged in, Fief will redirect them to your application with a temporary code. At that point, your application will use this temporary code to obtain a valid token. For security reasons, Fief won't allow the user to be redirected to any URI . Instead, you have to explicitly allow every URI you'll need in your applications. For HTTP URIs, they need to use the https scheme; http URL are not allowed. The only exception to this rule is localhost , which can be in http for local development purposes.","title":"Clients"},{"location":"getting-started/clients/#clients","text":"This is where you'll see and manage the clients of your workspace. What is a client? A client is a central part of the OAuth2 protocol. It's the definition of an application authorized to request for access tokens and user information on Fief. In other words, your application will need one of those client to be able to authenticate users from your Fief workspace. Each client has a Client ID and a Client Secret. Those values are used during OAuth2 authentification to recognize the client. Each workspace comes with one client, tied to the default tenant .","title":"Clients"},{"location":"getting-started/clients/#view-client-details","text":"If you click on one of the client in the list, you'll see its details on the right. Especially, you'll be able to copy its ID and Secret by using the clipboard buttons.","title":"View client details"},{"location":"getting-started/clients/#create-a-new-client","text":"You can create a new client by clicking the Create Client button. A modal will open where you'll be able to input its name, if it's a first-party, its type, its redirect URIs and its associated tenant. When should I create a new client? If you have several applications authenticating to your Fief workspace, you should consider creating new clients. Typically, if you have both a web and a mobile application, it's usually a good idea to have a client for each one. This way, it's easier to track down where the tokens come from and mitigates the risk of compromising data if one of the application has a security breach.","title":"Create a new client"},{"location":"getting-started/clients/#edit-an-existing-client","text":"You can edit an existing client by opening its details and click on the Edit Client button. A modal will open where you'll be able to change its name, if it's a first-party its type and its redirect URIs.","title":"Edit an existing client"},{"location":"getting-started/clients/#first-party-clients","text":"You probably noticed that your first client has a first-party badge. It means that this client is intended to be used by your own, official application. In this context, when users log in to your application, the traditional OAuth2 consent screen is bypassed . Since you are the developer of the application, it makes sense to not ask the user for their consent to use their data on the same application! For third-party applications, like developers from another company who want to integrate your API in their product, you'll provide them a client without this first-party flag. In this context, we want the user consent to be explicit.","title":"First-party clients"},{"location":"getting-started/clients/#client-type","text":"OAuth2 protocol defines two types of clients, depending on the context they will be used. Confidential : clients where we can guarantee the safety of the client secret . It's suitable for server-based applications like Python or NodeJS web applications. Public : clients where the client secret would be exposed to the end-user. It's the case for browser-based JavaScript applications and mobile applications.","title":"Client type"},{"location":"getting-started/clients/#public-clients","text":"For public clients, we consider that the client secret can never be safe. It's indeed fairly easy to find it in the JavaScript source code or in the application package. Therefore, it's recommended to not use it at all in your application . Fief will allow public clients to make token request without the client secret . However, it'll require a PKCE challenge for maximum security.","title":"Public clients"},{"location":"getting-started/clients/#redirect-uris","text":"During an OAuth2 authentication flow , after the user has successfully logged in, Fief will redirect them to your application with a temporary code. At that point, your application will use this temporary code to obtain a valid token. For security reasons, Fief won't allow the user to be redirected to any URI . Instead, you have to explicitly allow every URI you'll need in your applications. For HTTP URIs, they need to use the https scheme; http URL are not allowed. The only exception to this rule is localhost , which can be in http for local development purposes.","title":"Redirect URIs"},{"location":"getting-started/introduction/","text":"Introduction \u00b6 Fief is what is usually called an identity provider : it provides and secures user identities to external apps. To allow this, Fief implements the OpenID Connect protocol, an identity layer on top of the well-known OAuth2 protocol . Basically, it describes a secure way for a user to give access to its data to an external app. So, how does everything will fit together? In a nutshell, Fief will store everything about your users data (email address, hashed passwords...) and give you a simple way to authenticate them in your application. graph TD U((User)) A{Your application} subgraph FIEF [Fief] F[Fief API] FL[Login page] FD[(Fief database)] end U -- is not authenticated ----> FL U -- is authenticated ----> A A -- checks user identity on --> F FL -. redirects to .-> A F -- stores users on --> FD Let's get started! \u00b6 The first thing to do is to create your workspace!","title":"Introduction"},{"location":"getting-started/introduction/#introduction","text":"Fief is what is usually called an identity provider : it provides and secures user identities to external apps. To allow this, Fief implements the OpenID Connect protocol, an identity layer on top of the well-known OAuth2 protocol . Basically, it describes a secure way for a user to give access to its data to an external app. So, how does everything will fit together? In a nutshell, Fief will store everything about your users data (email address, hashed passwords...) and give you a simple way to authenticate them in your application. graph TD U((User)) A{Your application} subgraph FIEF [Fief] F[Fief API] FL[Login page] FD[(Fief database)] end U -- is not authenticated ----> FL U -- is authenticated ----> A A -- checks user identity on --> F FL -. redirects to .-> A F -- stores users on --> FD","title":"Introduction"},{"location":"getting-started/introduction/#lets-get-started","text":"The first thing to do is to create your workspace!","title":"Let's get started!"},{"location":"getting-started/oauth2/","text":"Understand OAuth2 \u00b6 Fief uses the OpenID Connect protocol, an identity layer on top of the well-known OAuth2 protocol to securely authenticate users . If you understand the basics of this protocol, you'll better understand how to integrate Fief to your own application. You probably already used OAuth2 before: whenever you use a button like Sign In with Google or Sign In with Facebook on a website, you actually authenticate yourself using the OAuth2 protocol! Authentication flow \u00b6 Schematically, a complete OAuth2 flow looks like this: sequenceDiagram actor U as User participant A as Your app participant F as Fief U->>A: Wants to login A->>U: Redirects to Fief login page U->>F: Authenticates on Fief F->>A: Redirects with a temporary code A->>F: Exchanges the temporary code F->>A: Generates a valid token A->>U: Answers with a valid session You see that we have three actors in this flow: The user Your application that needs to know the authenticated user Fief , which is able to authenticate users and provide their information This flow relies a lot on redirections: The user first tries to access your application. If they're not logged in, they are redirected to the Fief login page. On this login page, the user will input its credentials, typically an email address and a password to authenticate themself. At this point, we don't have a valid user session yet . In traditional applications, after a successful login, we do obtain a valid user session. However, in this context, the application needing the user session, your application, is not the same as the one that provides authentication, Fief. That's why we have an additional step: Fief redirects to your application with a temporary code, called the authorization code . This code is then used by your application to call the Fief API and obtain a valid token in exchange. Finally, your application can save this token somewhere to maintain the user session. The benefit of this approach is that your application never has access to the user credentials: the sensitive and difficult part is handled by Fief. There are other OAuth2 variants OAuth2 proposes several ways to achieve this kind of authentication flow. We showed here the authorization code grant , which is the most widely-used and the default in Fief. Scopes \u00b6 A central part in OAuth2 is the concept of scopes . Basically, it determines what the application will be able to do or not with the user data. For the user, this translates to the famous consent screen : it's a special page after a successful login telling them what the application wants to do with their data. Once the access token is generated, it'll be tied to this specific list of scopes the user has granted. In your application, you'll be able to limit some actions based on those scopes. As we said in introduction, we use the OpenID Connect protocol on top of OAuth2. With this protocol, we always have at least one scope, openid . It's a core scope giving access to the basic information of the user. First-party clients Since you'll use Fief to authenticate users on your own, official application, we introduced the concept of first-party clients. When a user logs in on a client configured as first-party, the consent screen is bypassed and every scopes asked are implicitly granted. You can read more about this in the dedicated section . Limitations In the future, you'll be able to create your own set of scopes in Fief. Access Token and ID Token \u00b6 After a successful authentication flow, your application will get two different tokens: an access token and an ID token . The first one, the access token , is a secret value that'll authenticate the user on your application. It's tied to a specific user and a list of scopes. On the other hand, the ID token is a value containing all the basic information about the authenticated user, like its email and other personal information. It'll be very useful in your application if you need for example to display the email of the current user. For security reasons, both of them have a limited lifetime . At some point, we'll need to make another OAuth2 authentication flow again to retrieve fresh tokens. Those are JWT The access token and the ID token are both generated as JSON Web Tokens (JWT). JWT is a widely-used standard to secure data contained in a standard JSON object. Typically, JWT are cryptographically signed . It means that your application is able to certify that the tokens you get are true and authentic tokens generated by Fief, and not forged by a malicious attacker. This is critical since we use those to authenticate users into your app. The technical details around this are a bit complex but you can read more about on the official JWT documentation .","title":"Understand OAuth2"},{"location":"getting-started/oauth2/#understand-oauth2","text":"Fief uses the OpenID Connect protocol, an identity layer on top of the well-known OAuth2 protocol to securely authenticate users . If you understand the basics of this protocol, you'll better understand how to integrate Fief to your own application. You probably already used OAuth2 before: whenever you use a button like Sign In with Google or Sign In with Facebook on a website, you actually authenticate yourself using the OAuth2 protocol!","title":"Understand OAuth2"},{"location":"getting-started/oauth2/#authentication-flow","text":"Schematically, a complete OAuth2 flow looks like this: sequenceDiagram actor U as User participant A as Your app participant F as Fief U->>A: Wants to login A->>U: Redirects to Fief login page U->>F: Authenticates on Fief F->>A: Redirects with a temporary code A->>F: Exchanges the temporary code F->>A: Generates a valid token A->>U: Answers with a valid session You see that we have three actors in this flow: The user Your application that needs to know the authenticated user Fief , which is able to authenticate users and provide their information This flow relies a lot on redirections: The user first tries to access your application. If they're not logged in, they are redirected to the Fief login page. On this login page, the user will input its credentials, typically an email address and a password to authenticate themself. At this point, we don't have a valid user session yet . In traditional applications, after a successful login, we do obtain a valid user session. However, in this context, the application needing the user session, your application, is not the same as the one that provides authentication, Fief. That's why we have an additional step: Fief redirects to your application with a temporary code, called the authorization code . This code is then used by your application to call the Fief API and obtain a valid token in exchange. Finally, your application can save this token somewhere to maintain the user session. The benefit of this approach is that your application never has access to the user credentials: the sensitive and difficult part is handled by Fief. There are other OAuth2 variants OAuth2 proposes several ways to achieve this kind of authentication flow. We showed here the authorization code grant , which is the most widely-used and the default in Fief.","title":"Authentication flow"},{"location":"getting-started/oauth2/#scopes","text":"A central part in OAuth2 is the concept of scopes . Basically, it determines what the application will be able to do or not with the user data. For the user, this translates to the famous consent screen : it's a special page after a successful login telling them what the application wants to do with their data. Once the access token is generated, it'll be tied to this specific list of scopes the user has granted. In your application, you'll be able to limit some actions based on those scopes. As we said in introduction, we use the OpenID Connect protocol on top of OAuth2. With this protocol, we always have at least one scope, openid . It's a core scope giving access to the basic information of the user. First-party clients Since you'll use Fief to authenticate users on your own, official application, we introduced the concept of first-party clients. When a user logs in on a client configured as first-party, the consent screen is bypassed and every scopes asked are implicitly granted. You can read more about this in the dedicated section . Limitations In the future, you'll be able to create your own set of scopes in Fief.","title":"Scopes"},{"location":"getting-started/oauth2/#access-token-and-id-token","text":"After a successful authentication flow, your application will get two different tokens: an access token and an ID token . The first one, the access token , is a secret value that'll authenticate the user on your application. It's tied to a specific user and a list of scopes. On the other hand, the ID token is a value containing all the basic information about the authenticated user, like its email and other personal information. It'll be very useful in your application if you need for example to display the email of the current user. For security reasons, both of them have a limited lifetime . At some point, we'll need to make another OAuth2 authentication flow again to retrieve fresh tokens. Those are JWT The access token and the ID token are both generated as JSON Web Tokens (JWT). JWT is a widely-used standard to secure data contained in a standard JSON object. Typically, JWT are cryptographically signed . It means that your application is able to certify that the tokens you get are true and authentic tokens generated by Fief, and not forged by a malicious attacker. This is critical since we use those to authenticate users into your app. The technical details around this are a bit complex but you can read more about on the official JWT documentation .","title":"Access Token and ID Token"},{"location":"getting-started/tenants/","text":"Tenants \u00b6 This is where you'll see and manage the tenants of your workspace. What is a tenant? A tenant is a sub-division of your workspace. Each client and user is tied to a specific tenant. This is mostly useful if you want to create a product sold in white-label where each of your client has its own space. It allows for example for a user to have several accounts with the same email address inside one workspace, but actually tied to different tenants. From a user point-of-view, this is a different application on which they login with different credentials. If you don't plan to do this, that's okay: you'll always use a single tenant in your workspace. Each workspace has at least one default tenant. Base URL \u00b6 Each tenant is tied to a base URL : each routes, like login or registration, will be derived from this base. When you integrate Fief in your application, you'll need this base URL. Each workspace has one default tenant with a base URL pointing to your root subdomain, like https://example.fief.dev . Other tenants gets a path prefix, like https://example.fief.dev/other-tenant . Tip You can copy the base URL directly using the clipboard button in the list. Limitation At the moment, new tenants can't be created from the admin dashboard.","title":"Tenants"},{"location":"getting-started/tenants/#tenants","text":"This is where you'll see and manage the tenants of your workspace. What is a tenant? A tenant is a sub-division of your workspace. Each client and user is tied to a specific tenant. This is mostly useful if you want to create a product sold in white-label where each of your client has its own space. It allows for example for a user to have several accounts with the same email address inside one workspace, but actually tied to different tenants. From a user point-of-view, this is a different application on which they login with different credentials. If you don't plan to do this, that's okay: you'll always use a single tenant in your workspace. Each workspace has at least one default tenant.","title":"Tenants"},{"location":"getting-started/tenants/#base-url","text":"Each tenant is tied to a base URL : each routes, like login or registration, will be derived from this base. When you integrate Fief in your application, you'll need this base URL. Each workspace has one default tenant with a base URL pointing to your root subdomain, like https://example.fief.dev . Other tenants gets a path prefix, like https://example.fief.dev/other-tenant . Tip You can copy the base URL directly using the clipboard button in the list. Limitation At the moment, new tenants can't be created from the admin dashboard.","title":"Base URL"},{"location":"getting-started/user-fields/","text":"User fields \u00b6 This is where you'll see and manage the custom user fields of your workspace. What is a user field? Most of the time, you'll need to store data about your users, e.g., their first and last names, their birthdate, their newsletter preferences, etc. Your application will probably need to have quite a lot of data about them! To help you with this, Fief allows you to create custom user fields . Each one will have a name, an identifier and a type. Each user will have attached its values for those fields. They will be available directly through the ID token or through the /userinfo endpoint. Create a new user field \u00b6 You can create a new client by clicking the Create User field button. A modal will open where you'll be able to input its different properties. Edit an existing user field \u00b6 If you click on one of the user field in the list, you'll see its details on the right and be able to change its properties. Delete an existing user field \u00b6 If one of your user field is not useful anymore, you can delete it: click on the user field you want to delete in the list and click on the Delete button. Associated user values will be deleted as well When you delete a user field, the associated data on the user will also be deleted . Make sure you don't need this information anymore or that you saved it somewhere else before proceeding. User field properties \u00b6 User fields can be configured through their properties. Name \u00b6 This is the name of your user field. It'll be used as label in the registration form and in the admin dashboard . Slug \u00b6 This will be the identifier of the field in the ID token and in API responses. By default, it'll be automatically generated from the name , but you can customize it at will. The slug is unique in a workspace Each field should have a unique identifier. If you try to create a new user field with a slug that already exists, an error will be raised. Type \u00b6 This is probably the most important setting for your user field. It'll determine the type of data you want to store . We currently support n types: String \u00b6 Common type for textual values. Examples: A first or last name A company name A tagline It'll be shown as a simple text input in forms. Integer \u00b6 Type to store integer values. Examples: A reputation score An height An age It'll be shown as a numeric input in forms. Boolean \u00b6 Type to store boolean values. Examples: Subscription status to a newsletter Terms consent A validation status It'll be shown as a checkbox in forms. Choice \u00b6 Type accepting a predefined set of values. Examples: A gender A job sector A level of experience When selecting this type, you'll be able to configure the allowed choices. Each choice consists of two things: the value ( A ), which is the actual underlying value that will be stored in database and returned in the user data, and the label ( Choice A ) which will be used to show a user-friendly label in forms and the admin dashboard. It'll be shown as a select menu in forms. Phone number \u00b6 Type that'll validate if the value is a valid phone number. It shall be formatted with the international country code, +331020405 . It'll be shown as a text input in forms. Address \u00b6 Type that'll display several inputs to validate a full postal address. Timezone \u00b6 Type that'll display a list of valid timezones. Default \u00b6 For some types, you can define a default value . If the field is shown in a form, the field will automatically be pre-filled with this value. If the field is not presented in a form, this value will be automatically assigned to new users when they register. Ask at registration \u00b6 If checked, the user field will be presented in the user registration form . Ask at update \u00b6 If checked, the user will be able to update its value through the /profile API. Private field In some cases, you need values that can't be set by the user, e.g., an onboarding status or a reputation score. To do this, you can simply uncheck both Ask at registration and Ask at update field. You'll always be able to update this value through the admin dashboard or the Admin API. Required \u00b6 If checked, the value will have to be filled when presented in forms. Required boolean field You can set a user field of type Boolean as required . In this case, the value must be True . It can be useful for consent checkbox where you need the user to accept the terms before creating its account.","title":"User fields"},{"location":"getting-started/user-fields/#user-fields","text":"This is where you'll see and manage the custom user fields of your workspace. What is a user field? Most of the time, you'll need to store data about your users, e.g., their first and last names, their birthdate, their newsletter preferences, etc. Your application will probably need to have quite a lot of data about them! To help you with this, Fief allows you to create custom user fields . Each one will have a name, an identifier and a type. Each user will have attached its values for those fields. They will be available directly through the ID token or through the /userinfo endpoint.","title":"User fields"},{"location":"getting-started/user-fields/#create-a-new-user-field","text":"You can create a new client by clicking the Create User field button. A modal will open where you'll be able to input its different properties.","title":"Create a new user field"},{"location":"getting-started/user-fields/#edit-an-existing-user-field","text":"If you click on one of the user field in the list, you'll see its details on the right and be able to change its properties.","title":"Edit an existing user field"},{"location":"getting-started/user-fields/#delete-an-existing-user-field","text":"If one of your user field is not useful anymore, you can delete it: click on the user field you want to delete in the list and click on the Delete button. Associated user values will be deleted as well When you delete a user field, the associated data on the user will also be deleted . Make sure you don't need this information anymore or that you saved it somewhere else before proceeding.","title":"Delete an existing user field"},{"location":"getting-started/user-fields/#user-field-properties","text":"User fields can be configured through their properties.","title":"User field properties"},{"location":"getting-started/user-fields/#name","text":"This is the name of your user field. It'll be used as label in the registration form and in the admin dashboard .","title":"Name"},{"location":"getting-started/user-fields/#slug","text":"This will be the identifier of the field in the ID token and in API responses. By default, it'll be automatically generated from the name , but you can customize it at will. The slug is unique in a workspace Each field should have a unique identifier. If you try to create a new user field with a slug that already exists, an error will be raised.","title":"Slug"},{"location":"getting-started/user-fields/#type","text":"This is probably the most important setting for your user field. It'll determine the type of data you want to store . We currently support n types:","title":"Type"},{"location":"getting-started/user-fields/#string","text":"Common type for textual values. Examples: A first or last name A company name A tagline It'll be shown as a simple text input in forms.","title":"String"},{"location":"getting-started/user-fields/#integer","text":"Type to store integer values. Examples: A reputation score An height An age It'll be shown as a numeric input in forms.","title":"Integer"},{"location":"getting-started/user-fields/#boolean","text":"Type to store boolean values. Examples: Subscription status to a newsletter Terms consent A validation status It'll be shown as a checkbox in forms.","title":"Boolean"},{"location":"getting-started/user-fields/#choice","text":"Type accepting a predefined set of values. Examples: A gender A job sector A level of experience When selecting this type, you'll be able to configure the allowed choices. Each choice consists of two things: the value ( A ), which is the actual underlying value that will be stored in database and returned in the user data, and the label ( Choice A ) which will be used to show a user-friendly label in forms and the admin dashboard. It'll be shown as a select menu in forms.","title":"Choice"},{"location":"getting-started/user-fields/#phone-number","text":"Type that'll validate if the value is a valid phone number. It shall be formatted with the international country code, +331020405 . It'll be shown as a text input in forms.","title":"Phone number"},{"location":"getting-started/user-fields/#address","text":"Type that'll display several inputs to validate a full postal address.","title":"Address"},{"location":"getting-started/user-fields/#timezone","text":"Type that'll display a list of valid timezones.","title":"Timezone"},{"location":"getting-started/user-fields/#default","text":"For some types, you can define a default value . If the field is shown in a form, the field will automatically be pre-filled with this value. If the field is not presented in a form, this value will be automatically assigned to new users when they register.","title":"Default"},{"location":"getting-started/user-fields/#ask-at-registration","text":"If checked, the user field will be presented in the user registration form .","title":"Ask at registration"},{"location":"getting-started/user-fields/#ask-at-update","text":"If checked, the user will be able to update its value through the /profile API. Private field In some cases, you need values that can't be set by the user, e.g., an onboarding status or a reputation score. To do this, you can simply uncheck both Ask at registration and Ask at update field. You'll always be able to update this value through the admin dashboard or the Admin API.","title":"Ask at update"},{"location":"getting-started/user-fields/#required","text":"If checked, the value will have to be filled when presented in forms. Required boolean field You can set a user field of type Boolean as required . In this case, the value must be True . It can be useful for consent checkbox where you need the user to accept the terms before creating its account.","title":"Required"},{"location":"getting-started/users/","text":"Users \u00b6 This is where you'll see and manage the users of your workspace. What is a user? A user is the fundamental part of your Fief workspace: it represents the actual user that'll have access to your application! We store basic information about the user, like its email address and hashed password and take care of verifying its credentials upon login. Every user is tied to a tenant . It means that an individual can have several user accounts on your workspace, with the same email address, but tied to a different tenant. Create a new user \u00b6 In some circumstances, you might need to create a user manually from the admin dashboard. You can do so by clicking on the Create User button. A modal will open where you'll be able to input its email address, password and associated tenant. You'll also be able to fill the values for your custom user fields . Info User created that way will receive the welcome email, as if they registered themselves. Edit an existing user \u00b6 If you click on one of the user in the list, you'll see its details on the right and be able to update them. Assign roles and permissions to a user \u00b6 What are permissions and roles? Permissions are a way to list the actions a user will be allowed to perform in your application. For example, if you have a resource in your application called Castle , we can define the permissions Read Castle and Create Castle . Then, those permissions can be assigned to users . You'll then be able to control this list of permissions in your app to determine if the current user is able to perform the action they request. Assigning permissions directly to users can be tedious and error-prone. To help with this, Fief also supports the concept of Roles . A role consists of a set of permissions . Following our previous example, we can imagine to have the roles Castle Visitor , which only have the Read Castle permission and a Castle Manager role, which have both Read Castle and Create Castle permissions. Those roles can also be assigned to users . Then, they'll be automatically granted with the set of associated permissions . The good thing is that if you modify a role to add or remove permissions, it'll be automatically be passed on every users with this role. Said another way, it's a way to easily organize and assing permissions. Fief allows you to define permissions and roles to determine what your users are allowed to do or not in your application. From the dashboard, you are able to assign permissions and roles to users. Assign a role \u00b6 You can assign a role to a user by clicking on it in the list. It details will open on the right. Click on the Roles tab to see the roles they already have. From here, you can look for roles in the select menu. Click on Add role to assign it to the user. Asssociated permissions are automatically granted Of course, when you assign a role to a user, the permissions associated to this role are automatically granted to the user. Nothing more to do! Revoke a role \u00b6 You can revoke a role from a user by clicking on the trash button in front of the role you want to remove. Asssociated permissions are automatically revoked Of course, when you revoke a role from a user, the permissions associated to this role are automatically revoked from this user. Nothing more to do! Assign a permission \u00b6 You can assign a single permission to a user by clicking on it in the list. It details will open on the right. Click on the Permissions tab to see the permissions they already have. Notice that permissions granted through roles are also displayed , in italic. From here, you can look for permissions in the select menu. Click on Add permission to assign it to the user. In general, you should prefer roles Assigning a single permission can be convenient from time-to-time but we generally recommend to assign proper roles, even if they contain only one permission. This way, you can be more future-proof if you find that you actually need to add a new permission: rather than editing every users one by one, you'll only have to update the role once. Revoke a permission \u00b6 You can revoke a permission from a user by clicking on the trash button in front of the permission you want to remove. Displaying user fields \u00b6 By default, every user fields are displayed in the list. You can customize the view by clicking on the button at the left of the Create User button. A menu will show up where you'll be able to show or hide a field by clicking on the eye icon and reorder them by drag-and-drop.","title":"Users"},{"location":"getting-started/users/#users","text":"This is where you'll see and manage the users of your workspace. What is a user? A user is the fundamental part of your Fief workspace: it represents the actual user that'll have access to your application! We store basic information about the user, like its email address and hashed password and take care of verifying its credentials upon login. Every user is tied to a tenant . It means that an individual can have several user accounts on your workspace, with the same email address, but tied to a different tenant.","title":"Users"},{"location":"getting-started/users/#create-a-new-user","text":"In some circumstances, you might need to create a user manually from the admin dashboard. You can do so by clicking on the Create User button. A modal will open where you'll be able to input its email address, password and associated tenant. You'll also be able to fill the values for your custom user fields . Info User created that way will receive the welcome email, as if they registered themselves.","title":"Create a new user"},{"location":"getting-started/users/#edit-an-existing-user","text":"If you click on one of the user in the list, you'll see its details on the right and be able to update them.","title":"Edit an existing user"},{"location":"getting-started/users/#assign-roles-and-permissions-to-a-user","text":"What are permissions and roles? Permissions are a way to list the actions a user will be allowed to perform in your application. For example, if you have a resource in your application called Castle , we can define the permissions Read Castle and Create Castle . Then, those permissions can be assigned to users . You'll then be able to control this list of permissions in your app to determine if the current user is able to perform the action they request. Assigning permissions directly to users can be tedious and error-prone. To help with this, Fief also supports the concept of Roles . A role consists of a set of permissions . Following our previous example, we can imagine to have the roles Castle Visitor , which only have the Read Castle permission and a Castle Manager role, which have both Read Castle and Create Castle permissions. Those roles can also be assigned to users . Then, they'll be automatically granted with the set of associated permissions . The good thing is that if you modify a role to add or remove permissions, it'll be automatically be passed on every users with this role. Said another way, it's a way to easily organize and assing permissions. Fief allows you to define permissions and roles to determine what your users are allowed to do or not in your application. From the dashboard, you are able to assign permissions and roles to users.","title":"Assign roles and permissions to a user"},{"location":"getting-started/users/#assign-a-role","text":"You can assign a role to a user by clicking on it in the list. It details will open on the right. Click on the Roles tab to see the roles they already have. From here, you can look for roles in the select menu. Click on Add role to assign it to the user. Asssociated permissions are automatically granted Of course, when you assign a role to a user, the permissions associated to this role are automatically granted to the user. Nothing more to do!","title":"Assign a role"},{"location":"getting-started/users/#revoke-a-role","text":"You can revoke a role from a user by clicking on the trash button in front of the role you want to remove. Asssociated permissions are automatically revoked Of course, when you revoke a role from a user, the permissions associated to this role are automatically revoked from this user. Nothing more to do!","title":"Revoke a role"},{"location":"getting-started/users/#assign-a-permission","text":"You can assign a single permission to a user by clicking on it in the list. It details will open on the right. Click on the Permissions tab to see the permissions they already have. Notice that permissions granted through roles are also displayed , in italic. From here, you can look for permissions in the select menu. Click on Add permission to assign it to the user. In general, you should prefer roles Assigning a single permission can be convenient from time-to-time but we generally recommend to assign proper roles, even if they contain only one permission. This way, you can be more future-proof if you find that you actually need to add a new permission: rather than editing every users one by one, you'll only have to update the role once.","title":"Assign a permission"},{"location":"getting-started/users/#revoke-a-permission","text":"You can revoke a permission from a user by clicking on the trash button in front of the permission you want to remove.","title":"Revoke a permission"},{"location":"getting-started/users/#displaying-user-fields","text":"By default, every user fields are displayed in the list. You can customize the view by clicking on the button at the left of the Create User button. A menu will show up where you'll be able to show or hide a field by clicking on the eye icon and reorder them by drag-and-drop.","title":"Displaying user fields"},{"location":"getting-started/workspace/","text":"Create your workspace \u00b6 The easiest way to get started is to create your workspace on our official Fief instance . After having created your user account, you'll be guided through the creation of your workspace . What is a workspace? A workspace is a place where all your Fief data lives: configuration, users data, etc. Each workspace has its own subdomain reserved for you, like https://example.fief.dev . If you are working on several projects or companies, we recommend to create several workspaces to keep things organized. Step 1: name your workspace \u00b6 The first step is to name your workspace. Use a name describing your application or company: it'll be used to generate your workspace subdomain. For example, a workspace named Bretagne Duchy will be assigned to the subdomain https://bretagne-duchy.fief.dev . Step 2: select your type of database \u00b6 One of the great strength of Fief is that you can bring your own database to store your workspace data. This way, you keep in total control of your data. Of course, we also propose you to store your data on our performand and secure cloud database. Your choice! At this step, you can make the choice between the Fief cloud database or configure your own. For the sake of simplicity, we'll choose here the cloud database . If you want to bring your own database, we recommend you to read the dedicated section . Ready to go! \u00b6 That's it! At this point, everything is ready to create your workspace! After that, you'll be redirected to your admin dashboard, where you'll be able to manage your workspace.","title":"Create your workspace"},{"location":"getting-started/workspace/#create-your-workspace","text":"The easiest way to get started is to create your workspace on our official Fief instance . After having created your user account, you'll be guided through the creation of your workspace . What is a workspace? A workspace is a place where all your Fief data lives: configuration, users data, etc. Each workspace has its own subdomain reserved for you, like https://example.fief.dev . If you are working on several projects or companies, we recommend to create several workspaces to keep things organized.","title":"Create your workspace"},{"location":"getting-started/workspace/#step-1-name-your-workspace","text":"The first step is to name your workspace. Use a name describing your application or company: it'll be used to generate your workspace subdomain. For example, a workspace named Bretagne Duchy will be assigned to the subdomain https://bretagne-duchy.fief.dev .","title":"Step 1: name your workspace"},{"location":"getting-started/workspace/#step-2-select-your-type-of-database","text":"One of the great strength of Fief is that you can bring your own database to store your workspace data. This way, you keep in total control of your data. Of course, we also propose you to store your data on our performand and secure cloud database. Your choice! At this step, you can make the choice between the Fief cloud database or configure your own. For the sake of simplicity, we'll choose here the cloud database . If you want to bring your own database, we recommend you to read the dedicated section .","title":"Step 2: select your type of database"},{"location":"getting-started/workspace/#ready-to-go","text":"That's it! At this point, everything is ready to create your workspace! After that, you'll be redirected to your admin dashboard, where you'll be able to manage your workspace.","title":"Ready to go!"},{"location":"going-further/byod/","text":"Bring your own database \u00b6 This is one of the most iconic feature of Fief. \"Bring your own database\" allows you to configure your very own SQL database , hosted anywhere you want, and let Fief store all your data into it. This is especially useful if you have special requirements about where and how your data should be stored. Then, Fief will execute its logic by reading and writing data to your database, and nowhere else. I want to host everything myself! If you don't want to use our cloud instance at all, you can also host the entire Fief server on your own! You can find detailed instructions here . Setup your database \u00b6 You can configure your database during the creation of your workspace . At step 2, select the option My own database . Then, you'll need to enter the details about your database. Database type : you have the choice between a PostgreSQL and MySQL database. Host Port Username Password Database name Credentials are encrypted on Fief To protect your database credentials, we encrypt them using the Fernet method . It means that even if a malicious individual achieves to access our systems, they couldn't steal your credentials. After this step, we'll try to connect to your database and create the schema Fief needs to work. You'll then be redirected to your admin dashboard, where you'll be able to manage your workspace. IP allow-list \u00b6 If your database server controls which IP are allowed to connect, you can allow the following list of IP. Those are the ones used by our cloud server: 18.156.158.53 18.156.42.200 52.59.103.54 How Fief uses your database? \u00b6 Schema \u00b6 Fief won't directly use the database instance you provide. Instead, it'll create another dedicated schema . For PostgreSQL servers, it'll create a schema , which could be more or less described as a \"sub-database\". For MySQL servers, it'll create another database instance. Migrations \u00b6 Fief maintain a migration table in your database to keep track of changes to the tables schema. When we deploy updates to Fief that needs to add or modify tables, we'll automatically apply migrations on your database. Don't edit data yourself! \u00b6 When you have access to the database, it might be tempting to manually add or modify data. DON'T DO THIS . If you make a mistake, you'll probably break your whole Fief workspace and your users won't be able to authenticate anymore. If you really need to make a special operation on your data, please ask us first , we'll help you to do it safely.","title":"Bring your own database"},{"location":"going-further/byod/#bring-your-own-database","text":"This is one of the most iconic feature of Fief. \"Bring your own database\" allows you to configure your very own SQL database , hosted anywhere you want, and let Fief store all your data into it. This is especially useful if you have special requirements about where and how your data should be stored. Then, Fief will execute its logic by reading and writing data to your database, and nowhere else. I want to host everything myself! If you don't want to use our cloud instance at all, you can also host the entire Fief server on your own! You can find detailed instructions here .","title":"Bring your own database"},{"location":"going-further/byod/#setup-your-database","text":"You can configure your database during the creation of your workspace . At step 2, select the option My own database . Then, you'll need to enter the details about your database. Database type : you have the choice between a PostgreSQL and MySQL database. Host Port Username Password Database name Credentials are encrypted on Fief To protect your database credentials, we encrypt them using the Fernet method . It means that even if a malicious individual achieves to access our systems, they couldn't steal your credentials. After this step, we'll try to connect to your database and create the schema Fief needs to work. You'll then be redirected to your admin dashboard, where you'll be able to manage your workspace.","title":"Setup your database"},{"location":"going-further/byod/#ip-allow-list","text":"If your database server controls which IP are allowed to connect, you can allow the following list of IP. Those are the ones used by our cloud server: 18.156.158.53 18.156.42.200 52.59.103.54","title":"IP allow-list"},{"location":"going-further/byod/#how-fief-uses-your-database","text":"","title":"How Fief uses your database?"},{"location":"going-further/byod/#schema","text":"Fief won't directly use the database instance you provide. Instead, it'll create another dedicated schema . For PostgreSQL servers, it'll create a schema , which could be more or less described as a \"sub-database\". For MySQL servers, it'll create another database instance.","title":"Schema"},{"location":"going-further/byod/#migrations","text":"Fief maintain a migration table in your database to keep track of changes to the tables schema. When we deploy updates to Fief that needs to add or modify tables, we'll automatically apply migrations on your database.","title":"Migrations"},{"location":"going-further/byod/#dont-edit-data-yourself","text":"When you have access to the database, it might be tempting to manually add or modify data. DON'T DO THIS . If you make a mistake, you'll probably break your whole Fief workspace and your users won't be able to authenticate anymore. If you really need to make a special operation on your data, please ask us first , we'll help you to do it safely.","title":"Don't edit data yourself!"},{"location":"going-further/id-token-encryption/","text":"ID Token encryption \u00b6 Work in progress \ud83d\udc77","title":"ID Token encryption"},{"location":"going-further/id-token-encryption/#id-token-encryption","text":"Work in progress \ud83d\udc77","title":"ID Token encryption"},{"location":"going-further/pkce/","text":"PKCE \u00b6 Work in progress \ud83d\udc77","title":"PKCE"},{"location":"going-further/pkce/#pkce","text":"Work in progress \ud83d\udc77","title":"PKCE"},{"location":"integrate/javascript/","text":"JavaScript \u00b6 We provide an official client for JavaScript. You can install it with npm : npm install @fief/fief Create a Fief client \u00b6 The Fief client provides all the necessary methods to manage OAuth2 authentication, validate access tokens and refresh them. const fief = new Fief ({ baseURL : 'https://example.fief.dev' , // (1)! clientId : 'YOUR_CLIENT_ID' , // (2)! clientSecret : 'YOUR_CLIENT_SECRET' , // (3)! }); Base URL of your Fief tenant You can find it in the admin dashboard, in the Tenants list. More info ID of your Fief client You can find it in the admin dashboard, in the Clients list. More info Info A first client is always created for you when you create your workspace. When getting started, you should use this one. Secret of your Fief client You can find it in the admin dashboard, in the Clients list. More info Info A first client is always created for you when you create your workspace. When getting started, you should use this one. Client secret is not safe in browser-based applications If you build a browser-based application in JavaScript, the Client Secret is not safe: the end-user can easily find it in the source code. To circumvent this, Fief allows to omit the client secret for clients with the public type . However, a PKCE code challenge will be required during the authorization flow. What's next? \u00b6 JavaScript being a vast ecosystem both for browsers and servers, integration paths can be quite different following your use-case. To help you further, we provide you helpers and examples for popular JavaScript frameworks and technologies, like React. Integrate in browser with plain JavaScript Integrate with React Reference \u00b6 Fief client \u00b6 Constructor baseURL: string : Base URL of your Fief tenant. clientID: string : ID of your Fief client. clientSecret: string | undefined : Secret of your Fief client. It's not recommended to use it in the context of a browser app, since it can be easily found by the end-user in the source code. The recommended way is to use a Public client . encryptionKey: string | undefined : Encryption key of your Fief client. Necessary only if ID Token encryption is enabled. getAuthURL \u00b6 Returns an authorization URL. Parameters redirectURI: string : Your callback URI where the user will be redirected after Fief authentication. state: string | undefined : Optional string that will be returned back in the callback parameters to allow you to retrieve state information. scope: string[] | undefined : Optional list of scopes to ask for. codeChallenge: string | undefined : Optional code challenge for PKCE process . codeChallengeMethod: 'plain' | 'S256' | undefined : Method used to hash the PKCE code challenge. extras_params: Record<string, string> | undefined : Optional object containing specific parameters. Example const authURL = await fief . getAuthURL ({ redirectURI : 'http://localhost:8000/callback' , scope : [ 'openid' ], ); authCallback \u00b6 Returns a FiefTokenResponse and FiefUserInfo in exchange of an authorization code. Parameters code: string : The authorization code. redirectURI: string : The exact same redirectURI you passed to the authorization URL. codeVerifier: string | undefined : The raw PCKE code used to generate the code challenge during authorization. Example const [ tokens , userinfo ] = await fief . authCallback ( 'CODE' , 'http://localhost:8000/callback' ); authRefreshToken \u00b6 Returns fresh FiefTokenResponse and FiefUserInfo in exchange of a refresh token. Parameters refresh_token: string : A valid refresh token. scope: string[] | undefined : Optional list of scopes to ask for. If not provided, the access token will share the same list of scopes as requested the first time. Otherwise, it should be a subset of the original list of scopes. Example const [ tokens , userinfo ] = await fief . authRefreshToken ( 'REFRESH_TOKEN' ); validateAccessToken \u00b6 Checks if an access token is valid and optionally that it has a required list of scopes, or a required list of permissions . Returns a FiefAccessTokenInfo . Parameters accessToken: string : The access token to validate. requiredScopes: string[] | undefined : Optional list of scopes to check for. requiredPermissions: string[] | undefined : Optional list of permissions to check for. Example: Validate access token with required scopes import { FiefAccessTokenExpired , FiefAccessTokenInvalid , FiefAccessTokenMissingScope } from '@fief/fief' ; try { accessTokenInfo = await fief . validateAccessToken ( 'ACCESS_TOKEN' , [ 'required_scope' ]); console . log ( accessTokenInfo ); } catch ( err ) { if ( err instanceof FiefAccessTokenInvalid ) { console . error ( 'Invalid access token' ); } else if ( err instanceof FiefAccessTokenExpired ) { console . error ( 'Expired access token' ); } else if ( err instanceof FiefAccessTokenMissingScope ) { console . error ( 'Missing required scope' ); } } Example: Validate access token with required scopes import { FiefAccessTokenExpired , FiefAccessTokenInvalid , FiefAccessTokenMissingPermission } from '@fief/fief' ; try { accessTokenInfo = await fief . validateAccessToken ( 'ACCESS_TOKEN' , undefined , [ 'castles:create' , 'castles:read' ]); console . log ( accessTokenInfo ); } catch ( err ) { if ( err instanceof FiefAccessTokenInvalid ) { console . error ( 'Invalid access token' ); } else if ( err instanceof FiefAccessTokenExpired ) { console . error ( 'Expired access token' ); } else if ( err instanceof FiefAccessTokenMissingPermission ) { console . error ( 'Missing required permission' ); } } userinfo \u00b6 Returns fresh FiefUserInfo from the Fief API using a valid access token. Parameters accessToken: string : A valid access token Example userinfo = await fief . userinfo ( 'ACCESS_TOKEN' ); updateProfile \u00b6 Updates user information with the Fief API using a valid access token. Parameters accessToken: string : A valid access token data: Record<string, any> : An object containing the data to update Update email address userinfo = await fief . updateProfile ( 'ACCESS_TOKEN' , { email : 'anne@nantes.city' }) Update password userinfo = await fief . updateProfile ( 'ACCESS_TOKEN' , { password : 'hermine1' }) Update user field To update user field values, you need to nest them into a fields object, indexed by their slug. userinfo = await fief . update_profile ( 'ACCESS_TOKEN' , { fields : { first_name : 'Anne' } }) getLogoutURL \u00b6 Returns a logout URL. If you redirect the user to this page, Fief will clear the session stored on its side. You're still responsible for clearing your own session mechanism if any. Parameters redirectURI: string : A valid URL where the user will be redirected after the logout process. Example const logoutURL = await fief . getLogoutURL ({ redirectURI : 'http://localhost:8000' , }); FiefTokenResponse \u00b6 Object containing the tokens and related information returned by Fief after a successful authentication. Structure access_token: string : Access token you can use to call the Fief API id_token: string : ID token containing user information token_type: string : Type of token, usually bearer expires_int: number : Number of seconds after which the tokens will expire refresh_token: string | undefined : Token provided only if scope offline_access was granted. Allows you to retrieve fresh tokens using the authRefreshToken method. FiefAccessTokenInfo \u00b6 Object containing information about the access token. Structure id: string : ID of the user scope: string[] : Array of granted scopes for this access token permissions: string[] : List of granted permissions for this user access_token: string : Access token you can use to call the Fief API Example { id : 'aeeb8bfa-e8f4-4724-9427-c3d5af66190e' , scope : [ 'openid' , 'required_scope' ], permissions : [ 'castles:read' , 'castles:create' , 'castles:update' , 'castles:delete' ], access_token : 'ACCESS_TOKEN' , } FiefUserInfo \u00b6 Object containing user information. Structure sub: string : ID of the user email: string : Email address of the user tenant_id: string : ID of the tenant associated to the user Available user fields values for this user, indexed by their slug. Example { sub : 'aeeb8bfa-e8f4-4724-9427-c3d5af66190e' , email : 'anne@bretagne.duchy' , tenant_id : 'c91ecb7f-359c-4244-8385-51ecd6c0d06b' , first_name : 'Anne' , last_name : 'De Bretagne' , }","title":"General"},{"location":"integrate/javascript/#javascript","text":"We provide an official client for JavaScript. You can install it with npm : npm install @fief/fief","title":"JavaScript"},{"location":"integrate/javascript/#create-a-fief-client","text":"The Fief client provides all the necessary methods to manage OAuth2 authentication, validate access tokens and refresh them. const fief = new Fief ({ baseURL : 'https://example.fief.dev' , // (1)! clientId : 'YOUR_CLIENT_ID' , // (2)! clientSecret : 'YOUR_CLIENT_SECRET' , // (3)! }); Base URL of your Fief tenant You can find it in the admin dashboard, in the Tenants list. More info ID of your Fief client You can find it in the admin dashboard, in the Clients list. More info Info A first client is always created for you when you create your workspace. When getting started, you should use this one. Secret of your Fief client You can find it in the admin dashboard, in the Clients list. More info Info A first client is always created for you when you create your workspace. When getting started, you should use this one. Client secret is not safe in browser-based applications If you build a browser-based application in JavaScript, the Client Secret is not safe: the end-user can easily find it in the source code. To circumvent this, Fief allows to omit the client secret for clients with the public type . However, a PKCE code challenge will be required during the authorization flow.","title":"Create a Fief client"},{"location":"integrate/javascript/#whats-next","text":"JavaScript being a vast ecosystem both for browsers and servers, integration paths can be quite different following your use-case. To help you further, we provide you helpers and examples for popular JavaScript frameworks and technologies, like React. Integrate in browser with plain JavaScript Integrate with React","title":"What's next?"},{"location":"integrate/javascript/#reference","text":"","title":"Reference"},{"location":"integrate/javascript/#fief-client","text":"Constructor baseURL: string : Base URL of your Fief tenant. clientID: string : ID of your Fief client. clientSecret: string | undefined : Secret of your Fief client. It's not recommended to use it in the context of a browser app, since it can be easily found by the end-user in the source code. The recommended way is to use a Public client . encryptionKey: string | undefined : Encryption key of your Fief client. Necessary only if ID Token encryption is enabled.","title":"Fief client"},{"location":"integrate/javascript/#getauthurl","text":"Returns an authorization URL. Parameters redirectURI: string : Your callback URI where the user will be redirected after Fief authentication. state: string | undefined : Optional string that will be returned back in the callback parameters to allow you to retrieve state information. scope: string[] | undefined : Optional list of scopes to ask for. codeChallenge: string | undefined : Optional code challenge for PKCE process . codeChallengeMethod: 'plain' | 'S256' | undefined : Method used to hash the PKCE code challenge. extras_params: Record<string, string> | undefined : Optional object containing specific parameters. Example const authURL = await fief . getAuthURL ({ redirectURI : 'http://localhost:8000/callback' , scope : [ 'openid' ], );","title":"getAuthURL"},{"location":"integrate/javascript/#authcallback","text":"Returns a FiefTokenResponse and FiefUserInfo in exchange of an authorization code. Parameters code: string : The authorization code. redirectURI: string : The exact same redirectURI you passed to the authorization URL. codeVerifier: string | undefined : The raw PCKE code used to generate the code challenge during authorization. Example const [ tokens , userinfo ] = await fief . authCallback ( 'CODE' , 'http://localhost:8000/callback' );","title":"authCallback"},{"location":"integrate/javascript/#authrefreshtoken","text":"Returns fresh FiefTokenResponse and FiefUserInfo in exchange of a refresh token. Parameters refresh_token: string : A valid refresh token. scope: string[] | undefined : Optional list of scopes to ask for. If not provided, the access token will share the same list of scopes as requested the first time. Otherwise, it should be a subset of the original list of scopes. Example const [ tokens , userinfo ] = await fief . authRefreshToken ( 'REFRESH_TOKEN' );","title":"authRefreshToken"},{"location":"integrate/javascript/#validateaccesstoken","text":"Checks if an access token is valid and optionally that it has a required list of scopes, or a required list of permissions . Returns a FiefAccessTokenInfo . Parameters accessToken: string : The access token to validate. requiredScopes: string[] | undefined : Optional list of scopes to check for. requiredPermissions: string[] | undefined : Optional list of permissions to check for. Example: Validate access token with required scopes import { FiefAccessTokenExpired , FiefAccessTokenInvalid , FiefAccessTokenMissingScope } from '@fief/fief' ; try { accessTokenInfo = await fief . validateAccessToken ( 'ACCESS_TOKEN' , [ 'required_scope' ]); console . log ( accessTokenInfo ); } catch ( err ) { if ( err instanceof FiefAccessTokenInvalid ) { console . error ( 'Invalid access token' ); } else if ( err instanceof FiefAccessTokenExpired ) { console . error ( 'Expired access token' ); } else if ( err instanceof FiefAccessTokenMissingScope ) { console . error ( 'Missing required scope' ); } } Example: Validate access token with required scopes import { FiefAccessTokenExpired , FiefAccessTokenInvalid , FiefAccessTokenMissingPermission } from '@fief/fief' ; try { accessTokenInfo = await fief . validateAccessToken ( 'ACCESS_TOKEN' , undefined , [ 'castles:create' , 'castles:read' ]); console . log ( accessTokenInfo ); } catch ( err ) { if ( err instanceof FiefAccessTokenInvalid ) { console . error ( 'Invalid access token' ); } else if ( err instanceof FiefAccessTokenExpired ) { console . error ( 'Expired access token' ); } else if ( err instanceof FiefAccessTokenMissingPermission ) { console . error ( 'Missing required permission' ); } }","title":"validateAccessToken"},{"location":"integrate/javascript/#userinfo","text":"Returns fresh FiefUserInfo from the Fief API using a valid access token. Parameters accessToken: string : A valid access token Example userinfo = await fief . userinfo ( 'ACCESS_TOKEN' );","title":"userinfo"},{"location":"integrate/javascript/#updateprofile","text":"Updates user information with the Fief API using a valid access token. Parameters accessToken: string : A valid access token data: Record<string, any> : An object containing the data to update Update email address userinfo = await fief . updateProfile ( 'ACCESS_TOKEN' , { email : 'anne@nantes.city' }) Update password userinfo = await fief . updateProfile ( 'ACCESS_TOKEN' , { password : 'hermine1' }) Update user field To update user field values, you need to nest them into a fields object, indexed by their slug. userinfo = await fief . update_profile ( 'ACCESS_TOKEN' , { fields : { first_name : 'Anne' } })","title":"updateProfile"},{"location":"integrate/javascript/#getlogouturl","text":"Returns a logout URL. If you redirect the user to this page, Fief will clear the session stored on its side. You're still responsible for clearing your own session mechanism if any. Parameters redirectURI: string : A valid URL where the user will be redirected after the logout process. Example const logoutURL = await fief . getLogoutURL ({ redirectURI : 'http://localhost:8000' , });","title":"getLogoutURL"},{"location":"integrate/javascript/#fieftokenresponse","text":"Object containing the tokens and related information returned by Fief after a successful authentication. Structure access_token: string : Access token you can use to call the Fief API id_token: string : ID token containing user information token_type: string : Type of token, usually bearer expires_int: number : Number of seconds after which the tokens will expire refresh_token: string | undefined : Token provided only if scope offline_access was granted. Allows you to retrieve fresh tokens using the authRefreshToken method.","title":"FiefTokenResponse"},{"location":"integrate/javascript/#fiefaccesstokeninfo","text":"Object containing information about the access token. Structure id: string : ID of the user scope: string[] : Array of granted scopes for this access token permissions: string[] : List of granted permissions for this user access_token: string : Access token you can use to call the Fief API Example { id : 'aeeb8bfa-e8f4-4724-9427-c3d5af66190e' , scope : [ 'openid' , 'required_scope' ], permissions : [ 'castles:read' , 'castles:create' , 'castles:update' , 'castles:delete' ], access_token : 'ACCESS_TOKEN' , }","title":"FiefAccessTokenInfo"},{"location":"integrate/javascript/#fiefuserinfo","text":"Object containing user information. Structure sub: string : ID of the user email: string : Email address of the user tenant_id: string : ID of the tenant associated to the user Available user fields values for this user, indexed by their slug. Example { sub : 'aeeb8bfa-e8f4-4724-9427-c3d5af66190e' , email : 'anne@bretagne.duchy' , tenant_id : 'c91ecb7f-359c-4244-8385-51ecd6c0d06b' , first_name : 'Anne' , last_name : 'De Bretagne' , }","title":"FiefUserInfo"},{"location":"integrate/javascript/browser/","text":"Browser \u00b6 It's possible to manage authentication with Fief entirely within the browser, using a bit of JavaScript. To help you in this task, the Fief JavaScript client provides tools dedicated to the browser environment. Let's see how to use them! Install the client \u00b6 The recommended way to install the client is to use npm : npm install @fief/fief However, if you don't use a JavaScript bundler, like Webpack, you can include the package directly in a browser script, thanks to UNPKG CDN : < script src = \"https://unpkg.com/@fief/fief\" ></ script > <!-- (1)! --> < script > console . log ( fief ); // Module is available globally under the `fief` variable </ script > This will always load the latest version You should pin the version to avoid problems when we update the client and improve the loading time. For example, to load the version 0.6.1 : < script src = \"https://unpkg.com/@fief/fief@0.6.1/build/index.umd.js\" ></ script > Application example \u00b6 This is for you if... You want to handle all the OAuth authentication in the browser. Prerequisites Make sure your Fief Client is Public . Allow the following Redirect URI on your Fief Client: http://localhost:8080/callback.html Install http-server , a simple NodeJS HTTP server: npm i --global http-server In this example, we'll show you a very simple HTML and JavaScript application to perform the OAuth2 authentication. We'll define two pages: index.html : it'll show if the user is logged in or not, and display a Login button. callback.html : the page Fief will redirect the user to after a successful login to complete the OAuth authentication. Let's see the first one: index.html <!DOCTYPE html> < html > < head > < title > Fief JavaScript Browser example </ title > </ head > < body > < div id = \"logged-out\" style = \"display: none\" > <!-- (1)! --> < h1 > You are not logged in </ h1 > < button type = \"button\" id = \"login-button\" > Login </ button > </ div > < div id = \"logged-in\" style = \"display: none\" > <!-- (2)! --> < h1 > Hello < span id = \"user-email\" ></ span > \ud83d\udc4b </ h1 > < button type = \"button\" id = \"logout-button\" > Logout </ button > </ div > < script src = \"https://unpkg.com/@fief/fief\" ></ script > < script > const initialize = () => { const fiefClient = new fief . Fief ({ // (3)! baseURL : 'https://example.fief.dev' , clientId : 'YOUR_CLIENT_ID' , }); const fiefAuth = new fief . browser . FiefAuth ( fiefClient ); // (4)! document . getElementById ( 'login-button' ). addEventListener ( 'click' , () => { fiefAuth . redirectToLogin ( 'http://localhost:8080/callback.html' ); // (5)! }); document . getElementById ( 'logout-button' ). addEventListener ( 'click' , () => { fiefAuth . logout ( 'http://localhost:8080' ); // (6)! }); const userinfo = fiefAuth . getUserinfo (); // (7)! if ( userinfo !== null ) { // (8)! document . getElementById ( 'logged-in' ). style . display = 'block' ; document . getElementById ( 'logged-out' ). style . display = 'none' ; document . getElementById ( 'user-email' ). textContent = userinfo . email ; } else { // (9)! document . getElementById ( 'logged-in' ). style . display = 'none' ; document . getElementById ( 'logged-out' ). style . display = 'block' ; } }; document . addEventListener ( 'DOMContentLoaded' , initialize , false ); </ script > </ body > </ html > HTML block for when the user is not logged in It simply contains a generic title and a login button . HTML block for when the user is logged in We greet the logged in user with their email address and show them a logout button . Fief client instantiation As we showed in the JavaScript section , we instantiate here a Fief client here with the base tenant URL and client credentials. Notice here that we omit the Client Secret . Indeed, the secret can't be kept safe in the browser: the end-user can easily find it in the source code. That's why we set the Fief Client as Public : we allow it to make authentication requests without the Client Secret. Fief helper for the browser This is the helper doing the tedious work for you in the browser. All it needs is an instance of the Fief client. Under the hood, FiefAuth will store the user session data on the browser SessionStorage . This is how we'll maintain the logged-in state of the user during its visit. When the login button is clicked, redirect to Fief login page We simply add an event listener on the button to start the authorization process when it's clicked. We use the FiefAuth helper for this. All it needs is the redirect URL where the user will be redirected after a successful authentication on Fief: the callback.html page. Under the hood, FiefAuth takes care of generating a PKCE code challenge for maximum security! When the logout button is clicked, clear session and redirect to Fief logout page We simply add an event listener on the button to logout the user. The FiefAuth helper takes care of clearing the local session and redirect to the Fief logout page so that the session on Fief's side can also be cleared. All it needs is the redirect URL where the user will be redirected after a successful logout. Here, we go back to the index.html page. Get user information in session The getUserinfo method of FiefAuth allows to retrieve the user information stored in session, if any. User information is available The user is logged in \ud83d\udc4d We can show the right HTML block and fill the user email to greet them properly. User information is not available The user is not logged in \ud83d\ude14 We can show the right HTML block with the login button. As you can see, the JavaScript code is quite short! Most of the tedious work is done by the FiefAuth helper, which takes care of storing the session in the browser and authenticating the client with PKCE. Let's now see the callback.html page: callback.html <!DOCTYPE html> < html > < head > < title > Fief JavaScript Browser example </ title > </ head > < body > < script src = \"https://unpkg.com/@fief/fief\" ></ script > < script > const initialize = () => { const fiefClient = new fief . Fief ({ baseURL : 'https://example.fief.dev' , clientId : 'YOUR_CLIENT_ID' , }); const fiefAuth = new fief . browser . FiefAuth ( fiefClient ); // (1)! fiefAuth . authCallback ( 'http://localhost:8080/callback.html' ). then ( // (2)! () => { window . location . href = 'http://localhost:8080' ; } ); }; document . addEventListener ( 'DOMContentLoaded' , initialize , false ); </ script > </ body > </ html > This doesn't change We once again instantiate a Fief client and the browser helper. We call the authCallback method This method takes care of everything: retrieving the authorization code in the query parameters, exchanging it with a fresh access token and save it in the browser session. Once the promise is resolved, all we have to do is to redirect back to the index.html page. That's it! Assuming you have both files in a directory named app-directory , you can run this application using http-server : http-server app-directory/ It'll make it available on http://localhost:8080 . The first time you open it, you'll be logged out: If you click on the Login button, you'll be redirected to Fief to authenticate. Once done, you'll be redirected to your application and should be properly logged in: You can also try the Logout button to see how the session is cleared. FiefAuth reference \u00b6 Constructor client: Fief : Instance of a Fief client. storage: IFiefAuthStorage | undefined : Instance of a class implementing the IFiefAuthStorage interface . By default, it'll use an implementation based on the browser SessionStorage . isAuthenticated \u00b6 Returns whether there is a valid user session in the browser. Example const isAuthenticated = fiefAuth . isAuthenticated (); getUserinfo \u00b6 Returns the user information object available in session, or null if no current session. Example const userinfo = fiefAuth . getUserinfo (); console . log ( userinfo ); getTokenInfo \u00b6 Returns the token information object available in session, or null if no current session. Example const tokenInfo = fiefAuth . getTokenInfo (); console . log ( tokenInfo ); // {\"access_token\": \"ACCESS_TOKEN\", \"id_token\": \"ID_TOKEN\", \"token_type\": \"bearer\", \"expires_in\": 3600} redirectToLogin \u00b6 Starts a Fief authorization process and performs the redirection. Under the hood, it automatically generates a PKCE code challenge . Parameters redirectURI: string : Your callback URI where the user will be redirected after Fief authentication. Example fiefAuth . redirectToLogin ( 'http://localhost:8080/callback.html' ); authCallback \u00b6 Completes the Fief authentication process by exchanging the authorization code available in query parameters and stores the tokens and user information in the browser session. Under the hood, it automatically handles the PKCE code challenge . Parameters redirectURI: string : The exact same redirectURI you passed to the authorization URL. Example fiefAuth . authCallback ( 'http://localhost:8080/callback.html' ) . then (() => { window . location . href = 'http://localhost:8080' ; }) . catch (( err ) => { if ( err instance of fief . browser . FiefAuthAuthorizeError ) { console . error ( 'An error occured: ' , err . error , err . description ); } }) refreshUserinfo \u00b6 Refreshes user information from the Fief API using the access token available in session. The fresh user information is returned and automatically updated in the session storage. Example fiefAuth . refreshUserinfo ( 'http://localhost:8080/callback.html' ) . then (( userinfo ) => { console . log ( userinfo ); }) . catch (( err ) => { if ( err instance of fief . browser . FiefAuthNotAuthenticatedError ) { console . error ( 'User is not logged in' ); } }) logout \u00b6 Clears the access token and the user information from the browser storage and redirects to the Fief logout endpoint. Parameters redirectURI: string : A valid URL where the user will be redirected after the logout process. Example fiefAuth . logout ( 'http://localhost:8080' )","title":"Browser"},{"location":"integrate/javascript/browser/#browser","text":"It's possible to manage authentication with Fief entirely within the browser, using a bit of JavaScript. To help you in this task, the Fief JavaScript client provides tools dedicated to the browser environment. Let's see how to use them!","title":"Browser"},{"location":"integrate/javascript/browser/#install-the-client","text":"The recommended way to install the client is to use npm : npm install @fief/fief However, if you don't use a JavaScript bundler, like Webpack, you can include the package directly in a browser script, thanks to UNPKG CDN : < script src = \"https://unpkg.com/@fief/fief\" ></ script > <!-- (1)! --> < script > console . log ( fief ); // Module is available globally under the `fief` variable </ script > This will always load the latest version You should pin the version to avoid problems when we update the client and improve the loading time. For example, to load the version 0.6.1 : < script src = \"https://unpkg.com/@fief/fief@0.6.1/build/index.umd.js\" ></ script >","title":"Install the client"},{"location":"integrate/javascript/browser/#application-example","text":"This is for you if... You want to handle all the OAuth authentication in the browser. Prerequisites Make sure your Fief Client is Public . Allow the following Redirect URI on your Fief Client: http://localhost:8080/callback.html Install http-server , a simple NodeJS HTTP server: npm i --global http-server In this example, we'll show you a very simple HTML and JavaScript application to perform the OAuth2 authentication. We'll define two pages: index.html : it'll show if the user is logged in or not, and display a Login button. callback.html : the page Fief will redirect the user to after a successful login to complete the OAuth authentication. Let's see the first one: index.html <!DOCTYPE html> < html > < head > < title > Fief JavaScript Browser example </ title > </ head > < body > < div id = \"logged-out\" style = \"display: none\" > <!-- (1)! --> < h1 > You are not logged in </ h1 > < button type = \"button\" id = \"login-button\" > Login </ button > </ div > < div id = \"logged-in\" style = \"display: none\" > <!-- (2)! --> < h1 > Hello < span id = \"user-email\" ></ span > \ud83d\udc4b </ h1 > < button type = \"button\" id = \"logout-button\" > Logout </ button > </ div > < script src = \"https://unpkg.com/@fief/fief\" ></ script > < script > const initialize = () => { const fiefClient = new fief . Fief ({ // (3)! baseURL : 'https://example.fief.dev' , clientId : 'YOUR_CLIENT_ID' , }); const fiefAuth = new fief . browser . FiefAuth ( fiefClient ); // (4)! document . getElementById ( 'login-button' ). addEventListener ( 'click' , () => { fiefAuth . redirectToLogin ( 'http://localhost:8080/callback.html' ); // (5)! }); document . getElementById ( 'logout-button' ). addEventListener ( 'click' , () => { fiefAuth . logout ( 'http://localhost:8080' ); // (6)! }); const userinfo = fiefAuth . getUserinfo (); // (7)! if ( userinfo !== null ) { // (8)! document . getElementById ( 'logged-in' ). style . display = 'block' ; document . getElementById ( 'logged-out' ). style . display = 'none' ; document . getElementById ( 'user-email' ). textContent = userinfo . email ; } else { // (9)! document . getElementById ( 'logged-in' ). style . display = 'none' ; document . getElementById ( 'logged-out' ). style . display = 'block' ; } }; document . addEventListener ( 'DOMContentLoaded' , initialize , false ); </ script > </ body > </ html > HTML block for when the user is not logged in It simply contains a generic title and a login button . HTML block for when the user is logged in We greet the logged in user with their email address and show them a logout button . Fief client instantiation As we showed in the JavaScript section , we instantiate here a Fief client here with the base tenant URL and client credentials. Notice here that we omit the Client Secret . Indeed, the secret can't be kept safe in the browser: the end-user can easily find it in the source code. That's why we set the Fief Client as Public : we allow it to make authentication requests without the Client Secret. Fief helper for the browser This is the helper doing the tedious work for you in the browser. All it needs is an instance of the Fief client. Under the hood, FiefAuth will store the user session data on the browser SessionStorage . This is how we'll maintain the logged-in state of the user during its visit. When the login button is clicked, redirect to Fief login page We simply add an event listener on the button to start the authorization process when it's clicked. We use the FiefAuth helper for this. All it needs is the redirect URL where the user will be redirected after a successful authentication on Fief: the callback.html page. Under the hood, FiefAuth takes care of generating a PKCE code challenge for maximum security! When the logout button is clicked, clear session and redirect to Fief logout page We simply add an event listener on the button to logout the user. The FiefAuth helper takes care of clearing the local session and redirect to the Fief logout page so that the session on Fief's side can also be cleared. All it needs is the redirect URL where the user will be redirected after a successful logout. Here, we go back to the index.html page. Get user information in session The getUserinfo method of FiefAuth allows to retrieve the user information stored in session, if any. User information is available The user is logged in \ud83d\udc4d We can show the right HTML block and fill the user email to greet them properly. User information is not available The user is not logged in \ud83d\ude14 We can show the right HTML block with the login button. As you can see, the JavaScript code is quite short! Most of the tedious work is done by the FiefAuth helper, which takes care of storing the session in the browser and authenticating the client with PKCE. Let's now see the callback.html page: callback.html <!DOCTYPE html> < html > < head > < title > Fief JavaScript Browser example </ title > </ head > < body > < script src = \"https://unpkg.com/@fief/fief\" ></ script > < script > const initialize = () => { const fiefClient = new fief . Fief ({ baseURL : 'https://example.fief.dev' , clientId : 'YOUR_CLIENT_ID' , }); const fiefAuth = new fief . browser . FiefAuth ( fiefClient ); // (1)! fiefAuth . authCallback ( 'http://localhost:8080/callback.html' ). then ( // (2)! () => { window . location . href = 'http://localhost:8080' ; } ); }; document . addEventListener ( 'DOMContentLoaded' , initialize , false ); </ script > </ body > </ html > This doesn't change We once again instantiate a Fief client and the browser helper. We call the authCallback method This method takes care of everything: retrieving the authorization code in the query parameters, exchanging it with a fresh access token and save it in the browser session. Once the promise is resolved, all we have to do is to redirect back to the index.html page. That's it! Assuming you have both files in a directory named app-directory , you can run this application using http-server : http-server app-directory/ It'll make it available on http://localhost:8080 . The first time you open it, you'll be logged out: If you click on the Login button, you'll be redirected to Fief to authenticate. Once done, you'll be redirected to your application and should be properly logged in: You can also try the Logout button to see how the session is cleared.","title":"Application example"},{"location":"integrate/javascript/browser/#fiefauth-reference","text":"Constructor client: Fief : Instance of a Fief client. storage: IFiefAuthStorage | undefined : Instance of a class implementing the IFiefAuthStorage interface . By default, it'll use an implementation based on the browser SessionStorage .","title":"FiefAuth reference"},{"location":"integrate/javascript/browser/#isauthenticated","text":"Returns whether there is a valid user session in the browser. Example const isAuthenticated = fiefAuth . isAuthenticated ();","title":"isAuthenticated"},{"location":"integrate/javascript/browser/#getuserinfo","text":"Returns the user information object available in session, or null if no current session. Example const userinfo = fiefAuth . getUserinfo (); console . log ( userinfo );","title":"getUserinfo"},{"location":"integrate/javascript/browser/#gettokeninfo","text":"Returns the token information object available in session, or null if no current session. Example const tokenInfo = fiefAuth . getTokenInfo (); console . log ( tokenInfo ); // {\"access_token\": \"ACCESS_TOKEN\", \"id_token\": \"ID_TOKEN\", \"token_type\": \"bearer\", \"expires_in\": 3600}","title":"getTokenInfo"},{"location":"integrate/javascript/browser/#redirecttologin","text":"Starts a Fief authorization process and performs the redirection. Under the hood, it automatically generates a PKCE code challenge . Parameters redirectURI: string : Your callback URI where the user will be redirected after Fief authentication. Example fiefAuth . redirectToLogin ( 'http://localhost:8080/callback.html' );","title":"redirectToLogin"},{"location":"integrate/javascript/browser/#authcallback","text":"Completes the Fief authentication process by exchanging the authorization code available in query parameters and stores the tokens and user information in the browser session. Under the hood, it automatically handles the PKCE code challenge . Parameters redirectURI: string : The exact same redirectURI you passed to the authorization URL. Example fiefAuth . authCallback ( 'http://localhost:8080/callback.html' ) . then (() => { window . location . href = 'http://localhost:8080' ; }) . catch (( err ) => { if ( err instance of fief . browser . FiefAuthAuthorizeError ) { console . error ( 'An error occured: ' , err . error , err . description ); } })","title":"authCallback"},{"location":"integrate/javascript/browser/#refreshuserinfo","text":"Refreshes user information from the Fief API using the access token available in session. The fresh user information is returned and automatically updated in the session storage. Example fiefAuth . refreshUserinfo ( 'http://localhost:8080/callback.html' ) . then (( userinfo ) => { console . log ( userinfo ); }) . catch (( err ) => { if ( err instance of fief . browser . FiefAuthNotAuthenticatedError ) { console . error ( 'User is not logged in' ); } })","title":"refreshUserinfo"},{"location":"integrate/javascript/browser/#logout","text":"Clears the access token and the user information from the browser storage and redirects to the Fief logout endpoint. Parameters redirectURI: string : A valid URL where the user will be redirected after the logout process. Example fiefAuth . logout ( 'http://localhost:8080' )","title":"logout"},{"location":"integrate/javascript/react/","text":"React \u00b6 React is one of the most popular JavaScript framework to build dynamic applications for the browser. The Fief JavaScript client provides tools to help you integrate Fief authentication in your React project. Let's see how to use them! Install the client \u00b6 npm install @fief/fief Application example \u00b6 This is for you if... You want to handle all the OAuth authentication in your React application. Prerequisites You have a React project setup. Make sure your Fief Client is Public . Allow the following Redirect URI on your Fief Client: http://localhost:3000/callback In this example, we'll show you how to use the components and hooks provided by Fief to authenticate users and protect routes using React Router . Setup FiefAuthProvider \u00b6 The FiefAuthProvider is a component providing all the necessary context for Fief, especially the Fief client and user session state. Every component nested inside this component will have access to the Fief hooks. App.tsx import { FiefAuthProvider } from '@fief/fief/react' ; import { Routes , Route } from 'react-router-dom' ; import Callback from './Callback' ; import Public from './Public' ; import Private from './Private' ; import Header from './Header' ; import RequireAuth from './RequireAuth' ; function App () { return ( < FiefAuthProvider // (1)! baseURL = \"https://example.fief.dev\" clientId = \"YOUR_CLIENT_ID\" > < div className = \"App\" > < h1 > Fief React example < /h1> < Header /> { /* (2)! */ } < Routes > { /* (3)! */ } < Route path = \"/\" element = { < Public /> } /> { /* (4)! */ } < Route path = \"/private\" element = { < RequireAuth >< Private />< /RequireAuth>} / > { /* (5)! */ } < Route path = \"/callback\" element = { < Callback /> } /> { /* (6)! */ } < /Routes> < /div> < /FiefAuthProvider> ); } export default App ; Declare the FiefAuthProvider This is necessary to give to nested components the right Fief context and makes the hooks working. It takes as properties the same arguments as the Fief client. A Header component Contains the navigation. We'll detail it in a moment. The Routes component from React Router A public route This route will be accessible by any visitor, even if not logged in. A private route This route will be accessible only by logged in users. To do this, we wrap it in a RequireAuth component. We'll detail it in a moment. A callback route The route where Fief will redirect the user to after a successful login to complete the OAuth authentication. At this point, your React app has everything it needs to use Fief authentication tools! Implement callback route \u00b6 After the user has successfully logged in on Fief, they will be redirected to your callback route. It needs to exchange the authorization code with a proper access token. The role of this route is then just to perform this task before redirecting to another route. Callback.tsx import { useFiefAuth } from '@fief/fief/react' ; import { useEffect } from 'react' ; import { useNavigate } from 'react-router-dom' ; const Callback : React.FunctionComponent = () => { const fiefAuth = useFiefAuth (); // (1)! const navigate = useNavigate (); useEffect (() => { fiefAuth . authCallback ( ` ${ window . location . protocol } // ${ window . location . host } /callback` ). then (() => { // (2)! navigate ( '/' ); }); }, [ fiefAuth , navigate ]); return ( < p > Callback !< /p> ); }; export default Callback ; Hook to get the FiefAuth class This is the browser helper provided by the Fief JavaScript client. We call the authCallback method This method takes care of everything: retrieving the authorization code in the query parameters, exchanging it with a fresh access token and save it in the browser session. Once the promise is resolved, all we have to do is to redirect back to the index page. Protect private routes \u00b6 Usually, you'll need to prevent visitors from accessing a page if they're not logged in. To do this, we implement a simple component that'll check for the authentication state and automatically redirect to the Fief authentication page if the user is not logged in. RequireAuth.tsx import { useFiefAuth , useFiefIsAuthenticated } from '@fief/fief/react' ; import React , { useEffect } from 'react' ; const RequireAuth : React.FunctionComponent = ({ children }) => { const fiefAuth = useFiefAuth (); // (1)! const isAuthenticated = useFiefIsAuthenticated (); // (2)! useEffect (() => { if ( ! isAuthenticated ) { fiefAuth . redirectToLogin ( ` ${ window . location . protocol } // ${ window . location . host } /callback` ); // (3)! } }, [ fiefAuth , isAuthenticated ]); return ( <> { isAuthenticated && children } < /> ); }; export default RequireAuth ; Hook to get the FiefAuth class This is the browser helper provided by the Fief JavaScript client. Hook to get the authentication state This hook simply returns a boolean stating if a user is logged in or not. Redirect to Fief authentication page With this effect, we automatically redirect the user to the Fief authentication page so that they can log in. The redirectToLogin method only needs the redirect URL where the user will be redirected after a successful authentication on Fief: the /callback route. Manage authentication \u00b6 You have access to a set of hooks to help you manage the authentication state of the user, like retrieving their information, redirect them to the authentication page or logout them. In the example below, we show a simple header with navigation links and a login or logout button. Header.tsx import { useFiefAuth , useFiefIsAuthenticated , useFiefUserinfo } from '@fief/fief/react' ; import React , { useCallback } from 'react' ; import { Link } from 'react-router-dom' ; const Header : React.FunctionComponent = () => { const fiefAuth = useFiefAuth (); const isAuthenticated = useFiefIsAuthenticated (); const userinfo = useFiefUserinfo (); // (1)! const login = useCallback (() => { // (2)! fiefAuth . redirectToLogin ( ` ${ window . location . protocol } // ${ window . location . host } /callback` ); }, [ fiefAuth ]); const logout = useCallback (() => { // (3)! fiefAuth . logout ( ` ${ window . location . protocol } // ${ window . location . host } ` ); }, [ fiefAuth ]); return ( < ul > < li >< Link to = \"/\" > Public page < /Link></li> < li >< Link to = \"/private\" > Private page < /Link></li> < li > { ! isAuthenticated && < button type = \"button\" onClick = {() => login ()} > Login < /button>} { isAuthenticated && userinfo && ( < div > < span > { userinfo . email } < /span> < button type = \"button\" onClick = {() => logout ()} > Logout < /button> < /div> )} < /li> < /ul> ); }; export default Header ; Hook to get user information It'll return you an object with the user information, or null if no user is authenticated. Callback to redirect to Fief authentication page When the login button is clicked, this callback will redirect to the Fief authentication page. This is exactly the same thing we showed in the RequireAuth component. Callback to logout When the logout button is clicked, this callback will start the logout process. The FiefAuth helper takes care of clearing the local session and redirect to the Fief logout page so that the session on Fief's side can also be cleared. All it needs is the redirect URL where the user will be redirected after a successful logout. Here, we go back to the index route. React reference \u00b6 Components \u00b6 FiefAuthProvider \u00b6 Provides all the necessary context for Fief, especially the Fief client and user session state. Every component nested inside this component will have access to the Fief hooks. Parameters baseURL: string : Base URL of your Fief tenant. clientID: string : ID of your Fief client. clientSecret: string | undefined : Secret of your Fief client. It's not recommended to use it in the context of a browser app, since it can be easily found by the end-user in the source code. The recommended way is to use a Public client . encryptionKey: string | undefined : Encryption key of your Fief client. Necessary only if ID Token encryption is enabled. Hooks \u00b6 useFiefAuth \u00b6 Returns an instance of the FiefAuth browser helper . Example const fiefAuth = useFiefAuth (); useFiefIsAuthenticated \u00b6 Returns whether there is a valid user session. Example const isAuthenticated = useFiefIsAuthenticated (); useFiefTokenInfo \u00b6 Returns the token information object available in session, or null if no current session. Example const tokenInfo = useFiefTokenInfo () console . log ( tokenInfo ); // {\"access_token\": \"ACCESS_TOKEN\", \"id_token\": \"ID_TOKEN\", \"token_type\": \"bearer\", \"expires_in\": 3600} useFiefUserinfo \u00b6 Returns the user information object available in session, or null if no current session. Example const userinfo = useFiefUserinfo (); console . log ( userinfo );","title":"React"},{"location":"integrate/javascript/react/#react","text":"React is one of the most popular JavaScript framework to build dynamic applications for the browser. The Fief JavaScript client provides tools to help you integrate Fief authentication in your React project. Let's see how to use them!","title":"React"},{"location":"integrate/javascript/react/#install-the-client","text":"npm install @fief/fief","title":"Install the client"},{"location":"integrate/javascript/react/#application-example","text":"This is for you if... You want to handle all the OAuth authentication in your React application. Prerequisites You have a React project setup. Make sure your Fief Client is Public . Allow the following Redirect URI on your Fief Client: http://localhost:3000/callback In this example, we'll show you how to use the components and hooks provided by Fief to authenticate users and protect routes using React Router .","title":"Application example"},{"location":"integrate/javascript/react/#setup-fiefauthprovider","text":"The FiefAuthProvider is a component providing all the necessary context for Fief, especially the Fief client and user session state. Every component nested inside this component will have access to the Fief hooks. App.tsx import { FiefAuthProvider } from '@fief/fief/react' ; import { Routes , Route } from 'react-router-dom' ; import Callback from './Callback' ; import Public from './Public' ; import Private from './Private' ; import Header from './Header' ; import RequireAuth from './RequireAuth' ; function App () { return ( < FiefAuthProvider // (1)! baseURL = \"https://example.fief.dev\" clientId = \"YOUR_CLIENT_ID\" > < div className = \"App\" > < h1 > Fief React example < /h1> < Header /> { /* (2)! */ } < Routes > { /* (3)! */ } < Route path = \"/\" element = { < Public /> } /> { /* (4)! */ } < Route path = \"/private\" element = { < RequireAuth >< Private />< /RequireAuth>} / > { /* (5)! */ } < Route path = \"/callback\" element = { < Callback /> } /> { /* (6)! */ } < /Routes> < /div> < /FiefAuthProvider> ); } export default App ; Declare the FiefAuthProvider This is necessary to give to nested components the right Fief context and makes the hooks working. It takes as properties the same arguments as the Fief client. A Header component Contains the navigation. We'll detail it in a moment. The Routes component from React Router A public route This route will be accessible by any visitor, even if not logged in. A private route This route will be accessible only by logged in users. To do this, we wrap it in a RequireAuth component. We'll detail it in a moment. A callback route The route where Fief will redirect the user to after a successful login to complete the OAuth authentication. At this point, your React app has everything it needs to use Fief authentication tools!","title":"Setup FiefAuthProvider"},{"location":"integrate/javascript/react/#implement-callback-route","text":"After the user has successfully logged in on Fief, they will be redirected to your callback route. It needs to exchange the authorization code with a proper access token. The role of this route is then just to perform this task before redirecting to another route. Callback.tsx import { useFiefAuth } from '@fief/fief/react' ; import { useEffect } from 'react' ; import { useNavigate } from 'react-router-dom' ; const Callback : React.FunctionComponent = () => { const fiefAuth = useFiefAuth (); // (1)! const navigate = useNavigate (); useEffect (() => { fiefAuth . authCallback ( ` ${ window . location . protocol } // ${ window . location . host } /callback` ). then (() => { // (2)! navigate ( '/' ); }); }, [ fiefAuth , navigate ]); return ( < p > Callback !< /p> ); }; export default Callback ; Hook to get the FiefAuth class This is the browser helper provided by the Fief JavaScript client. We call the authCallback method This method takes care of everything: retrieving the authorization code in the query parameters, exchanging it with a fresh access token and save it in the browser session. Once the promise is resolved, all we have to do is to redirect back to the index page.","title":"Implement callback route"},{"location":"integrate/javascript/react/#protect-private-routes","text":"Usually, you'll need to prevent visitors from accessing a page if they're not logged in. To do this, we implement a simple component that'll check for the authentication state and automatically redirect to the Fief authentication page if the user is not logged in. RequireAuth.tsx import { useFiefAuth , useFiefIsAuthenticated } from '@fief/fief/react' ; import React , { useEffect } from 'react' ; const RequireAuth : React.FunctionComponent = ({ children }) => { const fiefAuth = useFiefAuth (); // (1)! const isAuthenticated = useFiefIsAuthenticated (); // (2)! useEffect (() => { if ( ! isAuthenticated ) { fiefAuth . redirectToLogin ( ` ${ window . location . protocol } // ${ window . location . host } /callback` ); // (3)! } }, [ fiefAuth , isAuthenticated ]); return ( <> { isAuthenticated && children } < /> ); }; export default RequireAuth ; Hook to get the FiefAuth class This is the browser helper provided by the Fief JavaScript client. Hook to get the authentication state This hook simply returns a boolean stating if a user is logged in or not. Redirect to Fief authentication page With this effect, we automatically redirect the user to the Fief authentication page so that they can log in. The redirectToLogin method only needs the redirect URL where the user will be redirected after a successful authentication on Fief: the /callback route.","title":"Protect private routes"},{"location":"integrate/javascript/react/#manage-authentication","text":"You have access to a set of hooks to help you manage the authentication state of the user, like retrieving their information, redirect them to the authentication page or logout them. In the example below, we show a simple header with navigation links and a login or logout button. Header.tsx import { useFiefAuth , useFiefIsAuthenticated , useFiefUserinfo } from '@fief/fief/react' ; import React , { useCallback } from 'react' ; import { Link } from 'react-router-dom' ; const Header : React.FunctionComponent = () => { const fiefAuth = useFiefAuth (); const isAuthenticated = useFiefIsAuthenticated (); const userinfo = useFiefUserinfo (); // (1)! const login = useCallback (() => { // (2)! fiefAuth . redirectToLogin ( ` ${ window . location . protocol } // ${ window . location . host } /callback` ); }, [ fiefAuth ]); const logout = useCallback (() => { // (3)! fiefAuth . logout ( ` ${ window . location . protocol } // ${ window . location . host } ` ); }, [ fiefAuth ]); return ( < ul > < li >< Link to = \"/\" > Public page < /Link></li> < li >< Link to = \"/private\" > Private page < /Link></li> < li > { ! isAuthenticated && < button type = \"button\" onClick = {() => login ()} > Login < /button>} { isAuthenticated && userinfo && ( < div > < span > { userinfo . email } < /span> < button type = \"button\" onClick = {() => logout ()} > Logout < /button> < /div> )} < /li> < /ul> ); }; export default Header ; Hook to get user information It'll return you an object with the user information, or null if no user is authenticated. Callback to redirect to Fief authentication page When the login button is clicked, this callback will redirect to the Fief authentication page. This is exactly the same thing we showed in the RequireAuth component. Callback to logout When the logout button is clicked, this callback will start the logout process. The FiefAuth helper takes care of clearing the local session and redirect to the Fief logout page so that the session on Fief's side can also be cleared. All it needs is the redirect URL where the user will be redirected after a successful logout. Here, we go back to the index route.","title":"Manage authentication"},{"location":"integrate/javascript/react/#react-reference","text":"","title":"React reference"},{"location":"integrate/javascript/react/#components","text":"","title":"Components"},{"location":"integrate/javascript/react/#fiefauthprovider","text":"Provides all the necessary context for Fief, especially the Fief client and user session state. Every component nested inside this component will have access to the Fief hooks. Parameters baseURL: string : Base URL of your Fief tenant. clientID: string : ID of your Fief client. clientSecret: string | undefined : Secret of your Fief client. It's not recommended to use it in the context of a browser app, since it can be easily found by the end-user in the source code. The recommended way is to use a Public client . encryptionKey: string | undefined : Encryption key of your Fief client. Necessary only if ID Token encryption is enabled.","title":"FiefAuthProvider"},{"location":"integrate/javascript/react/#hooks","text":"","title":"Hooks"},{"location":"integrate/javascript/react/#usefiefauth","text":"Returns an instance of the FiefAuth browser helper . Example const fiefAuth = useFiefAuth ();","title":"useFiefAuth"},{"location":"integrate/javascript/react/#usefiefisauthenticated","text":"Returns whether there is a valid user session. Example const isAuthenticated = useFiefIsAuthenticated ();","title":"useFiefIsAuthenticated"},{"location":"integrate/javascript/react/#usefieftokeninfo","text":"Returns the token information object available in session, or null if no current session. Example const tokenInfo = useFiefTokenInfo () console . log ( tokenInfo ); // {\"access_token\": \"ACCESS_TOKEN\", \"id_token\": \"ID_TOKEN\", \"token_type\": \"bearer\", \"expires_in\": 3600}","title":"useFiefTokenInfo"},{"location":"integrate/javascript/react/#usefiefuserinfo","text":"Returns the user information object available in session, or null if no current session. Example const userinfo = useFiefUserinfo (); console . log ( userinfo );","title":"useFiefUserinfo"},{"location":"integrate/python/","text":"Python \u00b6 We provide an official client for Python. You can install it with pip : pip install fief-client Create a Fief client \u00b6 Prerequisites Allow the following Redirect URI on your Fief Client: http://localhost:8000/callback The Fief client provides all the necessary methods to manage OAuth2 authentication, validate access tokens and refresh them. client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) Base URL of your Fief tenant You can find it in the admin dashboard, in the Tenants list. More info ID of your Fief client You can find it in the admin dashboard, in the Clients list. More info Info A first client is always created for you when you create your workspace. When getting started, you should use this one. Secret of your Fief client You can find it in the admin dashboard, in the Clients list. More info Info A first client is always created for you when you create your workspace. When getting started, you should use this one. Avoid to hardcode your secrets in your code It's usually not recommended to hardcode secrets like Client ID and Secret in your code like this. If your code gets published on the web, for example on GitHub, the security of your workspace would be compromised. Besides, it'll be harder if you need to deploy on several environments, like a staging or testing one, in addition to your production environment. A standard and widely-used approach is to use environment variables . Async support For asyncio enthusiasts, we also provide a FiefAsync class with the same methods. Perform an OAuth2 flow manually \u00b6 The simple script below shows you how to authenticate with OAuth2 \"manually\". The goal is to show you how to use the client. You'll then be able to integrate it in your own project with your framework and stack. The first step is to generate an authorization URL , which is an URL on the Fief server that'll ask you for your email address and password. client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) Then, we make the script prompt for the authorization code . client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) This temporary code is generated by Fief upon successful login and can be used to obtain valid tokens. Fief returns both an access token and an ID token , which contains information about the user. client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) Test it \u00b6 You can run this script from a command line: python client.py You'll get the following output: Open this URL in your browser: https://example.fief.dev/authorize?response_type=code&client_id=YOUR_CLIENT_ID&redirect_uri=http%3A%2F%2Flocalhost%3A8000%2Fcallback&scope=openid Paste the callback code: You can copy and paste this URL manually in your browser . You'll be redirected to a Fief login page. Upon successful login, Fief will redirect to the redirect URL you defined above, including a query parameter named code . It'll look like this: http://localhost:8000/redirect?code=wPEDiSRkoYOtA-4QCJHpsLne0P2PXVYAlW6hcH5OVBg Your browser will probably show an error at this point In this simple implementation, we don't have a web server running on our local machine, so the browser won't be able to open the redirect URL. It's not a problem: what we care about is retrieving the authorization code by hand. Copy the code value, get back to the command line where the script is running and paste it. You'll get the following output: Paste the callback code: wPEDiSRkoYOtA-4QCJHpsLne0P2PXVYAlW6hcH5OVBg Tokens: {'access_token': 'eyJhbGciOiJSUzI1NiJ9.eyJhdWQiOlsiRE9JaGpfNzJIYTlyWWg5dURnbmRTdTYyRVhKdUZmUTVsa2t4MS1rc1VJbyJdLCJhenAiOiJET0loal83MkhhOXJZaDl1RGduZFN1NjJFWEp1RmZRNWxra3gxLWtzVUlvIiwiZXhwIjoxNjQ4MDUwNDIzLCJpYXQiOjE2NDgwNDY4MjMsImlzcyI6Imh0dHBzOi8vZXhhbXBsZS5maWVmLmRldiIsInNjb3BlIjoib3BlbmlkIiwic3ViIjoiYTM4NDZjYzEtN2MwOC00Mzg5LThjOGUtYzBlNzlmNzA3NWZlIn0.R5JnZW9Vq6lWai-FZcqsihYxmtFRbIjZ7D0Ck9XAG0d2YnQQ7ms3bUwtXEAnLhos4C3paGDa0PzQRtXSAx4IH85ZdeVJoBk9GrOj1ZV7E6dtZZSZlvtY2msMeXFC9gNg-A86R9ZU_T0PoROof0u1eJHYVlmo_dv2fodyNqkDB8V6HK3vqf7jaqNQtk8Fg6eHKhwb-3bAtjb5cpWAAWhMSrHZzTWIYUvYsvwAas5ihgenv3UOkpcl_p7b7G9SDhGE5abPQQ7lvyfhYZE7CV1DzVRU6UL4N0D2l4uI3RJNOQoECvltfo2etYzp5viwAwvg9LUS3466Ra1i8beBKXsPFQ', 'id_token': 'eyJhbGciOiJSUzI1NiJ9.eyJhdWQiOlsiRE9JaGpfNzJIYTlyWWg5dURnbmRTdTYyRVhKdUZmUTVsa2t4MS1rc1VJbyJdLCJhenAiOiJET0loal83MkhhOXJZaDl1RGduZFN1NjJFWEp1RmZRNWxra3gxLWtzVUlvIiwiZW1haWwiOiJmcmFuY29pcyt0ZXN0QGZpZWYuZGV2IiwiZXhwIjoxNjQ4MDUwNDIzLCJpYXQiOjE2NDgwNDY4MjMsImlzcyI6Imh0dHBzOi8vZXhhbXBsZS5maWVmLmRldiIsInN1YiI6ImEzODQ2Y2MxLTdjMDgtNDM4OS04YzhlLWMwZTc5ZjcwNzVmZSIsInRlbmFudF9pZCI6IjcwNDEzNWI2LTRiZmQtNGM1NS04MDkwLWM2MzhhNmJhNTNhMiJ9.ULQy7TlgF5_oQwwgA6ydTahTYE31obr4F3olJy-mgyPw67XstoJLM1VwUNawzyz2Iu2QDmgcBrH3OMVfgCkBAFk2sp-QQIDr9arIF1QXNKG65El3zgPQ5-niTTsIuAkemyjNGcpdrcN2b9FaeodzauO5eOjno60h5dTBbcLnqv00V-Jv6sq8lB8_o5JXHKWUoZZA2VFEDox9MXfhDqrvyHcitsIRWIy7XhILKcZ-JG_AMcXnuDcyMnsoy91-gJznvMk7_ty9eNWs8Cm0ZhK3nMqEKML4tXIREmIN-vYUGDtbDWX3O45N98ovu9gJi9S3aVOh-gZQsnwauJmlW82ZQQ', 'token_type': 'bearer', 'expires_in': 3600} Userinfo: {'aud': ['YOUR_CLIENT_ID'], 'azp': 'YOUR_CLIENT_ID', 'email': 'anne@bretagne.duchy', 'exp': 1648050423, 'iat': 1648046823, 'iss': 'https://example.fief.dev', 'sub': 'a3846cc1-7c08-4389-8c8e-c0e79f7075fe', 'tenant_id': '704135b6-4bfd-4c55-8090-c638a6ba53a2'} As you can see, we obtained a first dictionary tokens containing an access token, an ID token and other standard OAuth2 information. The second variable, userinfo , is a dictionary with the user data. It's actually the information contained in the ID token that the client decoded for you. What's next? \u00b6 You have the fundamental basics for performing an OAuth2 authentication with the Fief Python client. To help you further, we provide you helpers and examples for popular Python frameworks like Flask or FastAPI. Integrate with FastAPI Integrate with Flask Reference \u00b6 Fief client \u00b6 Initializer base_url: str : Base URL of your Fief tenant. client_id: str : ID of your Fief client. client_secret: str : Secret of your Fief client. encryption_key: Optional[str] = None : Encryption key of your Fief client. Necessary only if ID Token encryption is enabled. auth_url \u00b6 Returns an authorization URL. Parameters redirect_uri: str : Your callback URI where the user will be redirected after Fief authentication. state: str = None : Optional string that will be returned back in the callback parameters to allow you to retrieve state information. scope: Optional[List[str]] = None : Optional list of scopes to ask for. code_challenge: Optional[str] = None : Optional code challenge for PKCE process . code_challenge_method: Optional[str] = None : Method used to hash the PKCE code challenge. extras_params: Optional[Dict[str, Any]] = None : Optional dictionary containing specific parameters. Example auth_url = fief . auth_url ( \"http://localhost:8000/callback\" , scope = [ \"openid\" ]) auth_callback \u00b6 Returns a FiefTokenResponse and FiefUserInfo in exchange of an authorization code. Parameters code: str : The authorization code. redirect_uri: str : The exact same redirect_uri you passed to the authorization URL. code_verifier: Optional[str] = None : The raw PCKE code used to generate the code challenge during authorization. Example tokens , userinfo = fief . auth_callback ( \"CODE\" , \"http://localhost:8000/callback\" ) auth_refresh_token \u00b6 Returns fresh FiefTokenResponse and FiefUserInfo in exchange of a refresh token. Parameters refresh_token: str : A valid refresh token. scope: Optional[List[str]] = None : Optional list of scopes to ask for. If not provided, the access token will share the same list of scopes as requested the first time. Otherwise, it should be a subset of the original list of scopes. Example tokens , userinfo = fief . auth_refresh_token ( \"REFRESH_TOKEN\" ) validate_access_token \u00b6 Checks if an access token is valid and optionally that it has a required list of scopes, or a required list of permissions . Returns a FiefAccessTokenInfo . Parameters access_token: str : The access token to validate. required_scope: Optional[List[str]] = None : Optional list of scopes to check for. required_permissions: Optional[List[str]] = None : Optional list of permissions to check for. Example: Validate access token with required scopes from fief_client import FiefAccessTokenInvalid , FiefAccessTokenExpired , FiefAccessTokenMissingScope try : access_token_info = fief . validate_access_token ( \"ACCESS_TOKEN\" , required_scope = [ \"required_scope\" ]) except FiefAccessTokenInvalid : print ( \"Invalid access token\" ) except FiefAccessTokenExpired : print ( \"Expired access token\" ) except FiefAccessTokenMissingScope : print ( \"Missing required scope\" ) print ( access_token_info ) Example: Validate access token with required permissions from fief_client import FiefAccessTokenInvalid , FiefAccessTokenExpired , FiefAccessTokenMissingPermission try : access_token_info = fief . validate_access_token ( \"ACCESS_TOKEN\" , required_permissions = [ \"castles:create\" , \"castles:read\" ]) except FiefAccessTokenInvalid : print ( \"Invalid access token\" ) except FiefAccessTokenExpired : print ( \"Expired access token\" ) except FiefAccessTokenMissingPermission : print ( \"Missing required permission\" ) print ( access_token_info ) userinfo \u00b6 Returns fresh FiefUserInfo from the Fief API using a valid access token. Parameters access_token: str : A valid access token Example userinfo = fief . userinfo ( \"ACCESS_TOKEN\" ) update_profile \u00b6 Updates user information with the Fief API using a valid access token. Parameters access_token: str : A valid access token data: Dict[str, Any] : A dictionary containing the data to update Update email address userinfo = fief . update_profile ( \"ACCESS_TOKEN\" , { \"email\" : \"anne@nantes.city\" }) Update password userinfo = fief . update_profile ( \"ACCESS_TOKEN\" , { \"password\" : \"hermine1\" }) Update user field To update user field values, you need to nest them into a fields dictionary, indexed by their slug. userinfo = fief . update_profile ( \"ACCESS_TOKEN\" , { \"fields\" : { \"first_name\" : \"Anne\" } }) logout_url \u00b6 Returns a logout URL. If you redirect the user to this page, Fief will clear the session stored on its side. You're still responsible for clearing your own session mechanism if any. Parameters redirect_uri: str : A valid URL where the user will be redirected after the logout process Example logout_url = fief . logout_url ( \"http://localhost:8000\" ) FiefTokenResponse \u00b6 Typed dictionary containing the tokens and related information returned by Fief after a successful authentication. Structure access_token: str : Access token you can use to call the Fief API id_token: str : ID token containing user information token_type: str : Type of token, usually bearer expires_int: int : Number of seconds after which the tokens will expire refresh_token: Optional[str] : Token provided only if scope offline_access was granted. Allows you to retrieve fresh tokens using the auth_refresh_token method. FiefAccessTokenInfo \u00b6 Typed dictionary containing information about the access token. Structure id: uuid.UUID : ID of the user scope: List[str] : List of granted scopes for this access token permissions: List[str] : List of granted permissions for this user access_token: str : Access token you can use to call the Fief API Example { \"id\" : \"aeeb8bfa-e8f4-4724-9427-c3d5af66190e\" , \"scope\" : [ \"openid\" , \"required_scope\" ], \"permissions\" : [ \"castles:read\" , \"castles:create\" , \"castles:update\" , \"castles:delete\" ], \"access_token\" : \"ACCESS_TOKEN\" , } FiefUserInfo \u00b6 Dictionary containing user information. Structure sub: str : ID of the user email: str : Email address of the user tenant_id: str : ID of the tenant associated to the user Available user fields values for this user, indexed by their slug. Example { \"sub\" : \"aeeb8bfa-e8f4-4724-9427-c3d5af66190e\" , \"email\" : \"anne@bretagne.duchy\" , \"tenant_id\" : \"c91ecb7f-359c-4244-8385-51ecd6c0d06b\" , \"first_name\" : \"Anne\" , \"last_name\" : \"De Bretagne\" , }","title":"General"},{"location":"integrate/python/#python","text":"We provide an official client for Python. You can install it with pip : pip install fief-client","title":"Python"},{"location":"integrate/python/#create-a-fief-client","text":"Prerequisites Allow the following Redirect URI on your Fief Client: http://localhost:8000/callback The Fief client provides all the necessary methods to manage OAuth2 authentication, validate access tokens and refresh them. client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) Base URL of your Fief tenant You can find it in the admin dashboard, in the Tenants list. More info ID of your Fief client You can find it in the admin dashboard, in the Clients list. More info Info A first client is always created for you when you create your workspace. When getting started, you should use this one. Secret of your Fief client You can find it in the admin dashboard, in the Clients list. More info Info A first client is always created for you when you create your workspace. When getting started, you should use this one. Avoid to hardcode your secrets in your code It's usually not recommended to hardcode secrets like Client ID and Secret in your code like this. If your code gets published on the web, for example on GitHub, the security of your workspace would be compromised. Besides, it'll be harder if you need to deploy on several environments, like a staging or testing one, in addition to your production environment. A standard and widely-used approach is to use environment variables . Async support For asyncio enthusiasts, we also provide a FiefAsync class with the same methods.","title":"Create a Fief client"},{"location":"integrate/python/#perform-an-oauth2-flow-manually","text":"The simple script below shows you how to authenticate with OAuth2 \"manually\". The goal is to show you how to use the client. You'll then be able to integrate it in your own project with your framework and stack. The first step is to generate an authorization URL , which is an URL on the Fief server that'll ask you for your email address and password. client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) Then, we make the script prompt for the authorization code . client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" ) This temporary code is generated by Fief upon successful login and can be used to obtain valid tokens. Fief returns both an access token and an ID token , which contains information about the user. client.py from fief_client import Fief fief = Fief ( \"https://example.fief.dev\" , # (1)! \"YOUR_CLIENT_ID\" , # (2)! \"YOUR_CLIENT_SECRET\" , # (3)! ) redirect_url = \"http://localhost:8000/callback\" auth_url = fief . auth_url ( redirect_url , scope = [ \"openid\" ]) print ( f \"Open this URL in your browser: { auth_url } \" ) code = input ( \"Paste the callback code: \" ) tokens , userinfo = fief . auth_callback ( code , redirect_url ) print ( f \"Tokens: { tokens } \" ) print ( f \"Userinfo: { userinfo } \" )","title":"Perform an OAuth2 flow manually"},{"location":"integrate/python/#test-it","text":"You can run this script from a command line: python client.py You'll get the following output: Open this URL in your browser: https://example.fief.dev/authorize?response_type=code&client_id=YOUR_CLIENT_ID&redirect_uri=http%3A%2F%2Flocalhost%3A8000%2Fcallback&scope=openid Paste the callback code: You can copy and paste this URL manually in your browser . You'll be redirected to a Fief login page. Upon successful login, Fief will redirect to the redirect URL you defined above, including a query parameter named code . It'll look like this: http://localhost:8000/redirect?code=wPEDiSRkoYOtA-4QCJHpsLne0P2PXVYAlW6hcH5OVBg Your browser will probably show an error at this point In this simple implementation, we don't have a web server running on our local machine, so the browser won't be able to open the redirect URL. It's not a problem: what we care about is retrieving the authorization code by hand. Copy the code value, get back to the command line where the script is running and paste it. You'll get the following output: Paste the callback code: wPEDiSRkoYOtA-4QCJHpsLne0P2PXVYAlW6hcH5OVBg Tokens: {'access_token': 'eyJhbGciOiJSUzI1NiJ9.eyJhdWQiOlsiRE9JaGpfNzJIYTlyWWg5dURnbmRTdTYyRVhKdUZmUTVsa2t4MS1rc1VJbyJdLCJhenAiOiJET0loal83MkhhOXJZaDl1RGduZFN1NjJFWEp1RmZRNWxra3gxLWtzVUlvIiwiZXhwIjoxNjQ4MDUwNDIzLCJpYXQiOjE2NDgwNDY4MjMsImlzcyI6Imh0dHBzOi8vZXhhbXBsZS5maWVmLmRldiIsInNjb3BlIjoib3BlbmlkIiwic3ViIjoiYTM4NDZjYzEtN2MwOC00Mzg5LThjOGUtYzBlNzlmNzA3NWZlIn0.R5JnZW9Vq6lWai-FZcqsihYxmtFRbIjZ7D0Ck9XAG0d2YnQQ7ms3bUwtXEAnLhos4C3paGDa0PzQRtXSAx4IH85ZdeVJoBk9GrOj1ZV7E6dtZZSZlvtY2msMeXFC9gNg-A86R9ZU_T0PoROof0u1eJHYVlmo_dv2fodyNqkDB8V6HK3vqf7jaqNQtk8Fg6eHKhwb-3bAtjb5cpWAAWhMSrHZzTWIYUvYsvwAas5ihgenv3UOkpcl_p7b7G9SDhGE5abPQQ7lvyfhYZE7CV1DzVRU6UL4N0D2l4uI3RJNOQoECvltfo2etYzp5viwAwvg9LUS3466Ra1i8beBKXsPFQ', 'id_token': 'eyJhbGciOiJSUzI1NiJ9.eyJhdWQiOlsiRE9JaGpfNzJIYTlyWWg5dURnbmRTdTYyRVhKdUZmUTVsa2t4MS1rc1VJbyJdLCJhenAiOiJET0loal83MkhhOXJZaDl1RGduZFN1NjJFWEp1RmZRNWxra3gxLWtzVUlvIiwiZW1haWwiOiJmcmFuY29pcyt0ZXN0QGZpZWYuZGV2IiwiZXhwIjoxNjQ4MDUwNDIzLCJpYXQiOjE2NDgwNDY4MjMsImlzcyI6Imh0dHBzOi8vZXhhbXBsZS5maWVmLmRldiIsInN1YiI6ImEzODQ2Y2MxLTdjMDgtNDM4OS04YzhlLWMwZTc5ZjcwNzVmZSIsInRlbmFudF9pZCI6IjcwNDEzNWI2LTRiZmQtNGM1NS04MDkwLWM2MzhhNmJhNTNhMiJ9.ULQy7TlgF5_oQwwgA6ydTahTYE31obr4F3olJy-mgyPw67XstoJLM1VwUNawzyz2Iu2QDmgcBrH3OMVfgCkBAFk2sp-QQIDr9arIF1QXNKG65El3zgPQ5-niTTsIuAkemyjNGcpdrcN2b9FaeodzauO5eOjno60h5dTBbcLnqv00V-Jv6sq8lB8_o5JXHKWUoZZA2VFEDox9MXfhDqrvyHcitsIRWIy7XhILKcZ-JG_AMcXnuDcyMnsoy91-gJznvMk7_ty9eNWs8Cm0ZhK3nMqEKML4tXIREmIN-vYUGDtbDWX3O45N98ovu9gJi9S3aVOh-gZQsnwauJmlW82ZQQ', 'token_type': 'bearer', 'expires_in': 3600} Userinfo: {'aud': ['YOUR_CLIENT_ID'], 'azp': 'YOUR_CLIENT_ID', 'email': 'anne@bretagne.duchy', 'exp': 1648050423, 'iat': 1648046823, 'iss': 'https://example.fief.dev', 'sub': 'a3846cc1-7c08-4389-8c8e-c0e79f7075fe', 'tenant_id': '704135b6-4bfd-4c55-8090-c638a6ba53a2'} As you can see, we obtained a first dictionary tokens containing an access token, an ID token and other standard OAuth2 information. The second variable, userinfo , is a dictionary with the user data. It's actually the information contained in the ID token that the client decoded for you.","title":"Test it"},{"location":"integrate/python/#whats-next","text":"You have the fundamental basics for performing an OAuth2 authentication with the Fief Python client. To help you further, we provide you helpers and examples for popular Python frameworks like Flask or FastAPI. Integrate with FastAPI Integrate with Flask","title":"What's next?"},{"location":"integrate/python/#reference","text":"","title":"Reference"},{"location":"integrate/python/#fief-client","text":"Initializer base_url: str : Base URL of your Fief tenant. client_id: str : ID of your Fief client. client_secret: str : Secret of your Fief client. encryption_key: Optional[str] = None : Encryption key of your Fief client. Necessary only if ID Token encryption is enabled.","title":"Fief client"},{"location":"integrate/python/#auth_url","text":"Returns an authorization URL. Parameters redirect_uri: str : Your callback URI where the user will be redirected after Fief authentication. state: str = None : Optional string that will be returned back in the callback parameters to allow you to retrieve state information. scope: Optional[List[str]] = None : Optional list of scopes to ask for. code_challenge: Optional[str] = None : Optional code challenge for PKCE process . code_challenge_method: Optional[str] = None : Method used to hash the PKCE code challenge. extras_params: Optional[Dict[str, Any]] = None : Optional dictionary containing specific parameters. Example auth_url = fief . auth_url ( \"http://localhost:8000/callback\" , scope = [ \"openid\" ])","title":"auth_url"},{"location":"integrate/python/#auth_callback","text":"Returns a FiefTokenResponse and FiefUserInfo in exchange of an authorization code. Parameters code: str : The authorization code. redirect_uri: str : The exact same redirect_uri you passed to the authorization URL. code_verifier: Optional[str] = None : The raw PCKE code used to generate the code challenge during authorization. Example tokens , userinfo = fief . auth_callback ( \"CODE\" , \"http://localhost:8000/callback\" )","title":"auth_callback"},{"location":"integrate/python/#auth_refresh_token","text":"Returns fresh FiefTokenResponse and FiefUserInfo in exchange of a refresh token. Parameters refresh_token: str : A valid refresh token. scope: Optional[List[str]] = None : Optional list of scopes to ask for. If not provided, the access token will share the same list of scopes as requested the first time. Otherwise, it should be a subset of the original list of scopes. Example tokens , userinfo = fief . auth_refresh_token ( \"REFRESH_TOKEN\" )","title":"auth_refresh_token"},{"location":"integrate/python/#validate_access_token","text":"Checks if an access token is valid and optionally that it has a required list of scopes, or a required list of permissions . Returns a FiefAccessTokenInfo . Parameters access_token: str : The access token to validate. required_scope: Optional[List[str]] = None : Optional list of scopes to check for. required_permissions: Optional[List[str]] = None : Optional list of permissions to check for. Example: Validate access token with required scopes from fief_client import FiefAccessTokenInvalid , FiefAccessTokenExpired , FiefAccessTokenMissingScope try : access_token_info = fief . validate_access_token ( \"ACCESS_TOKEN\" , required_scope = [ \"required_scope\" ]) except FiefAccessTokenInvalid : print ( \"Invalid access token\" ) except FiefAccessTokenExpired : print ( \"Expired access token\" ) except FiefAccessTokenMissingScope : print ( \"Missing required scope\" ) print ( access_token_info ) Example: Validate access token with required permissions from fief_client import FiefAccessTokenInvalid , FiefAccessTokenExpired , FiefAccessTokenMissingPermission try : access_token_info = fief . validate_access_token ( \"ACCESS_TOKEN\" , required_permissions = [ \"castles:create\" , \"castles:read\" ]) except FiefAccessTokenInvalid : print ( \"Invalid access token\" ) except FiefAccessTokenExpired : print ( \"Expired access token\" ) except FiefAccessTokenMissingPermission : print ( \"Missing required permission\" ) print ( access_token_info )","title":"validate_access_token"},{"location":"integrate/python/#userinfo","text":"Returns fresh FiefUserInfo from the Fief API using a valid access token. Parameters access_token: str : A valid access token Example userinfo = fief . userinfo ( \"ACCESS_TOKEN\" )","title":"userinfo"},{"location":"integrate/python/#update_profile","text":"Updates user information with the Fief API using a valid access token. Parameters access_token: str : A valid access token data: Dict[str, Any] : A dictionary containing the data to update Update email address userinfo = fief . update_profile ( \"ACCESS_TOKEN\" , { \"email\" : \"anne@nantes.city\" }) Update password userinfo = fief . update_profile ( \"ACCESS_TOKEN\" , { \"password\" : \"hermine1\" }) Update user field To update user field values, you need to nest them into a fields dictionary, indexed by their slug. userinfo = fief . update_profile ( \"ACCESS_TOKEN\" , { \"fields\" : { \"first_name\" : \"Anne\" } })","title":"update_profile"},{"location":"integrate/python/#logout_url","text":"Returns a logout URL. If you redirect the user to this page, Fief will clear the session stored on its side. You're still responsible for clearing your own session mechanism if any. Parameters redirect_uri: str : A valid URL where the user will be redirected after the logout process Example logout_url = fief . logout_url ( \"http://localhost:8000\" )","title":"logout_url"},{"location":"integrate/python/#fieftokenresponse","text":"Typed dictionary containing the tokens and related information returned by Fief after a successful authentication. Structure access_token: str : Access token you can use to call the Fief API id_token: str : ID token containing user information token_type: str : Type of token, usually bearer expires_int: int : Number of seconds after which the tokens will expire refresh_token: Optional[str] : Token provided only if scope offline_access was granted. Allows you to retrieve fresh tokens using the auth_refresh_token method.","title":"FiefTokenResponse"},{"location":"integrate/python/#fiefaccesstokeninfo","text":"Typed dictionary containing information about the access token. Structure id: uuid.UUID : ID of the user scope: List[str] : List of granted scopes for this access token permissions: List[str] : List of granted permissions for this user access_token: str : Access token you can use to call the Fief API Example { \"id\" : \"aeeb8bfa-e8f4-4724-9427-c3d5af66190e\" , \"scope\" : [ \"openid\" , \"required_scope\" ], \"permissions\" : [ \"castles:read\" , \"castles:create\" , \"castles:update\" , \"castles:delete\" ], \"access_token\" : \"ACCESS_TOKEN\" , }","title":"FiefAccessTokenInfo"},{"location":"integrate/python/#fiefuserinfo","text":"Dictionary containing user information. Structure sub: str : ID of the user email: str : Email address of the user tenant_id: str : ID of the tenant associated to the user Available user fields values for this user, indexed by their slug. Example { \"sub\" : \"aeeb8bfa-e8f4-4724-9427-c3d5af66190e\" , \"email\" : \"anne@bretagne.duchy\" , \"tenant_id\" : \"c91ecb7f-359c-4244-8385-51ecd6c0d06b\" , \"first_name\" : \"Anne\" , \"last_name\" : \"De Bretagne\" , }","title":"FiefUserInfo"},{"location":"integrate/python/fastapi/","text":"FastAPI \u00b6 FastAPI is one of the fastest-growing Python web framework. It features impressive performance and top-notch developer experience. Actually, the Fief server itself is implemented with FastAPI! The Fief Python client provides tools to help you integrate Fief authentication in your FastAPI project. Let's see how to use them! Install the client \u00b6 Install the Fief client with the optional FastAPI dependencies: pip install \"fief-client[fastapi]\" API example \u00b6 This is for you if... Your FastAPI backend will work as a pure REST API. You have a separate frontend, like a JavaScript or mobile app, that'll take care of the OAuth2 flow. Prerequisites Check that the following Redirect URI is allowed on your Fief Client: http://localhost:8000/docs/oauth2-redirect In this first example, we'll leverage the interactive documentation generated by FastAPI to perform the OAuth2 authentication. The goal here is just to show you how to protect your API route with a Fief access token . app.py from fastapi import Depends , FastAPI from fastapi.security import OAuth2AuthorizationCodeBearer from fief_client import FiefAccessTokenInfo , FiefAsync from fief_client.integrations.fastapi import FiefAuth fief = FiefAsync ( # (1)! \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) scheme = OAuth2AuthorizationCodeBearer ( # (2)! \"https://example.fief.dev/authorize\" , \"https://example.fief.dev/api/token\" , scopes = { \"openid\" : \"openid\" , \"offline_access\" : \"offline_access\" }, ) auth = FiefAuth ( fief , scheme ) # (3)! app = FastAPI () @app . get ( \"/user\" ) async def get_user ( access_token_info : FiefAccessTokenInfo = Depends ( auth . authenticated ()), # (4)! ): return access_token_info Fief client instantiation As we showed in the standard Python section , we instantiate here a Fief client here with the base tenant URL and client credentials. Notice here that we use the FiefAsync class. FastAPI being an ASGI framework, it's always nice to take advantage of asyncio capabilities. OpenAPI security scheme FastAPI uses those security schemes to generate an interactive documentation showing the right interface to authenticate with the API. We use here a standard OAuth2 interface. Fief helper for FastAPI This is the helper doing the tedious work for you with FastAPI. All it needs is an instance of the Fief client and the scheme. authenticated dependency This is where the magic happens: in pure FastAPI style, FiefAuth gives you a authenticated dependency to check for the access token and optionally for required scopes. If everything goes well, you'll get a dictionary containing the ID of the user, the list of allowed scopes and the raw access token. And that's about it! Test it \u00b6 You can run this example just like you would do for any FastAPI app: uvicorn app:app Open http://localhost:8000/docs to access the interactive documentation. Let's try first the /user endpoint: We get an 401 error! That's expected: we are not authenticated yet ! Let's fix that: click on the Authorize button to start the authentication process. You'll need to provide your client ID and secret and select the scopes. Click on the Authorize button: you are redirected to the Fief login page. Upon successful login, you will be redirected back to the interactive documentation: a valid access token has been generated! You can now try the /user endpoint to check the result: Notice how the interactive documentation passed the access token in the Authorization header of the request! Besides, the response does contain the user ID, the list of allowed scopes and the access token itself. Checking for scopes \u00b6 Building on the previous example, you can make your endpoint requires the access token to be granted a list of scopes . Simply add this list of scopes as a keyword parameter of the authenticated dependency. app.py from fastapi import Depends , FastAPI from fastapi.security import OAuth2AuthorizationCodeBearer from fief_client import FiefAccessTokenInfo , FiefAsync from fief_client.integrations.fastapi import FiefAuth fief = FiefAsync ( \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) scheme = OAuth2AuthorizationCodeBearer ( \"https://example.fief.dev/authorize\" , \"https://example.fief.dev/api/token\" , scopes = { \"openid\" : \"openid\" , \"offline_access\" : \"offline_access\" }, ) auth = FiefAuth ( fief , scheme ) app = FastAPI () @app . get ( \"/user\" ) async def get_user ( access_token_info : FiefAccessTokenInfo = Depends ( auth . authenticated ( scope = [ \"openid\" , \"required_scope\" ]) ), ): return access_token_info If one of the required scope is missing on the access token, a 403 Forbidden error will automatically be returned. Checking for permissions \u00b6 Similary, you can make your endpoint requires the user to be granted a list of permissions . Simply add this list of permissions as a keyword parameter of the authenticated dependency. app.py from fastapi import Depends , FastAPI from fastapi.security import OAuth2AuthorizationCodeBearer from fief_client import FiefAccessTokenInfo , FiefAsync from fief_client.integrations.fastapi import FiefAuth fief = FiefAsync ( \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) scheme = OAuth2AuthorizationCodeBearer ( \"https://example.fief.dev/authorize\" , \"https://example.fief.dev/api/token\" , scopes = { \"openid\" : \"openid\" , \"offline_access\" : \"offline_access\" }, ) auth = FiefAuth ( fief , scheme ) app = FastAPI () @app . get ( \"/user\" ) async def get_user ( access_token_info : FiefAccessTokenInfo = Depends ( auth . authenticated ( permissions = [ \"castles:read\" ]) ), ): return access_token_info If one of the required permission is missing on ther user, a 403 Forbidden error will automatically be returned. Web application example \u00b6 This is for you if... Your FastAPI backend will render HTML pages. Your application is intended to be used in a browser. Prerequisites Allow the following Redirect URI on your Fief Client: http://localhost:8000/auth-callback The examples we showed previously are working well in a pure REST API context: a frontend, like interactive documentation, a JavaScript application or a mobile app will take care of the OAuth2 authentication flow to retrieve an access token before making request to your API. Another common context is traditional web application , where the server takes care of generating HTML pages before returning it to the browser. In this case, we'll need some routes to redirect the user to the Fief login page if they're not authenticated and take care of storing the access token somewhere. This is what'll show in this example. Besides, we'll usually need the basic information about the authenticated user, like its email or the values of the custom user fields . We'll see how we can use it. Basically, here's what we'll do: This time, we'll expect the access token to be passed through a traditional cookie instead of an HTTP header. Cookies are very convenient when designing web apps because they are handled automatically by the browser. If the cookie is not present, we'll redirect the user to the Fief login page . Once again, the browser will help us a lot here since it'll automatically follow the redirection. Upon successful login, Fief will automatically redirect the user to the callback route . This callback route will take care of setting a new cookie containing the access token . It means that the access token will be safely stored in the browser memory. Finally, the user is redirected back to the protected route. The browser will automatically send the cookie containing the access token: our request is now authenticated! app.py from datetime import datetime from fastapi import Depends , FastAPI , HTTPException , Query , Request , Response , status from fastapi.responses import HTMLResponse , RedirectResponse from fastapi.security import APIKeyCookie from fief_client import FiefAsync , FiefUserInfo from fief_client.integrations.fastapi import FiefAuth class CustomFiefAuth ( FiefAuth ): # (1)! client : FiefAsync async def get_unauthorized_response ( self , request : Request , response : Response ): redirect_uri = request . url_for ( \"auth_callback\" ) # (2)! auth_url = await self . client . auth_url ( redirect_uri , scope = [ \"openid\" ]) # (3)! raise HTTPException ( status_code = status . HTTP_307_TEMPORARY_REDIRECT , # (4)! headers = { \"Location\" : auth_url }, ) fief = FiefAsync ( # (5)! \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) SESSION_COOKIE_NAME = \"user_session\" scheme = APIKeyCookie ( name = SESSION_COOKIE_NAME , auto_error = False ) # (6)! auth = CustomFiefAuth ( fief , scheme ) # (7)! app = FastAPI () @app . get ( \"/auth-callback\" , name = \"auth_callback\" ) # (8)! async def auth_callback ( request : Request , response : Response , code : str = Query ( ... )): redirect_uri = request . url_for ( \"auth_callback\" ) tokens , _ = await fief . auth_callback ( code , redirect_uri ) # (9)! response = RedirectResponse ( request . url_for ( \"protected\" )) # (10)! response . set_cookie ( # (11)! SESSION_COOKIE_NAME , tokens [ \"access_token\" ], expires = int ( datetime . now () . timestamp () + tokens [ \"expires_in\" ]), httponly = True , # (12)! secure = False , # \u274c Set this to `True` in production (13)! ) return response @app . get ( \"/protected\" , name = \"protected\" ) async def protected ( user : FiefUserInfo = Depends ( auth . current_user ()), # (14)! ): return HTMLResponse ( f \"<h1>You are authenticated. Your user email is { user [ 'email' ] } </h1>\" ) We customize the FiefAuth helper to fit our needs The base class is implemented with an API scenario in mind. Nevertheless, it's designed in a way you can customize its behavior when the user is not authenticated or has not the required scope. That's what'll do with the get_unauthorized_response . We build the redirect URL This points to our /auth-callback route that we define below. We generate an authorization URL on the Fief server Thanks to the auth_url method on the Fief client, we can automatically generate the authorization URL on the Fief server. We build a redirect response By setting a status code in the 3XX range, we tell the browser that it should redirect the user to another URL, specified in the Location header. You can read more about HTTP redirections on the MDN documentation . This doesn't change from the previous example The FiefAsync client is always at the heart of the integration \ud83d\ude09 We use a scheme expecting a cookie Contrary to the previous examples, we expect the access token to be passed in a cookie. Thus, we use a dedicated scheme for that. Notice that we set the name of this cookie through the SESSION_COOKIE_NAME constant. Besides, we set the auto_error argument to False . It tells FastAPI user to bypass its built-in error response if the cookie is not present: we have our own logic to handle this. We use our custom CustomFiefAuth class Of course, now that we overloaded the behavior of this helper class, we shouldn't forget to actually use it! We implement an /auth-callback route This is the route that'll take care of exchanging the authorization code with a fresh access token and save it in a cookie. Notice that we set its name parameter: this is how we can generate its URL automatically with the request.url_for method. We generate an access token We finish the OAuth2 flow by exchanging the authorization code with a fresh access token. We build a redirection to the /protected route The user will now be correctly authenticated to our web application. Thus, we can redirect them to a protected page. We build a new cookie containing the access token The response will contain a Set-Cookie header instructing the browser to save the access token in its memory. This method allows us to configure each properties of the cookie. You can read more about HTTP cookies on the MDN documentation . Set the cookie as HTTPOnly For such sensitive values, it's strongly recommended to set the cookie as HTTPOnly . It means that it won't be possible to read its value from JavaScript, reducing potential attacks. Set the cookie as secure in production For such sensitive values, it's strongly recommended to set the cookie as Secure . It tells the browser to send the cookie only on HTTPS (SSL) connection, reducing the risk of the access token to be stolen by a attacker between the client and the server. However, in a local environment, you usually don't serve your application with SSL. That's why we set it to False in this example. A common approach to handle this is to have an environment variable to control this parameter, so you can disable it in local and enable it in production. Use the current_user dependency This time, we use the current_user dependency instead of authenticated . Under the hood, it'll stil call authenticated and check if the cookie is available in the request and proceed if everything goes well. However, it'll return you a FiefUserInfo dictionary containing the data of the user. If the request is not authenticated, our custom get_unauthorized_response will be called and the user will be redirected to the Fief login page. That's it! If you run this application and go to http://localhost:8000/protected , you'll be redirected to the Fief login page and experience the authentication flow before getting back to this route with a proper authentication cookie. Read the next example for a more optimal implementation In this example, the user information is not cached . For the performance of your application, we highly recommend you to read the next example. current_user can also check for scope and permissions In a similar way as we shown in the API example , you can also require the access token to be granted a list of scopes or the user to be granted a list of permissions . async def protected ( user : FiefUserInfo = Depends ( auth . current_user ( scope = [ \"openid\" , \"required_scope\" ])), ): ... async def protected ( user : FiefUserInfo = Depends ( auth . current_user ( permissions = [ \"castles:read\" ])), ): ... Caching user information \u00b6 In the previous example, we didn't set up cache for the user information. It means that everytime we hit the /protected route, the Fief API will be called to get the data. Obviously, this is not very optimal. Let's fix this! Fortunately, the client provides you useful tools to help you with this. Building upon the previous example, let's see how we can cache user information. app.py import uuid from datetime import datetime from typing import Dict , Optional from fastapi import Depends , FastAPI , HTTPException , Query , Request , Response , status from fastapi.responses import HTMLResponse , RedirectResponse from fastapi.security import APIKeyCookie from fief_client import FiefAsync , FiefUserInfo from fief_client.integrations.fastapi import FiefAuth class CustomFiefAuth ( FiefAuth ): client : FiefAsync async def get_unauthorized_response ( self , request : Request , response : Response ): redirect_uri = request . url_for ( \"auth_callback\" ) auth_url = await self . client . auth_url ( redirect_uri , scope = [ \"openid\" ]) raise HTTPException ( status_code = status . HTTP_307_TEMPORARY_REDIRECT , headers = { \"Location\" : auth_url }, ) class MemoryUserInfoCache : # (1)! def __init__ ( self ) -> None : self . storage : Dict [ uuid . UUID , FiefUserInfo ] = {} # (2)! async def get ( self , user_id : uuid . UUID ) -> Optional [ FiefUserInfo ]: # (3)! return self . storage . get ( user_id ) async def set ( self , user_id : uuid . UUID , userinfo : FiefUserInfo ) -> None : # (4)! self . storage [ user_id ] = userinfo memory_userinfo_cache = MemoryUserInfoCache () # (5)! async def get_memory_userinfo_cache () -> MemoryUserInfoCache : # (6)! return memory_userinfo_cache fief = FiefAsync ( \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) SESSION_COOKIE_NAME = \"user_session\" scheme = APIKeyCookie ( name = SESSION_COOKIE_NAME , auto_error = False ) auth = CustomFiefAuth ( fief , scheme , get_userinfo_cache = get_memory_userinfo_cache # (7)! ) app = FastAPI () @app . get ( \"/auth-callback\" , name = \"auth_callback\" ) async def auth_callback ( request : Request , response : Response , code : str = Query ( ... ), memory_userinfo_cache : MemoryUserInfoCache = Depends ( # (8)! get_memory_userinfo_cache ), ): redirect_uri = request . url_for ( \"auth_callback\" ) tokens , userinfo = await fief . auth_callback ( code , redirect_uri ) response = RedirectResponse ( request . url_for ( \"protected\" )) response . set_cookie ( SESSION_COOKIE_NAME , tokens [ \"access_token\" ], expires = int ( datetime . now () . timestamp () + tokens [ \"expires_in\" ]), httponly = True , secure = False , ) await memory_userinfo_cache . set ( uuid . UUID ( userinfo [ \"sub\" ]), userinfo ) # (9)! return response @app . get ( \"/protected\" , name = \"protected\" ) async def protected ( user : FiefUserInfo = Depends ( auth . current_user ()), # (10)! ): return HTMLResponse ( f \"<h1>You are authenticated. Your user email is { user [ 'email' ] } </h1>\" ) We start by implementing an helper class to store the user information somewhere The implementation is completely up-to-you and could be something rather complex, like using a Redis server to cache this information. We'll see that it expects you to implement two methods for working correctly with FiefAuth . We store the data in memory using a dictionary This is a very simple approach that will just store the data in memory. If your server is rebooted, the cache will be lost. It can work quite well when starting, but you'll probably need more robust approaches in the long run. The good thing is that you'll only need to change this class when the time comes! We implement the .get method This is the first compulsory method you have to implement in the class. It accepts an user ID as argument and expects you to return a cached FiefUserInfo dictionary or None if not available. Here, we simply read from our dictionary. We implement the .set method This is the second and last compulsory method you have to implement in the class. It accepts an user ID and a FiefUserInfo dictionary as arguments. There, you'll need to store this data in cache. Here, we simply set the user information into our dictionary. We instantiate MemoryUserInfoCache globally In order to have a global memory cache, we instantiate our class in the global context, at the same time of our FastAPI app. This way, the dictionary will be initialized at the same time our app is launched. Depending on your implementation, this may not be needed. We could also imagine to have a fresh instance every time we use it. This is typically the case when using database sessions for example. We define a callable dependency to get our class This pattern is typical of FastAPI. With a callable dependency, we are able to tell FastAPI to automatically instantiate objects, potentially needing other sub-dependencies as well. This is especially handy if you already have a dependency taking care of returning you a database connection or a session object for example. In our example here, we don't have any complex dependency, so we can just directly return the memory_userinfo_cache instance. We add the get_userinfo_cache argument to CustomFiefAuth This is an optional keyword argument that basically tells FiefAuth to use the caching class returned by get_userinfo_cache when you want to get the user information. That's why it's important to strictly follow the methods signature presented above: FiefAuth will call them inside its logic. We add memory_userinfo_cache as a dependency to auth_callback When a user has successfully authenticated, we do not only get the access token: we also get an ID token which already contains the user information. Hence, we'll take this opportunity to store it in our cache! Since we defined it as a callable dependency, we can directly use get_memory_userinfo_cache inside our route to use it. We cache the user information The ID token is automatically decoded by fief.auth_callback method. Thus, we just have to use our cache to store it! The current_user dependency doesn't change Nothing changes here! Now that we have set a get_userinfo_cache dependency, current_user will automatically use it to return you the user information. If it's not present in cache, it'll hit the Fief API. Note that you can use auth.current_user(refresh=True) if you need to always retrieve fresh data from the Fief API. That's it! Now, we won't retrieve user information from the Fief API at each request. Typically, we'll set it in cache when the user authenticates and it'll be used during the lifetime of the session.","title":"FastAPI"},{"location":"integrate/python/fastapi/#fastapi","text":"FastAPI is one of the fastest-growing Python web framework. It features impressive performance and top-notch developer experience. Actually, the Fief server itself is implemented with FastAPI! The Fief Python client provides tools to help you integrate Fief authentication in your FastAPI project. Let's see how to use them!","title":"FastAPI"},{"location":"integrate/python/fastapi/#install-the-client","text":"Install the Fief client with the optional FastAPI dependencies: pip install \"fief-client[fastapi]\"","title":"Install the client"},{"location":"integrate/python/fastapi/#api-example","text":"This is for you if... Your FastAPI backend will work as a pure REST API. You have a separate frontend, like a JavaScript or mobile app, that'll take care of the OAuth2 flow. Prerequisites Check that the following Redirect URI is allowed on your Fief Client: http://localhost:8000/docs/oauth2-redirect In this first example, we'll leverage the interactive documentation generated by FastAPI to perform the OAuth2 authentication. The goal here is just to show you how to protect your API route with a Fief access token . app.py from fastapi import Depends , FastAPI from fastapi.security import OAuth2AuthorizationCodeBearer from fief_client import FiefAccessTokenInfo , FiefAsync from fief_client.integrations.fastapi import FiefAuth fief = FiefAsync ( # (1)! \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) scheme = OAuth2AuthorizationCodeBearer ( # (2)! \"https://example.fief.dev/authorize\" , \"https://example.fief.dev/api/token\" , scopes = { \"openid\" : \"openid\" , \"offline_access\" : \"offline_access\" }, ) auth = FiefAuth ( fief , scheme ) # (3)! app = FastAPI () @app . get ( \"/user\" ) async def get_user ( access_token_info : FiefAccessTokenInfo = Depends ( auth . authenticated ()), # (4)! ): return access_token_info Fief client instantiation As we showed in the standard Python section , we instantiate here a Fief client here with the base tenant URL and client credentials. Notice here that we use the FiefAsync class. FastAPI being an ASGI framework, it's always nice to take advantage of asyncio capabilities. OpenAPI security scheme FastAPI uses those security schemes to generate an interactive documentation showing the right interface to authenticate with the API. We use here a standard OAuth2 interface. Fief helper for FastAPI This is the helper doing the tedious work for you with FastAPI. All it needs is an instance of the Fief client and the scheme. authenticated dependency This is where the magic happens: in pure FastAPI style, FiefAuth gives you a authenticated dependency to check for the access token and optionally for required scopes. If everything goes well, you'll get a dictionary containing the ID of the user, the list of allowed scopes and the raw access token. And that's about it!","title":"API example"},{"location":"integrate/python/fastapi/#test-it","text":"You can run this example just like you would do for any FastAPI app: uvicorn app:app Open http://localhost:8000/docs to access the interactive documentation. Let's try first the /user endpoint: We get an 401 error! That's expected: we are not authenticated yet ! Let's fix that: click on the Authorize button to start the authentication process. You'll need to provide your client ID and secret and select the scopes. Click on the Authorize button: you are redirected to the Fief login page. Upon successful login, you will be redirected back to the interactive documentation: a valid access token has been generated! You can now try the /user endpoint to check the result: Notice how the interactive documentation passed the access token in the Authorization header of the request! Besides, the response does contain the user ID, the list of allowed scopes and the access token itself.","title":"Test it"},{"location":"integrate/python/fastapi/#checking-for-scopes","text":"Building on the previous example, you can make your endpoint requires the access token to be granted a list of scopes . Simply add this list of scopes as a keyword parameter of the authenticated dependency. app.py from fastapi import Depends , FastAPI from fastapi.security import OAuth2AuthorizationCodeBearer from fief_client import FiefAccessTokenInfo , FiefAsync from fief_client.integrations.fastapi import FiefAuth fief = FiefAsync ( \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) scheme = OAuth2AuthorizationCodeBearer ( \"https://example.fief.dev/authorize\" , \"https://example.fief.dev/api/token\" , scopes = { \"openid\" : \"openid\" , \"offline_access\" : \"offline_access\" }, ) auth = FiefAuth ( fief , scheme ) app = FastAPI () @app . get ( \"/user\" ) async def get_user ( access_token_info : FiefAccessTokenInfo = Depends ( auth . authenticated ( scope = [ \"openid\" , \"required_scope\" ]) ), ): return access_token_info If one of the required scope is missing on the access token, a 403 Forbidden error will automatically be returned.","title":"Checking for scopes"},{"location":"integrate/python/fastapi/#checking-for-permissions","text":"Similary, you can make your endpoint requires the user to be granted a list of permissions . Simply add this list of permissions as a keyword parameter of the authenticated dependency. app.py from fastapi import Depends , FastAPI from fastapi.security import OAuth2AuthorizationCodeBearer from fief_client import FiefAccessTokenInfo , FiefAsync from fief_client.integrations.fastapi import FiefAuth fief = FiefAsync ( \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) scheme = OAuth2AuthorizationCodeBearer ( \"https://example.fief.dev/authorize\" , \"https://example.fief.dev/api/token\" , scopes = { \"openid\" : \"openid\" , \"offline_access\" : \"offline_access\" }, ) auth = FiefAuth ( fief , scheme ) app = FastAPI () @app . get ( \"/user\" ) async def get_user ( access_token_info : FiefAccessTokenInfo = Depends ( auth . authenticated ( permissions = [ \"castles:read\" ]) ), ): return access_token_info If one of the required permission is missing on ther user, a 403 Forbidden error will automatically be returned.","title":"Checking for permissions"},{"location":"integrate/python/fastapi/#web-application-example","text":"This is for you if... Your FastAPI backend will render HTML pages. Your application is intended to be used in a browser. Prerequisites Allow the following Redirect URI on your Fief Client: http://localhost:8000/auth-callback The examples we showed previously are working well in a pure REST API context: a frontend, like interactive documentation, a JavaScript application or a mobile app will take care of the OAuth2 authentication flow to retrieve an access token before making request to your API. Another common context is traditional web application , where the server takes care of generating HTML pages before returning it to the browser. In this case, we'll need some routes to redirect the user to the Fief login page if they're not authenticated and take care of storing the access token somewhere. This is what'll show in this example. Besides, we'll usually need the basic information about the authenticated user, like its email or the values of the custom user fields . We'll see how we can use it. Basically, here's what we'll do: This time, we'll expect the access token to be passed through a traditional cookie instead of an HTTP header. Cookies are very convenient when designing web apps because they are handled automatically by the browser. If the cookie is not present, we'll redirect the user to the Fief login page . Once again, the browser will help us a lot here since it'll automatically follow the redirection. Upon successful login, Fief will automatically redirect the user to the callback route . This callback route will take care of setting a new cookie containing the access token . It means that the access token will be safely stored in the browser memory. Finally, the user is redirected back to the protected route. The browser will automatically send the cookie containing the access token: our request is now authenticated! app.py from datetime import datetime from fastapi import Depends , FastAPI , HTTPException , Query , Request , Response , status from fastapi.responses import HTMLResponse , RedirectResponse from fastapi.security import APIKeyCookie from fief_client import FiefAsync , FiefUserInfo from fief_client.integrations.fastapi import FiefAuth class CustomFiefAuth ( FiefAuth ): # (1)! client : FiefAsync async def get_unauthorized_response ( self , request : Request , response : Response ): redirect_uri = request . url_for ( \"auth_callback\" ) # (2)! auth_url = await self . client . auth_url ( redirect_uri , scope = [ \"openid\" ]) # (3)! raise HTTPException ( status_code = status . HTTP_307_TEMPORARY_REDIRECT , # (4)! headers = { \"Location\" : auth_url }, ) fief = FiefAsync ( # (5)! \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) SESSION_COOKIE_NAME = \"user_session\" scheme = APIKeyCookie ( name = SESSION_COOKIE_NAME , auto_error = False ) # (6)! auth = CustomFiefAuth ( fief , scheme ) # (7)! app = FastAPI () @app . get ( \"/auth-callback\" , name = \"auth_callback\" ) # (8)! async def auth_callback ( request : Request , response : Response , code : str = Query ( ... )): redirect_uri = request . url_for ( \"auth_callback\" ) tokens , _ = await fief . auth_callback ( code , redirect_uri ) # (9)! response = RedirectResponse ( request . url_for ( \"protected\" )) # (10)! response . set_cookie ( # (11)! SESSION_COOKIE_NAME , tokens [ \"access_token\" ], expires = int ( datetime . now () . timestamp () + tokens [ \"expires_in\" ]), httponly = True , # (12)! secure = False , # \u274c Set this to `True` in production (13)! ) return response @app . get ( \"/protected\" , name = \"protected\" ) async def protected ( user : FiefUserInfo = Depends ( auth . current_user ()), # (14)! ): return HTMLResponse ( f \"<h1>You are authenticated. Your user email is { user [ 'email' ] } </h1>\" ) We customize the FiefAuth helper to fit our needs The base class is implemented with an API scenario in mind. Nevertheless, it's designed in a way you can customize its behavior when the user is not authenticated or has not the required scope. That's what'll do with the get_unauthorized_response . We build the redirect URL This points to our /auth-callback route that we define below. We generate an authorization URL on the Fief server Thanks to the auth_url method on the Fief client, we can automatically generate the authorization URL on the Fief server. We build a redirect response By setting a status code in the 3XX range, we tell the browser that it should redirect the user to another URL, specified in the Location header. You can read more about HTTP redirections on the MDN documentation . This doesn't change from the previous example The FiefAsync client is always at the heart of the integration \ud83d\ude09 We use a scheme expecting a cookie Contrary to the previous examples, we expect the access token to be passed in a cookie. Thus, we use a dedicated scheme for that. Notice that we set the name of this cookie through the SESSION_COOKIE_NAME constant. Besides, we set the auto_error argument to False . It tells FastAPI user to bypass its built-in error response if the cookie is not present: we have our own logic to handle this. We use our custom CustomFiefAuth class Of course, now that we overloaded the behavior of this helper class, we shouldn't forget to actually use it! We implement an /auth-callback route This is the route that'll take care of exchanging the authorization code with a fresh access token and save it in a cookie. Notice that we set its name parameter: this is how we can generate its URL automatically with the request.url_for method. We generate an access token We finish the OAuth2 flow by exchanging the authorization code with a fresh access token. We build a redirection to the /protected route The user will now be correctly authenticated to our web application. Thus, we can redirect them to a protected page. We build a new cookie containing the access token The response will contain a Set-Cookie header instructing the browser to save the access token in its memory. This method allows us to configure each properties of the cookie. You can read more about HTTP cookies on the MDN documentation . Set the cookie as HTTPOnly For such sensitive values, it's strongly recommended to set the cookie as HTTPOnly . It means that it won't be possible to read its value from JavaScript, reducing potential attacks. Set the cookie as secure in production For such sensitive values, it's strongly recommended to set the cookie as Secure . It tells the browser to send the cookie only on HTTPS (SSL) connection, reducing the risk of the access token to be stolen by a attacker between the client and the server. However, in a local environment, you usually don't serve your application with SSL. That's why we set it to False in this example. A common approach to handle this is to have an environment variable to control this parameter, so you can disable it in local and enable it in production. Use the current_user dependency This time, we use the current_user dependency instead of authenticated . Under the hood, it'll stil call authenticated and check if the cookie is available in the request and proceed if everything goes well. However, it'll return you a FiefUserInfo dictionary containing the data of the user. If the request is not authenticated, our custom get_unauthorized_response will be called and the user will be redirected to the Fief login page. That's it! If you run this application and go to http://localhost:8000/protected , you'll be redirected to the Fief login page and experience the authentication flow before getting back to this route with a proper authentication cookie. Read the next example for a more optimal implementation In this example, the user information is not cached . For the performance of your application, we highly recommend you to read the next example. current_user can also check for scope and permissions In a similar way as we shown in the API example , you can also require the access token to be granted a list of scopes or the user to be granted a list of permissions . async def protected ( user : FiefUserInfo = Depends ( auth . current_user ( scope = [ \"openid\" , \"required_scope\" ])), ): ... async def protected ( user : FiefUserInfo = Depends ( auth . current_user ( permissions = [ \"castles:read\" ])), ): ...","title":"Web application example"},{"location":"integrate/python/fastapi/#caching-user-information","text":"In the previous example, we didn't set up cache for the user information. It means that everytime we hit the /protected route, the Fief API will be called to get the data. Obviously, this is not very optimal. Let's fix this! Fortunately, the client provides you useful tools to help you with this. Building upon the previous example, let's see how we can cache user information. app.py import uuid from datetime import datetime from typing import Dict , Optional from fastapi import Depends , FastAPI , HTTPException , Query , Request , Response , status from fastapi.responses import HTMLResponse , RedirectResponse from fastapi.security import APIKeyCookie from fief_client import FiefAsync , FiefUserInfo from fief_client.integrations.fastapi import FiefAuth class CustomFiefAuth ( FiefAuth ): client : FiefAsync async def get_unauthorized_response ( self , request : Request , response : Response ): redirect_uri = request . url_for ( \"auth_callback\" ) auth_url = await self . client . auth_url ( redirect_uri , scope = [ \"openid\" ]) raise HTTPException ( status_code = status . HTTP_307_TEMPORARY_REDIRECT , headers = { \"Location\" : auth_url }, ) class MemoryUserInfoCache : # (1)! def __init__ ( self ) -> None : self . storage : Dict [ uuid . UUID , FiefUserInfo ] = {} # (2)! async def get ( self , user_id : uuid . UUID ) -> Optional [ FiefUserInfo ]: # (3)! return self . storage . get ( user_id ) async def set ( self , user_id : uuid . UUID , userinfo : FiefUserInfo ) -> None : # (4)! self . storage [ user_id ] = userinfo memory_userinfo_cache = MemoryUserInfoCache () # (5)! async def get_memory_userinfo_cache () -> MemoryUserInfoCache : # (6)! return memory_userinfo_cache fief = FiefAsync ( \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) SESSION_COOKIE_NAME = \"user_session\" scheme = APIKeyCookie ( name = SESSION_COOKIE_NAME , auto_error = False ) auth = CustomFiefAuth ( fief , scheme , get_userinfo_cache = get_memory_userinfo_cache # (7)! ) app = FastAPI () @app . get ( \"/auth-callback\" , name = \"auth_callback\" ) async def auth_callback ( request : Request , response : Response , code : str = Query ( ... ), memory_userinfo_cache : MemoryUserInfoCache = Depends ( # (8)! get_memory_userinfo_cache ), ): redirect_uri = request . url_for ( \"auth_callback\" ) tokens , userinfo = await fief . auth_callback ( code , redirect_uri ) response = RedirectResponse ( request . url_for ( \"protected\" )) response . set_cookie ( SESSION_COOKIE_NAME , tokens [ \"access_token\" ], expires = int ( datetime . now () . timestamp () + tokens [ \"expires_in\" ]), httponly = True , secure = False , ) await memory_userinfo_cache . set ( uuid . UUID ( userinfo [ \"sub\" ]), userinfo ) # (9)! return response @app . get ( \"/protected\" , name = \"protected\" ) async def protected ( user : FiefUserInfo = Depends ( auth . current_user ()), # (10)! ): return HTMLResponse ( f \"<h1>You are authenticated. Your user email is { user [ 'email' ] } </h1>\" ) We start by implementing an helper class to store the user information somewhere The implementation is completely up-to-you and could be something rather complex, like using a Redis server to cache this information. We'll see that it expects you to implement two methods for working correctly with FiefAuth . We store the data in memory using a dictionary This is a very simple approach that will just store the data in memory. If your server is rebooted, the cache will be lost. It can work quite well when starting, but you'll probably need more robust approaches in the long run. The good thing is that you'll only need to change this class when the time comes! We implement the .get method This is the first compulsory method you have to implement in the class. It accepts an user ID as argument and expects you to return a cached FiefUserInfo dictionary or None if not available. Here, we simply read from our dictionary. We implement the .set method This is the second and last compulsory method you have to implement in the class. It accepts an user ID and a FiefUserInfo dictionary as arguments. There, you'll need to store this data in cache. Here, we simply set the user information into our dictionary. We instantiate MemoryUserInfoCache globally In order to have a global memory cache, we instantiate our class in the global context, at the same time of our FastAPI app. This way, the dictionary will be initialized at the same time our app is launched. Depending on your implementation, this may not be needed. We could also imagine to have a fresh instance every time we use it. This is typically the case when using database sessions for example. We define a callable dependency to get our class This pattern is typical of FastAPI. With a callable dependency, we are able to tell FastAPI to automatically instantiate objects, potentially needing other sub-dependencies as well. This is especially handy if you already have a dependency taking care of returning you a database connection or a session object for example. In our example here, we don't have any complex dependency, so we can just directly return the memory_userinfo_cache instance. We add the get_userinfo_cache argument to CustomFiefAuth This is an optional keyword argument that basically tells FiefAuth to use the caching class returned by get_userinfo_cache when you want to get the user information. That's why it's important to strictly follow the methods signature presented above: FiefAuth will call them inside its logic. We add memory_userinfo_cache as a dependency to auth_callback When a user has successfully authenticated, we do not only get the access token: we also get an ID token which already contains the user information. Hence, we'll take this opportunity to store it in our cache! Since we defined it as a callable dependency, we can directly use get_memory_userinfo_cache inside our route to use it. We cache the user information The ID token is automatically decoded by fief.auth_callback method. Thus, we just have to use our cache to store it! The current_user dependency doesn't change Nothing changes here! Now that we have set a get_userinfo_cache dependency, current_user will automatically use it to return you the user information. If it's not present in cache, it'll hit the Fief API. Note that you can use auth.current_user(refresh=True) if you need to always retrieve fresh data from the Fief API. That's it! Now, we won't retrieve user information from the Fief API at each request. Typically, we'll set it in cache when the user authenticates and it'll be used during the lifetime of the session.","title":"Caching user information"},{"location":"integrate/python/flask/","text":"Flask \u00b6 Flask is probably the most popular Python web framework. The Fief Python client provides tools to help you integrate Fief authentication in your Flask project. Let's see how to use them! Install the client \u00b6 Install the Fief client with the optional Flask dependencies: pip install \"fief-client[flask]\" API example \u00b6 This is for you if... Your Flask backend will work as a pure REST API. You have a separate frontend, like a JavaScript or mobile app, that'll take care of the OAuth2 flow. In this first example, we won't implement routes to perform the OAuth2 authentication. The goal here is just to show you how to protect your API route with a Fief access token . app.py from fief_client import Fief from fief_client.integrations.flask import ( FiefAuth , FiefAuthForbidden , FiefAuthUnauthorized , get_authorization_scheme_token , ) from flask import Flask , g fief = Fief ( # (1)! \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) auth = FiefAuth ( fief , get_authorization_scheme_token ()) # (2)! app = Flask ( __name__ ) @app . errorhandler ( FiefAuthUnauthorized ) # (3)! def fief_unauthorized_error ( e ): return \"\" , 401 @app . errorhandler ( FiefAuthForbidden ) # (4)! def fief_forbidden_error ( e ): return \"\" , 403 @app . get ( \"/authenticated\" ) @auth . authenticated () # (5)! def get_authenticated (): return g . access_token_info # (6)! @app . get ( \"/authenticated-scope\" ) @auth . authenticated ( scope = [ \"openid\" , \"required_scope\" ]) # (7)! def get_authenticated_scope (): return g . access_token_info @app . get ( \"/authenticated-permissions\" ) @auth . authenticated ( permissions = [ \"castles:read\" ]) # (8)! def get_authenticated_permissions (): return g . access_token_info Fief client instantiation As we showed in the standard Python section , we instantiate here a Fief client here with the base tenant URL and client credentials. Fief helper for Flask This is the helper doing the tedious work for you with Flask. It first needs an instance of the Fief client we created above and a function retrieving the access token from the Flask request . It's a simple function which can use the global request object to retrieve the access token. For convenience, we provide two of them: get_authorization_scheme_token and get_cookie . Error handler for FiefAuthUnauthorized When a protected route is called without a valid access token, the Fief helper will raise the FiefAuthUnauthorized . By registering a Flask error handler, we can catch this error and customize the response returned to the user. Here, we just return an empty response with the 401 status code. Error handler for FiefAuthForbidden When a request is made with a valid access token but without the required scope, the Fief helper will raise the FiefAuthForbidden . By registering a Flask error handler, we can catch this error and customize the response returned to the user. Here, we just return an empty response with the 403 status code. authenticated decorator This is where the magic happens: FiefAuth gives you a authenticated decorator to check for the access token and optionally for required scopes. If everything goes well, the route logic will be executed. access_token_info dictionary is available in g When a valid access token is found in the request, the access_token_info decorator will automatically add the access_token_info property to the global g application context of Flask . This access_token_info property is a FiefAccessTokenInfo dictionary containing the ID of the user, the list of allowed scopes and the raw access token. Check for scopes The access_token_info decorator accepts an optional scope argument where you can list the scope required to access this route. If the access token doesn't have the required scope, FiefAuthForbidden error is raised. Check for permissions The access_token_info decorator accepts an optional permissions argument where you can list the permissions required to access this route. If the user doesn't have the required permissions, FiefAuthForbidden is raised. And that's about it! Web application example \u00b6 This is for you if... Your Flask backend will render HTML pages. Your application is intended to be used in a browser. Prerequisites Allow the following Redirect URI on your Fief Client: http://localhost:8000/auth-callback The examples we showed previously are working well in a pure REST API context: a frontend, like interactive documentation, a JavaScript application or a mobile app will take care of the OAuth2 authentication flow to retrieve an access token before making request to your API. Another common context is traditional web application , where the server takes care of generating HTML pages before returning it to the browser. In this case, we'll need some routes to redirect the user to the Fief login page if they're not authenticated and take care of storing the access token somewhere. This is what'll show in this example. Besides, we'll usually need the basic information about the authenticated user, like its email or the values of the custom user fields . We'll see how we can use it. Basically, here's what we'll do: This time, we'll expect the access token to be passed through a traditional cookie instead of an HTTP header. Cookies are very convenient when designing web apps because they are handled automatically by the browser. If the cookie is not present, we'll redirect the user to the Fief login page . Once again, the browser will help us a lot here since it'll automatically follow the redirection. Upon successful login, Fief will automatically redirect the user to the callback route . This callback route will take care of setting a new cookie containing the access token . It means that the access token will be safely stored in the browser memory. Finally, the user is redirected back to the protected route. The browser will automatically send the cookie containing the access token: our request is now authenticated! app.py import uuid from datetime import datetime from typing import Optional from fief_client import Fief , FiefUserInfo from fief_client.integrations.flask import ( FiefAuth , FiefAuthForbidden , FiefAuthUnauthorized , get_cookie , ) from flask import Flask , g , redirect , request , session , url_for SESSION_COOKIE_NAME = \"user_session\" SECRET_KEY = \"SECRET\" # (1)! fief = Fief ( # (2)! \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) def get_userinfo_cache ( id : uuid . UUID ) -> Optional [ FiefUserInfo ]: # (3)! return session . get ( f \"userinfo- { str ( id ) } \" ) def set_userinfo_cache ( id : uuid . UUID , userinfo : FiefUserInfo ) -> None : # (4)! session [ f \"userinfo- { str ( id ) } \" ] = userinfo auth = FiefAuth ( fief , get_cookie ( SESSION_COOKIE_NAME ), # (5) get_userinfo_cache = get_userinfo_cache , # (6)! set_userinfo_cache = set_userinfo_cache , ) app = Flask ( __name__ ) app . secret_key = SECRET_KEY @app . errorhandler ( FiefAuthUnauthorized ) # (7)! def fief_unauthorized_error ( e ): redirect_uri = url_for ( \"auth_callback\" , _external = True ) # (8)! auth_url = fief . auth_url ( redirect_uri , scope = [ \"openid\" ]) # (9)! return redirect ( auth_url ) # (10)! @app . errorhandler ( FiefAuthForbidden ) def fief_forbidden_error ( e ): return \"\" , 403 @app . get ( \"/auth-callback\" ) # (11)! def auth_callback (): redirect_uri = url_for ( \"auth_callback\" , _external = True ) code = request . args [ \"code\" ] tokens , userinfo = fief . auth_callback ( code , redirect_uri ) # (12)! response = redirect ( url_for ( \"protected\" )) # (13)! response . set_cookie ( # (14)! SESSION_COOKIE_NAME , tokens [ \"access_token\" ], expires = int ( datetime . now () . timestamp () + tokens [ \"expires_in\" ]), httponly = True , # (15)! secure = False , # \u274c Set this to `True` in production (16)! ) set_userinfo_cache ( uuid . UUID ( userinfo [ \"sub\" ]), userinfo ) # (17)! return response @app . get ( \"/protected\" ) @auth . current_user () # (18)! def protected (): user = g . user # (19)! return f \"<h1>You are authenticated. Your user email is { user [ 'email' ] } </h1>\" Define a secret key for Flask We'll use the Sessions mechanism from Flask to keep user information in cache. To enable it, we need to set a secret key for Flask. Generate a strong passphrase and don't share it . Avoid to hardcode your secrets in your code It's usually not recommended to hardcode secrets like Client ID and Secret in your code like this. If your code gets published on the web, for example on GitHub, the security of your workspace would be compromised. Besides, it'll be harder if you need to deploy on several environments, like a staging or testing one, in addition to your production environment. A standard and widely-used approach is to use environment variables . This doesn't change from the previous example The Fief client is always at the heart of the integration \ud83d\ude09 We define a function to retrieve user information from cache To make sure we don't call the Fief API every time we want the user data, we'll cache it in our application. It'll be way more performant! To do this, we implement a simple function allowing us to retrieve the user information given a user ID. In this example, we simply use the Sessions mechanism from Flask , but it can be something more complex, like reading from a Redis store. We define a function to set user information in cache As you probably have guessed, we need the other side of the operation: saving user information in cache. To do this, we implement a simple function accepting a user ID and a FiefUserInfo dictionary as arguments. There, you'll need to store this data in cache. In this example, we simply use the Sessions mechanism from Flask , but it can be something more complex, like writing to a Redis store. We use a cookie getter Contrary to the previous examples, we expect the access token to be passed in a cookie. Thus, we use the get_cookie getter. Notice that we set the name of this cookie through the SESSION_COOKIE_NAME constant. We pass both get_userinfo_cache and set_userinfo_cache as arguments Basically, we tell FiefAuth to use the caching functions we implemented when we want to get the user information. That's why it's important to strictly follow the functions signature presented above: FiefAuth will call them inside its logic. We change the error handler for FiefAuthUnauthorized This time, we'll generate a redirect response so the user can login on Fief. We build the redirect URL This points to our /auth-callback route that we define below. We generate an authorization URL on the Fief server Thanks to the auth_url method on the Fief client, we can automatically generate the authorization URL on the Fief server. We build a redirect response We redirect the user to the Fief authorization URL. We implement an /auth-callback route This is the route that'll take care of exchanging the authorization code with a fresh access token and save it in a cookie. We generate an access token We finish the OAuth2 flow by exchanging the authorization code with a fresh access token. We build a redirection to the /protected route The user will now be correctly authenticated to our web application. Thus, we can redirect them to a protected page. We build a new cookie containing the access token The response will contain a Set-Cookie header instructing the browser to save the access token in its memory. This method allows us to configure each properties of the cookie. You can read more about HTTP cookies on the MDN documentation . Set the cookie as HTTPOnly For such sensitive values, it's strongly recommended to set the cookie as HTTPOnly . It means that it won't be possible to read its value from JavaScript, reducing potential attacks. Set the cookie as secure in production For such sensitive values, it's strongly recommended to set the cookie as Secure . It tells the browser to send the cookie only on HTTPS (SSL) connection, reducing the risk of the access token to be stolen by a attacker between the client and the server. However, in a local environment, you usually don't serve your application with SSL. That's why we set it to False in this example. A common approach to handle this is to have an environment variable to control this parameter, so you can disable it in local and enable it in production. We cache the user information When a user has successfully authenticated, we do not only get the access token: we also get an ID token which already contains the user information. Hence, we'll take this opportunity to store it in our cache! The ID token is automatically decoded by fief.auth_callback method. Thus, we just have to use our cache function to store it! Use the current_user decorator This time, we use the current_user decorator instead of authenticated . Under the hood, it'll stil call authenticated and check if the cookie is available in the request and proceed if everything goes well. However, it'll return you a FiefUserInfo dictionary containing the data of the user. If the request is not authenticated, an FiefAuthUnauthorized error will be raised and the user will be redirected to the Fief login page. user dictionary is available in g If the request is properly authenticated, the current_user decorator will automatically add the user property to the global g application context of Flask . This user property is a FiefUserInfo dictionary containing the user data. If it's not available in cache, it's automatically retrieved from the Fief API. That's it! If you run this application and go to http://localhost:8000/protected , you'll be redirected to the Fief login page and experience the authentication flow before getting back to this route with a proper authentication cookie. of your application, we highly recommend you to read the next example. current_user can also check for scope and permissions In a similar way as we shown in the API example , you can also require the access token to be granted a list of scopes or the user to be granted a list of permissions . @app . get ( \"/protected\" ) @auth . current_user ( scope = [ \"openid\" , \"required_scope\" ]) def protected (): ... @app . get ( \"/protected\" ) @auth . current_user ( permissions = [ \"castles:read\" ]) def protected (): ...","title":"Flask"},{"location":"integrate/python/flask/#flask","text":"Flask is probably the most popular Python web framework. The Fief Python client provides tools to help you integrate Fief authentication in your Flask project. Let's see how to use them!","title":"Flask"},{"location":"integrate/python/flask/#install-the-client","text":"Install the Fief client with the optional Flask dependencies: pip install \"fief-client[flask]\"","title":"Install the client"},{"location":"integrate/python/flask/#api-example","text":"This is for you if... Your Flask backend will work as a pure REST API. You have a separate frontend, like a JavaScript or mobile app, that'll take care of the OAuth2 flow. In this first example, we won't implement routes to perform the OAuth2 authentication. The goal here is just to show you how to protect your API route with a Fief access token . app.py from fief_client import Fief from fief_client.integrations.flask import ( FiefAuth , FiefAuthForbidden , FiefAuthUnauthorized , get_authorization_scheme_token , ) from flask import Flask , g fief = Fief ( # (1)! \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) auth = FiefAuth ( fief , get_authorization_scheme_token ()) # (2)! app = Flask ( __name__ ) @app . errorhandler ( FiefAuthUnauthorized ) # (3)! def fief_unauthorized_error ( e ): return \"\" , 401 @app . errorhandler ( FiefAuthForbidden ) # (4)! def fief_forbidden_error ( e ): return \"\" , 403 @app . get ( \"/authenticated\" ) @auth . authenticated () # (5)! def get_authenticated (): return g . access_token_info # (6)! @app . get ( \"/authenticated-scope\" ) @auth . authenticated ( scope = [ \"openid\" , \"required_scope\" ]) # (7)! def get_authenticated_scope (): return g . access_token_info @app . get ( \"/authenticated-permissions\" ) @auth . authenticated ( permissions = [ \"castles:read\" ]) # (8)! def get_authenticated_permissions (): return g . access_token_info Fief client instantiation As we showed in the standard Python section , we instantiate here a Fief client here with the base tenant URL and client credentials. Fief helper for Flask This is the helper doing the tedious work for you with Flask. It first needs an instance of the Fief client we created above and a function retrieving the access token from the Flask request . It's a simple function which can use the global request object to retrieve the access token. For convenience, we provide two of them: get_authorization_scheme_token and get_cookie . Error handler for FiefAuthUnauthorized When a protected route is called without a valid access token, the Fief helper will raise the FiefAuthUnauthorized . By registering a Flask error handler, we can catch this error and customize the response returned to the user. Here, we just return an empty response with the 401 status code. Error handler for FiefAuthForbidden When a request is made with a valid access token but without the required scope, the Fief helper will raise the FiefAuthForbidden . By registering a Flask error handler, we can catch this error and customize the response returned to the user. Here, we just return an empty response with the 403 status code. authenticated decorator This is where the magic happens: FiefAuth gives you a authenticated decorator to check for the access token and optionally for required scopes. If everything goes well, the route logic will be executed. access_token_info dictionary is available in g When a valid access token is found in the request, the access_token_info decorator will automatically add the access_token_info property to the global g application context of Flask . This access_token_info property is a FiefAccessTokenInfo dictionary containing the ID of the user, the list of allowed scopes and the raw access token. Check for scopes The access_token_info decorator accepts an optional scope argument where you can list the scope required to access this route. If the access token doesn't have the required scope, FiefAuthForbidden error is raised. Check for permissions The access_token_info decorator accepts an optional permissions argument where you can list the permissions required to access this route. If the user doesn't have the required permissions, FiefAuthForbidden is raised. And that's about it!","title":"API example"},{"location":"integrate/python/flask/#web-application-example","text":"This is for you if... Your Flask backend will render HTML pages. Your application is intended to be used in a browser. Prerequisites Allow the following Redirect URI on your Fief Client: http://localhost:8000/auth-callback The examples we showed previously are working well in a pure REST API context: a frontend, like interactive documentation, a JavaScript application or a mobile app will take care of the OAuth2 authentication flow to retrieve an access token before making request to your API. Another common context is traditional web application , where the server takes care of generating HTML pages before returning it to the browser. In this case, we'll need some routes to redirect the user to the Fief login page if they're not authenticated and take care of storing the access token somewhere. This is what'll show in this example. Besides, we'll usually need the basic information about the authenticated user, like its email or the values of the custom user fields . We'll see how we can use it. Basically, here's what we'll do: This time, we'll expect the access token to be passed through a traditional cookie instead of an HTTP header. Cookies are very convenient when designing web apps because they are handled automatically by the browser. If the cookie is not present, we'll redirect the user to the Fief login page . Once again, the browser will help us a lot here since it'll automatically follow the redirection. Upon successful login, Fief will automatically redirect the user to the callback route . This callback route will take care of setting a new cookie containing the access token . It means that the access token will be safely stored in the browser memory. Finally, the user is redirected back to the protected route. The browser will automatically send the cookie containing the access token: our request is now authenticated! app.py import uuid from datetime import datetime from typing import Optional from fief_client import Fief , FiefUserInfo from fief_client.integrations.flask import ( FiefAuth , FiefAuthForbidden , FiefAuthUnauthorized , get_cookie , ) from flask import Flask , g , redirect , request , session , url_for SESSION_COOKIE_NAME = \"user_session\" SECRET_KEY = \"SECRET\" # (1)! fief = Fief ( # (2)! \"https://example.fief.dev\" , \"YOUR_CLIENT_ID\" , \"YOUR_CLIENT_SECRET\" , ) def get_userinfo_cache ( id : uuid . UUID ) -> Optional [ FiefUserInfo ]: # (3)! return session . get ( f \"userinfo- { str ( id ) } \" ) def set_userinfo_cache ( id : uuid . UUID , userinfo : FiefUserInfo ) -> None : # (4)! session [ f \"userinfo- { str ( id ) } \" ] = userinfo auth = FiefAuth ( fief , get_cookie ( SESSION_COOKIE_NAME ), # (5) get_userinfo_cache = get_userinfo_cache , # (6)! set_userinfo_cache = set_userinfo_cache , ) app = Flask ( __name__ ) app . secret_key = SECRET_KEY @app . errorhandler ( FiefAuthUnauthorized ) # (7)! def fief_unauthorized_error ( e ): redirect_uri = url_for ( \"auth_callback\" , _external = True ) # (8)! auth_url = fief . auth_url ( redirect_uri , scope = [ \"openid\" ]) # (9)! return redirect ( auth_url ) # (10)! @app . errorhandler ( FiefAuthForbidden ) def fief_forbidden_error ( e ): return \"\" , 403 @app . get ( \"/auth-callback\" ) # (11)! def auth_callback (): redirect_uri = url_for ( \"auth_callback\" , _external = True ) code = request . args [ \"code\" ] tokens , userinfo = fief . auth_callback ( code , redirect_uri ) # (12)! response = redirect ( url_for ( \"protected\" )) # (13)! response . set_cookie ( # (14)! SESSION_COOKIE_NAME , tokens [ \"access_token\" ], expires = int ( datetime . now () . timestamp () + tokens [ \"expires_in\" ]), httponly = True , # (15)! secure = False , # \u274c Set this to `True` in production (16)! ) set_userinfo_cache ( uuid . UUID ( userinfo [ \"sub\" ]), userinfo ) # (17)! return response @app . get ( \"/protected\" ) @auth . current_user () # (18)! def protected (): user = g . user # (19)! return f \"<h1>You are authenticated. Your user email is { user [ 'email' ] } </h1>\" Define a secret key for Flask We'll use the Sessions mechanism from Flask to keep user information in cache. To enable it, we need to set a secret key for Flask. Generate a strong passphrase and don't share it . Avoid to hardcode your secrets in your code It's usually not recommended to hardcode secrets like Client ID and Secret in your code like this. If your code gets published on the web, for example on GitHub, the security of your workspace would be compromised. Besides, it'll be harder if you need to deploy on several environments, like a staging or testing one, in addition to your production environment. A standard and widely-used approach is to use environment variables . This doesn't change from the previous example The Fief client is always at the heart of the integration \ud83d\ude09 We define a function to retrieve user information from cache To make sure we don't call the Fief API every time we want the user data, we'll cache it in our application. It'll be way more performant! To do this, we implement a simple function allowing us to retrieve the user information given a user ID. In this example, we simply use the Sessions mechanism from Flask , but it can be something more complex, like reading from a Redis store. We define a function to set user information in cache As you probably have guessed, we need the other side of the operation: saving user information in cache. To do this, we implement a simple function accepting a user ID and a FiefUserInfo dictionary as arguments. There, you'll need to store this data in cache. In this example, we simply use the Sessions mechanism from Flask , but it can be something more complex, like writing to a Redis store. We use a cookie getter Contrary to the previous examples, we expect the access token to be passed in a cookie. Thus, we use the get_cookie getter. Notice that we set the name of this cookie through the SESSION_COOKIE_NAME constant. We pass both get_userinfo_cache and set_userinfo_cache as arguments Basically, we tell FiefAuth to use the caching functions we implemented when we want to get the user information. That's why it's important to strictly follow the functions signature presented above: FiefAuth will call them inside its logic. We change the error handler for FiefAuthUnauthorized This time, we'll generate a redirect response so the user can login on Fief. We build the redirect URL This points to our /auth-callback route that we define below. We generate an authorization URL on the Fief server Thanks to the auth_url method on the Fief client, we can automatically generate the authorization URL on the Fief server. We build a redirect response We redirect the user to the Fief authorization URL. We implement an /auth-callback route This is the route that'll take care of exchanging the authorization code with a fresh access token and save it in a cookie. We generate an access token We finish the OAuth2 flow by exchanging the authorization code with a fresh access token. We build a redirection to the /protected route The user will now be correctly authenticated to our web application. Thus, we can redirect them to a protected page. We build a new cookie containing the access token The response will contain a Set-Cookie header instructing the browser to save the access token in its memory. This method allows us to configure each properties of the cookie. You can read more about HTTP cookies on the MDN documentation . Set the cookie as HTTPOnly For such sensitive values, it's strongly recommended to set the cookie as HTTPOnly . It means that it won't be possible to read its value from JavaScript, reducing potential attacks. Set the cookie as secure in production For such sensitive values, it's strongly recommended to set the cookie as Secure . It tells the browser to send the cookie only on HTTPS (SSL) connection, reducing the risk of the access token to be stolen by a attacker between the client and the server. However, in a local environment, you usually don't serve your application with SSL. That's why we set it to False in this example. A common approach to handle this is to have an environment variable to control this parameter, so you can disable it in local and enable it in production. We cache the user information When a user has successfully authenticated, we do not only get the access token: we also get an ID token which already contains the user information. Hence, we'll take this opportunity to store it in our cache! The ID token is automatically decoded by fief.auth_callback method. Thus, we just have to use our cache function to store it! Use the current_user decorator This time, we use the current_user decorator instead of authenticated . Under the hood, it'll stil call authenticated and check if the cookie is available in the request and proceed if everything goes well. However, it'll return you a FiefUserInfo dictionary containing the data of the user. If the request is not authenticated, an FiefAuthUnauthorized error will be raised and the user will be redirected to the Fief login page. user dictionary is available in g If the request is properly authenticated, the current_user decorator will automatically add the user property to the global g application context of Flask . This user property is a FiefUserInfo dictionary containing the user data. If it's not available in cache, it's automatically retrieved from the Fief API. That's it! If you run this application and go to http://localhost:8000/protected , you'll be redirected to the Fief login page and experience the authentication flow before getting back to this route with a proper authentication cookie. of your application, we highly recommend you to read the next example. current_user can also check for scope and permissions In a similar way as we shown in the API example , you can also require the access token to be granted a list of scopes or the user to be granted a list of permissions . @app . get ( \"/protected\" ) @auth . current_user ( scope = [ \"openid\" , \"required_scope\" ]) def protected (): ... @app . get ( \"/protected\" ) @auth . current_user ( permissions = [ \"castles:read\" ]) def protected (): ...","title":"Web application example"},{"location":"miscellaneous/resources/","text":"Resources \u00b6 RFC7517 (JSON Web Key): https://datatracker.ietf.org/doc/html/rfc7517 RFC7636 (OAuth2 PKCE): https://datatracker.ietf.org/doc/html/rfc7636 RFC8414 (OAuth2 Metadata): https://datatracker.ietf.org/doc/html/rfc8414 OpenID Connect 1.0 specification: https://openid.net/specs/openid-connect-core-1_0.html JWCrypto's library documentation: https://jwcrypto.readthedocs.io/","title":"Resources"},{"location":"miscellaneous/resources/#resources","text":"RFC7517 (JSON Web Key): https://datatracker.ietf.org/doc/html/rfc7517 RFC7636 (OAuth2 PKCE): https://datatracker.ietf.org/doc/html/rfc7636 RFC8414 (OAuth2 Metadata): https://datatracker.ietf.org/doc/html/rfc8414 OpenID Connect 1.0 specification: https://openid.net/specs/openid-connect-core-1_0.html JWCrypto's library documentation: https://jwcrypto.readthedocs.io/","title":"Resources"},{"location":"self-hosting/environment-variables/","text":"Environment variables \u00b6 Fief server relies heavily on environment variables for configuration. You'll likely need to adjust those settings for your deployment. Set environment variables \u00b6 Using docker run \u00b6 When running Fief server with Docker, the most straightforward way is to use the -e option on the command line, as shown in the Quickstart section. docker run \\ --name fief-server \\ -p 8000 :8000 \\ -d \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ -e \"PORT=8000\" \\ -e \"ROOT_DOMAIN=localhost:8000\" \\ -e \"FIEF_DOMAIN=localhost:8000\" \\ -e \"CSRF_COOKIE_SECURE=False\" \\ -e \"LOGIN_SESSION_COOKIE_SECURE=False\" \\ -e \"SESSION_COOKIE_SECURE=False\" \\ -e \"FIEF_ADMIN_SESSION_COOKIE_SECURE=False\" \\ ghcr.io/fief-dev/fief:latest However, it may become hard to maintain when having lot of variables to set. An alternative way is to use a .env file. It's a simple file where each line consists of a key and a value separated by an equal sign: .env SECRET = XXX FIEF_CLIENT_ID = XXX FIEF_CLIENT_SECRET = XXX ENCRYPTION_KEY = XXX PORT = 8000 ROOT_DOMAIN = localhost:8000 FIEF_DOMAIN = localhost:8000 CSRF_COOKIE_SECURE = False LOGIN_SESSION_COOKIE_SECURE = False SESSION_COOKIE_SECURE = False FIEF_ADMIN_SESSION_COOKIE_SECURE = False Then, you can reference this file in the Docker command: docker run \\ --name fief-server \\ -p 8000 :8000 \\ -d \\ --env-file .env \\ ghcr.io/fief-dev/fief:latest Using Docker Compose \u00b6 For more complex setups, you may need to configure a Docker Compose file to help you manage all your containers. You can directly define your environment variables in the Compose file. You'll find below an example of a Docker Compose file to run the Fief server. docker-compose.yml version : \"3.9\" services : fief : image : ghcr.io/fief-dev/fief:latest ports : - \"8000:8000\" environment : - SECRET=XXX - FIEF_CLIENT_ID=XXX - FIEF_CLIENT_SECRET=XXX - ENCRYPTION_KEY=XXX - PORT=8000 - ROOT_DOMAIN=localhost:8000 - FIEF_DOMAIN=localhost:8000 - CSRF_COOKIE_SECURE=False - LOGIN_SESSION_COOKIE_SECURE=False - SESSION_COOKIE_SECURE=False - FIEF_ADMIN_SESSION_COOKIE_SECURE=False Reference \u00b6 For each variable, we'll try to provide a sensible example value to help you configure it correctly. Throughout the examples, we'll assume that you host your Fief server on the sub-domain fief.bretagne.duchy . General \u00b6 Name Description Default Allowed values Example ENVIRONMENT Name of the deployment environment development development, staging, production production LOG_LEVEL Log verbosity INFO DEBUG, INFO, WARNING, ERROR INFO ROOT_DOMAIN Root domain where your server will be running. Mainly used for generating workspace subdomains. localhost:8000 bretagne.duchy ALLOW_ORIGIN_REGEX Regex used to control CORS access to your API http://.*localhost:[0-9]+ https://.*\\.bretagne.duchy PORT Internal port on which the Fief server is exposed 8000 8000 FORWARDED_ALLOW_IPS Comma separated list of IPs to trust with proxy headers. If you serve Fief behind a proxy handling SSL, you'll likely need to set this to value to * . 127.0.0.1 Secrets \u00b6 Name Description Default Allowed values Example SECRET Secret value used to sign reset password tokens. Any sufficiently long string ENCRYPTION_KEY Key used to encrypt the external databases credentials inside the main database A valid Fernet key encoded in UTF-8 Database \u00b6 Name Description Default Allowed values Example DATABASE_TYPE Type of the main database SQLITE POSTGRESQL, MYSQL, SQLITE POSTGRESQL DATABASE_HOST Host of the main database localhost DATABASE_PORT Listening port of the main database 5432 DATABASE_USERNAME Main database user fief DATABASE_PASSWORD Main database user's password fiefpassword DATABASE_NAME Main database name fief.db fief DATABASE_LOCATION For SQLite databases, path where to store the database files Current working directory DATABASE_URL Full database connection string, useful for some cloud providers. It'll take precedence over the single parameters above. DATABASE_POOL_RECYCLE_SECONDS Maximum lifetime in seconds of a database connection in the connection pool. Useful for servers cutting idle connections after some time. 600 (10 minutes) More details about how to setup a database in the dedicated section. Setup database Redis \u00b6 We use a Redis instance to manage background jobs (send emails, heavy computations...). A Redis instance is already up-and-running in the official Docker image, but you can provide your own one if needed. Name Description Default Allowed values Example REDIS_URL URL of a Redis server redis://localhost:6379 Email provider \u00b6 Name Description Default Allowed values Example EMAIL_PROVIDER Type of email provider NULL NULL, POSTMARK POSTMARK EMAIL_PROVIDER_PARAMS Configuration dictionary of the email provider {} {\"server_token\": \"XXX-XXX\"} More details about how to setup an email provider in the dedicated section. Setup email provider CSRF cookie \u00b6 To protect against Cross-Site-Request-Forgery attacks on authentication pages, we use the double-submit cookie pattern. Name Description Default Allowed values Example CSRF_COOKIE_NAME Name of the CSRF token cookie fief_csrftoken CSRF_COOKIE_SECURE Secure flag of the login session cookie True _COOKIE_SECURE flag should be True in production Browser cookies support the Secure flag , which tells the browser to not forward the cookie if the site is not requested in HTTPS. For your convenience when starting Fief on your local machine, the Quickstart command will set those flags to False for every Fief cookies. However, for security reasons, it's strongly recommended to set those flags to True (the default if not specified) when deploying to production. Login session \u00b6 A login session is a cookie used to maintain the state of the login flow of a user, from the login page until they're redirected to your application. Name Description Default Allowed values Example LOGIN_SESSION_COOKIE_NAME Name of the login session cookie fief_login_session LOGIN_SESSION_COOKIE_DOMAIN Domain of the login session cookie Empty string LOGIN_SESSION_COOKIE_SECURE Secure flag of the login session cookie True _COOKIE_SECURE flag should be True in production Browser cookies support the Secure flag , which tells the browser to not forward the cookie if the site is not requested in HTTPS. For your convenience when starting Fief on your local machine, the Quickstart command will set those flags to False for every Fief cookies. However, for security reasons, it's strongly recommended to set those flags to True (the default if not specified) when deploying to production. Session \u00b6 A session is a cookie used to maintain the session of a user on the Fief authentication pages . It's different from the session you'll maintain in your own application. Its purpose is to allow a user to re-authenticate quickly to your app without having them to input their credentials again. Name Description Default Allowed values Example SESSION_COOKIE_NAME Name of the session cookie fief_session SESSION_COOKIE_DOMAIN Domain of the session cookie Empty string SESSION_COOKIE_SECURE Secure flag of the session cookie True SESSION_LIFETIME_SECONDS Lifetime of the session cookie in seconds 86400 * 30 (30 days ) _COOKIE_SECURE flag should be True in production Browser cookies support the Secure flag , which tells the browser to not forward the cookie if the site is not requested in HTTPS. For your convenience when starting Fief on your local machine, the Quickstart command will set those flags to False for every Fief cookies. However, for security reasons, it's strongly recommended to set those flags to True (the default if not specified) when deploying to production. Authorization code \u00b6 Authorization codes are temporary codes generated during the OAuth2 authentication flow . Name Description Default Allowed values Example AUTHORIZATION_CODE_LIFETIME_SECONDS Lifetime of the authorization code in seconds. For security reasons, this value should remain low. OAuth2 specification recommends a value of 10 minutes . 600 (10 minutes) Fief-ception \u00b6 Fief-ception is a mind-fucking concept describing the fact that we actually use Fief to authenticate Fief users to the app \ud83e\udd2f That's why we necessarily need to create a first workspace and an admin user before being able to use Fief, as described in the Quickstart section. The variables below are here to configure the Fief server with a proper Fief client, as you would do in your own application! Name Description Default Allowed values Example FIEF_DOMAIN Domain of your main Fief workspace localhost:8000 fief.bretagne.duchy FIEF_CLIENT_ID Client ID in your main Fief workspace FIEF_CLIENT_SECRET Client secret in your main Fief workspace FIEF_ENCRYPTION_KEY Optional RSA key used to encrypt the JWT tokens Admin session \u00b6 An admin session is a cookie used to maintain the session of a user on the Fief admin dashboard. Name Description Default Allowed values Example FIEF_ADMIN_SESSION_COOKIE_NAME Name of the admin session cookie fief_admin_session FIEF_ADMIN_SESSION_COOKIE_DOMAIN Domain of the admin session cookie Empty string FIEF_ADMIN_SESSION_COOKIE_SECURE Secure flag of the admin session cookie True _COOKIE_SECURE flag should be True in production Browser cookies support the Secure flag , which tells the browser to not forward the cookie if the site is not requested in HTTPS. For your convenience when starting Fief on your local machine, the Quickstart command will set those flags to False for every Fief cookies. However, for security reasons, it's strongly recommended to set those flags to True (the default if not specified) when deploying to production.","title":"Environment variables"},{"location":"self-hosting/environment-variables/#environment-variables","text":"Fief server relies heavily on environment variables for configuration. You'll likely need to adjust those settings for your deployment.","title":"Environment variables"},{"location":"self-hosting/environment-variables/#set-environment-variables","text":"","title":"Set environment variables"},{"location":"self-hosting/environment-variables/#using-docker-run","text":"When running Fief server with Docker, the most straightforward way is to use the -e option on the command line, as shown in the Quickstart section. docker run \\ --name fief-server \\ -p 8000 :8000 \\ -d \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ -e \"PORT=8000\" \\ -e \"ROOT_DOMAIN=localhost:8000\" \\ -e \"FIEF_DOMAIN=localhost:8000\" \\ -e \"CSRF_COOKIE_SECURE=False\" \\ -e \"LOGIN_SESSION_COOKIE_SECURE=False\" \\ -e \"SESSION_COOKIE_SECURE=False\" \\ -e \"FIEF_ADMIN_SESSION_COOKIE_SECURE=False\" \\ ghcr.io/fief-dev/fief:latest However, it may become hard to maintain when having lot of variables to set. An alternative way is to use a .env file. It's a simple file where each line consists of a key and a value separated by an equal sign: .env SECRET = XXX FIEF_CLIENT_ID = XXX FIEF_CLIENT_SECRET = XXX ENCRYPTION_KEY = XXX PORT = 8000 ROOT_DOMAIN = localhost:8000 FIEF_DOMAIN = localhost:8000 CSRF_COOKIE_SECURE = False LOGIN_SESSION_COOKIE_SECURE = False SESSION_COOKIE_SECURE = False FIEF_ADMIN_SESSION_COOKIE_SECURE = False Then, you can reference this file in the Docker command: docker run \\ --name fief-server \\ -p 8000 :8000 \\ -d \\ --env-file .env \\ ghcr.io/fief-dev/fief:latest","title":"Using docker run"},{"location":"self-hosting/environment-variables/#using-docker-compose","text":"For more complex setups, you may need to configure a Docker Compose file to help you manage all your containers. You can directly define your environment variables in the Compose file. You'll find below an example of a Docker Compose file to run the Fief server. docker-compose.yml version : \"3.9\" services : fief : image : ghcr.io/fief-dev/fief:latest ports : - \"8000:8000\" environment : - SECRET=XXX - FIEF_CLIENT_ID=XXX - FIEF_CLIENT_SECRET=XXX - ENCRYPTION_KEY=XXX - PORT=8000 - ROOT_DOMAIN=localhost:8000 - FIEF_DOMAIN=localhost:8000 - CSRF_COOKIE_SECURE=False - LOGIN_SESSION_COOKIE_SECURE=False - SESSION_COOKIE_SECURE=False - FIEF_ADMIN_SESSION_COOKIE_SECURE=False","title":"Using Docker Compose"},{"location":"self-hosting/environment-variables/#reference","text":"For each variable, we'll try to provide a sensible example value to help you configure it correctly. Throughout the examples, we'll assume that you host your Fief server on the sub-domain fief.bretagne.duchy .","title":"Reference"},{"location":"self-hosting/environment-variables/#general","text":"Name Description Default Allowed values Example ENVIRONMENT Name of the deployment environment development development, staging, production production LOG_LEVEL Log verbosity INFO DEBUG, INFO, WARNING, ERROR INFO ROOT_DOMAIN Root domain where your server will be running. Mainly used for generating workspace subdomains. localhost:8000 bretagne.duchy ALLOW_ORIGIN_REGEX Regex used to control CORS access to your API http://.*localhost:[0-9]+ https://.*\\.bretagne.duchy PORT Internal port on which the Fief server is exposed 8000 8000 FORWARDED_ALLOW_IPS Comma separated list of IPs to trust with proxy headers. If you serve Fief behind a proxy handling SSL, you'll likely need to set this to value to * . 127.0.0.1","title":"General"},{"location":"self-hosting/environment-variables/#secrets","text":"Name Description Default Allowed values Example SECRET Secret value used to sign reset password tokens. Any sufficiently long string ENCRYPTION_KEY Key used to encrypt the external databases credentials inside the main database A valid Fernet key encoded in UTF-8","title":"Secrets"},{"location":"self-hosting/environment-variables/#database","text":"Name Description Default Allowed values Example DATABASE_TYPE Type of the main database SQLITE POSTGRESQL, MYSQL, SQLITE POSTGRESQL DATABASE_HOST Host of the main database localhost DATABASE_PORT Listening port of the main database 5432 DATABASE_USERNAME Main database user fief DATABASE_PASSWORD Main database user's password fiefpassword DATABASE_NAME Main database name fief.db fief DATABASE_LOCATION For SQLite databases, path where to store the database files Current working directory DATABASE_URL Full database connection string, useful for some cloud providers. It'll take precedence over the single parameters above. DATABASE_POOL_RECYCLE_SECONDS Maximum lifetime in seconds of a database connection in the connection pool. Useful for servers cutting idle connections after some time. 600 (10 minutes) More details about how to setup a database in the dedicated section. Setup database","title":"Database"},{"location":"self-hosting/environment-variables/#redis","text":"We use a Redis instance to manage background jobs (send emails, heavy computations...). A Redis instance is already up-and-running in the official Docker image, but you can provide your own one if needed. Name Description Default Allowed values Example REDIS_URL URL of a Redis server redis://localhost:6379","title":"Redis"},{"location":"self-hosting/environment-variables/#email-provider","text":"Name Description Default Allowed values Example EMAIL_PROVIDER Type of email provider NULL NULL, POSTMARK POSTMARK EMAIL_PROVIDER_PARAMS Configuration dictionary of the email provider {} {\"server_token\": \"XXX-XXX\"} More details about how to setup an email provider in the dedicated section. Setup email provider","title":"Email provider"},{"location":"self-hosting/environment-variables/#csrf-cookie","text":"To protect against Cross-Site-Request-Forgery attacks on authentication pages, we use the double-submit cookie pattern. Name Description Default Allowed values Example CSRF_COOKIE_NAME Name of the CSRF token cookie fief_csrftoken CSRF_COOKIE_SECURE Secure flag of the login session cookie True _COOKIE_SECURE flag should be True in production Browser cookies support the Secure flag , which tells the browser to not forward the cookie if the site is not requested in HTTPS. For your convenience when starting Fief on your local machine, the Quickstart command will set those flags to False for every Fief cookies. However, for security reasons, it's strongly recommended to set those flags to True (the default if not specified) when deploying to production.","title":"CSRF cookie"},{"location":"self-hosting/environment-variables/#login-session","text":"A login session is a cookie used to maintain the state of the login flow of a user, from the login page until they're redirected to your application. Name Description Default Allowed values Example LOGIN_SESSION_COOKIE_NAME Name of the login session cookie fief_login_session LOGIN_SESSION_COOKIE_DOMAIN Domain of the login session cookie Empty string LOGIN_SESSION_COOKIE_SECURE Secure flag of the login session cookie True _COOKIE_SECURE flag should be True in production Browser cookies support the Secure flag , which tells the browser to not forward the cookie if the site is not requested in HTTPS. For your convenience when starting Fief on your local machine, the Quickstart command will set those flags to False for every Fief cookies. However, for security reasons, it's strongly recommended to set those flags to True (the default if not specified) when deploying to production.","title":"Login session"},{"location":"self-hosting/environment-variables/#session","text":"A session is a cookie used to maintain the session of a user on the Fief authentication pages . It's different from the session you'll maintain in your own application. Its purpose is to allow a user to re-authenticate quickly to your app without having them to input their credentials again. Name Description Default Allowed values Example SESSION_COOKIE_NAME Name of the session cookie fief_session SESSION_COOKIE_DOMAIN Domain of the session cookie Empty string SESSION_COOKIE_SECURE Secure flag of the session cookie True SESSION_LIFETIME_SECONDS Lifetime of the session cookie in seconds 86400 * 30 (30 days ) _COOKIE_SECURE flag should be True in production Browser cookies support the Secure flag , which tells the browser to not forward the cookie if the site is not requested in HTTPS. For your convenience when starting Fief on your local machine, the Quickstart command will set those flags to False for every Fief cookies. However, for security reasons, it's strongly recommended to set those flags to True (the default if not specified) when deploying to production.","title":"Session"},{"location":"self-hosting/environment-variables/#authorization-code","text":"Authorization codes are temporary codes generated during the OAuth2 authentication flow . Name Description Default Allowed values Example AUTHORIZATION_CODE_LIFETIME_SECONDS Lifetime of the authorization code in seconds. For security reasons, this value should remain low. OAuth2 specification recommends a value of 10 minutes . 600 (10 minutes)","title":"Authorization code"},{"location":"self-hosting/environment-variables/#fief-ception","text":"Fief-ception is a mind-fucking concept describing the fact that we actually use Fief to authenticate Fief users to the app \ud83e\udd2f That's why we necessarily need to create a first workspace and an admin user before being able to use Fief, as described in the Quickstart section. The variables below are here to configure the Fief server with a proper Fief client, as you would do in your own application! Name Description Default Allowed values Example FIEF_DOMAIN Domain of your main Fief workspace localhost:8000 fief.bretagne.duchy FIEF_CLIENT_ID Client ID in your main Fief workspace FIEF_CLIENT_SECRET Client secret in your main Fief workspace FIEF_ENCRYPTION_KEY Optional RSA key used to encrypt the JWT tokens","title":"Fief-ception"},{"location":"self-hosting/environment-variables/#admin-session","text":"An admin session is a cookie used to maintain the session of a user on the Fief admin dashboard. Name Description Default Allowed values Example FIEF_ADMIN_SESSION_COOKIE_NAME Name of the admin session cookie fief_admin_session FIEF_ADMIN_SESSION_COOKIE_DOMAIN Domain of the admin session cookie Empty string FIEF_ADMIN_SESSION_COOKIE_SECURE Secure flag of the admin session cookie True _COOKIE_SECURE flag should be True in production Browser cookies support the Secure flag , which tells the browser to not forward the cookie if the site is not requested in HTTPS. For your convenience when starting Fief on your local machine, the Quickstart command will set those flags to False for every Fief cookies. However, for security reasons, it's strongly recommended to set those flags to True (the default if not specified) when deploying to production.","title":"Admin session"},{"location":"self-hosting/quickstart/","text":"Quickstart \u00b6 We provide a Docker image to help you start the Fief server locally in no time! Run the following command: docker run --rm ghcr.io/fief-dev/fief:latest fief quickstart --docker The result of this command is a complete docker run command with the required secrets generated and environment variables to help you get started. It'll look like the following: docker run \\ --name fief-server \\ -p 8000 :8000 \\ -d \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ -e \"PORT=8000\" \\ -e \"ROOT_DOMAIN=localhost:8000\" \\ -e \"FIEF_DOMAIN=localhost:8000\" \\ -e \"CSRF_COOKIE_SECURE=False\" \\ -e \"LOGIN_SESSION_COOKIE_SECURE=False\" \\ -e \"SESSION_COOKIE_SECURE=False\" \\ -e \"FIEF_ADMIN_SESSION_COOKIE_SECURE=False\" \\ ghcr.io/fief-dev/fief:latest Save those secrets somewhere safe! If you need restart or recreate your container, you'll probably need to set the same secrets again. If you lose them, you'll likely lose access to data or have a bad configuration. Read more about secrets and environment variables. Info The container is exposed on the port 8000 of your local machine by default. Create main workspace \u00b6 Next, you'll need to create the main workspace . Simply run the following command: docker exec fief-server fief workspaces create-main You should see the following output: Main Fief workspace created Create admin user \u00b6 Finally, you need to create an admin user for this main workspace that'll have access to the admin dashboard. Run the following command: docker exec -it fief-server fief workspaces create-main-user --user-email anne@bretagne.duchy Tip Of course, make sure to replace --user-email value with your own email address! You'll then be prompted for a password. If everything goes well, you should see the following output: Main Fief user created Good to go! \u00b6 At this point, your Fief server should be up-and-running! Open http://localhost:8000/admin/ to access the admin dashboard. You'll be redirected to a login page. Authenticate with the user credentials you created in the previous section. You'll then be redirected to the admin dashboard. Congratulations! Your Fief server instance is up-and-running \ud83c\udf89 You can now try Fief features and start to integrate authentication in your app. Tip For production deployment, we strongly recommend you to read the next sections. Limitations \u00b6 While quick and convenient, this way of running Fief is not suitable for production environments . Under the hood, it stores the data in the form of SQLite databases . If you ever happen to destroy your container, you'll lose all your data. The best way is of course to configure a proper PostgreSQL or MySQL database for your Fief server, as described in the dedicated section. Setup database Use a Docker volume to persist SQLite data \u00b6 If you really want to use SQLite, or mitigate the risk of losing data in your local environment, you can attach your container to a Docker volume . This way, even if the container is destroyed, you can create a new one and attach again the data. The first thing to do is to create a Docker volume: docker volume create fief-server-data Then, create your Fief server container and attach this volume to the /data folder on the container: docker run \\ --name fief-server \\ -p 8000 :8000 \\ -d \\ -v fief-server-volume:/data \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ -e \"PORT=8000\" \\ -e \"ROOT_DOMAIN=localhost:8000\" \\ -e \"FIEF_DOMAIN=localhost:8000\" \\ -e \"CSRF_COOKIE_SECURE=False\" \\ -e \"LOGIN_SESSION_COOKIE_SECURE=False\" \\ -e \"SESSION_COOKIE_SECURE=False\" \\ -e \"FIEF_ADMIN_SESSION_COOKIE_SECURE=False\" \\ ghcr.io/fief-dev/fief:latest Warning If you created your container with the instructions in the previous section, you'll need to recreate one from scratch to bind the volume. Custom local domain and port \u00b6 The quickstart command assume your Fief server will be served over localhost:8000 . Besides, additional workspaces will be automatically assigned a subdomain like bretagne.localhost:8000 . However, you might want to serve it locally on a custom domain you have wired manually on your local machine, like fief.test . In this case, you can use the --host parameter of the quickstart command to slightly adapt the Docker command. docker run --rm ghcr.io/fief-dev/fief:latest fief quickstart --docker --host fief.test docker run \\ --name fief-server \\ -p 8000 :8000 \\ -d \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ -e \"PORT=8000\" \\ -e \"ROOT_DOMAIN=fief.test:8000\" \\ -e \"FIEF_DOMAIN=fief.test:8000\" \\ -e \"CSRF_COOKIE_SECURE=False\" \\ -e \"LOGIN_SESSION_COOKIE_SECURE=False\" \\ -e \"SESSION_COOKIE_SECURE=False\" \\ -e \"FIEF_ADMIN_SESSION_COOKIE_SECURE=False\" \\ ghcr.io/fief-dev/fief:latest You can also customize the exposed port by using the --port parameter of the quickstart command: docker run --rm ghcr.io/fief-dev/fief:latest fief quickstart --docker --host fief.test --port 9000 docker run \\ --name fief-server \\ -p 9000 :9000 \\ -d \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ -e \"PORT=9000\" \\ -e \"ROOT_DOMAIN=fief.test:9000\" \\ -e \"FIEF_DOMAIN=fief.test:9000\" \\ -e \"CSRF_COOKIE_SECURE=False\" \\ -e \"LOGIN_SESSION_COOKIE_SECURE=False\" \\ -e \"SESSION_COOKIE_SECURE=False\" \\ -e \"FIEF_ADMIN_SESSION_COOKIE_SECURE=False\" \\ ghcr.io/fief-dev/fief:latest Notice how the different variables changed to adapt to the custom port.","title":"Quickstart"},{"location":"self-hosting/quickstart/#quickstart","text":"We provide a Docker image to help you start the Fief server locally in no time! Run the following command: docker run --rm ghcr.io/fief-dev/fief:latest fief quickstart --docker The result of this command is a complete docker run command with the required secrets generated and environment variables to help you get started. It'll look like the following: docker run \\ --name fief-server \\ -p 8000 :8000 \\ -d \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ -e \"PORT=8000\" \\ -e \"ROOT_DOMAIN=localhost:8000\" \\ -e \"FIEF_DOMAIN=localhost:8000\" \\ -e \"CSRF_COOKIE_SECURE=False\" \\ -e \"LOGIN_SESSION_COOKIE_SECURE=False\" \\ -e \"SESSION_COOKIE_SECURE=False\" \\ -e \"FIEF_ADMIN_SESSION_COOKIE_SECURE=False\" \\ ghcr.io/fief-dev/fief:latest Save those secrets somewhere safe! If you need restart or recreate your container, you'll probably need to set the same secrets again. If you lose them, you'll likely lose access to data or have a bad configuration. Read more about secrets and environment variables. Info The container is exposed on the port 8000 of your local machine by default.","title":"Quickstart"},{"location":"self-hosting/quickstart/#create-main-workspace","text":"Next, you'll need to create the main workspace . Simply run the following command: docker exec fief-server fief workspaces create-main You should see the following output: Main Fief workspace created","title":"Create main workspace"},{"location":"self-hosting/quickstart/#create-admin-user","text":"Finally, you need to create an admin user for this main workspace that'll have access to the admin dashboard. Run the following command: docker exec -it fief-server fief workspaces create-main-user --user-email anne@bretagne.duchy Tip Of course, make sure to replace --user-email value with your own email address! You'll then be prompted for a password. If everything goes well, you should see the following output: Main Fief user created","title":"Create admin user"},{"location":"self-hosting/quickstart/#good-to-go","text":"At this point, your Fief server should be up-and-running! Open http://localhost:8000/admin/ to access the admin dashboard. You'll be redirected to a login page. Authenticate with the user credentials you created in the previous section. You'll then be redirected to the admin dashboard. Congratulations! Your Fief server instance is up-and-running \ud83c\udf89 You can now try Fief features and start to integrate authentication in your app. Tip For production deployment, we strongly recommend you to read the next sections.","title":"Good to go!"},{"location":"self-hosting/quickstart/#limitations","text":"While quick and convenient, this way of running Fief is not suitable for production environments . Under the hood, it stores the data in the form of SQLite databases . If you ever happen to destroy your container, you'll lose all your data. The best way is of course to configure a proper PostgreSQL or MySQL database for your Fief server, as described in the dedicated section. Setup database","title":"Limitations"},{"location":"self-hosting/quickstart/#use-a-docker-volume-to-persist-sqlite-data","text":"If you really want to use SQLite, or mitigate the risk of losing data in your local environment, you can attach your container to a Docker volume . This way, even if the container is destroyed, you can create a new one and attach again the data. The first thing to do is to create a Docker volume: docker volume create fief-server-data Then, create your Fief server container and attach this volume to the /data folder on the container: docker run \\ --name fief-server \\ -p 8000 :8000 \\ -d \\ -v fief-server-volume:/data \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ -e \"PORT=8000\" \\ -e \"ROOT_DOMAIN=localhost:8000\" \\ -e \"FIEF_DOMAIN=localhost:8000\" \\ -e \"CSRF_COOKIE_SECURE=False\" \\ -e \"LOGIN_SESSION_COOKIE_SECURE=False\" \\ -e \"SESSION_COOKIE_SECURE=False\" \\ -e \"FIEF_ADMIN_SESSION_COOKIE_SECURE=False\" \\ ghcr.io/fief-dev/fief:latest Warning If you created your container with the instructions in the previous section, you'll need to recreate one from scratch to bind the volume.","title":"Use a Docker volume to persist SQLite data"},{"location":"self-hosting/quickstart/#custom-local-domain-and-port","text":"The quickstart command assume your Fief server will be served over localhost:8000 . Besides, additional workspaces will be automatically assigned a subdomain like bretagne.localhost:8000 . However, you might want to serve it locally on a custom domain you have wired manually on your local machine, like fief.test . In this case, you can use the --host parameter of the quickstart command to slightly adapt the Docker command. docker run --rm ghcr.io/fief-dev/fief:latest fief quickstart --docker --host fief.test docker run \\ --name fief-server \\ -p 8000 :8000 \\ -d \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ -e \"PORT=8000\" \\ -e \"ROOT_DOMAIN=fief.test:8000\" \\ -e \"FIEF_DOMAIN=fief.test:8000\" \\ -e \"CSRF_COOKIE_SECURE=False\" \\ -e \"LOGIN_SESSION_COOKIE_SECURE=False\" \\ -e \"SESSION_COOKIE_SECURE=False\" \\ -e \"FIEF_ADMIN_SESSION_COOKIE_SECURE=False\" \\ ghcr.io/fief-dev/fief:latest You can also customize the exposed port by using the --port parameter of the quickstart command: docker run --rm ghcr.io/fief-dev/fief:latest fief quickstart --docker --host fief.test --port 9000 docker run \\ --name fief-server \\ -p 9000 :9000 \\ -d \\ -e \"SECRET=XXX\" \\ -e \"FIEF_CLIENT_ID=XXX\" \\ -e \"FIEF_CLIENT_SECRET=XXX\" \\ -e \"ENCRYPTION_KEY=XXX\" \\ -e \"PORT=9000\" \\ -e \"ROOT_DOMAIN=fief.test:9000\" \\ -e \"FIEF_DOMAIN=fief.test:9000\" \\ -e \"CSRF_COOKIE_SECURE=False\" \\ -e \"LOGIN_SESSION_COOKIE_SECURE=False\" \\ -e \"SESSION_COOKIE_SECURE=False\" \\ -e \"FIEF_ADMIN_SESSION_COOKIE_SECURE=False\" \\ ghcr.io/fief-dev/fief:latest Notice how the different variables changed to adapt to the custom port.","title":"Custom local domain and port"},{"location":"self-hosting/setup-database/","text":"Setup database \u00b6 For production environments, your Fief server should store its data in a proper database server for better performance and reliability. Fief is compatible with PostgreSQL and MySQL databases. Setup PostgreSQL \u00b6 We'll assume that you have a working PostgreSQL database running, either locally or in the cloud. All you need to do is to set the corresponding environment variables with your database credentials. DATABASE_TYPE = POSTGRESQL DATABASE_HOST = localhost DATABASE_PORT = 5432 DATABASE_USERNAME = fief DATABASE_PASSWORD = fiefpassword DATABASE_NAME = fief Tip You can read about different ways of setting environment variables in the dedicated section . Setup MySQL \u00b6 We'll assume that you have a working MySQL database running, either locally or in the cloud. All you need to do is to set the corresponding environment variables with your database credentials. DATABASE_TYPE = MYSQL DATABASE_HOST = localhost DATABASE_PORT = 3306 DATABASE_USERNAME = fief DATABASE_PASSWORD = fiefpassword DATABASE_NAME = fief Tip You can read about different ways of setting environment variables in the dedicated section . Use a connection string \u00b6 Some cloud providers like Heroku will provide you a full database connection string like the one below instead of each parts separately: postgresql://fief:fiefpassword@localhost:5432/fief Fief supports this kind of configuration with the DATABASE_URL environment variable. DATABASE_TYPE = POSTGRESQL DATABASE_URL = postgresql://fief:fiefpassword@localhost:5432/fief Warning This variable will always take precedence over the single parameters: if you define DATABASE_URL , it'll use this variable to connect to your database, even if other parameters are defined. Create main workspace and admin user \u00b6 Once your database is configured, don't forget to create the main workspace and admin user, as described in the Quickstart section.","title":"Setup database"},{"location":"self-hosting/setup-database/#setup-database","text":"For production environments, your Fief server should store its data in a proper database server for better performance and reliability. Fief is compatible with PostgreSQL and MySQL databases.","title":"Setup database"},{"location":"self-hosting/setup-database/#setup-postgresql","text":"We'll assume that you have a working PostgreSQL database running, either locally or in the cloud. All you need to do is to set the corresponding environment variables with your database credentials. DATABASE_TYPE = POSTGRESQL DATABASE_HOST = localhost DATABASE_PORT = 5432 DATABASE_USERNAME = fief DATABASE_PASSWORD = fiefpassword DATABASE_NAME = fief Tip You can read about different ways of setting environment variables in the dedicated section .","title":"Setup PostgreSQL"},{"location":"self-hosting/setup-database/#setup-mysql","text":"We'll assume that you have a working MySQL database running, either locally or in the cloud. All you need to do is to set the corresponding environment variables with your database credentials. DATABASE_TYPE = MYSQL DATABASE_HOST = localhost DATABASE_PORT = 3306 DATABASE_USERNAME = fief DATABASE_PASSWORD = fiefpassword DATABASE_NAME = fief Tip You can read about different ways of setting environment variables in the dedicated section .","title":"Setup MySQL"},{"location":"self-hosting/setup-database/#use-a-connection-string","text":"Some cloud providers like Heroku will provide you a full database connection string like the one below instead of each parts separately: postgresql://fief:fiefpassword@localhost:5432/fief Fief supports this kind of configuration with the DATABASE_URL environment variable. DATABASE_TYPE = POSTGRESQL DATABASE_URL = postgresql://fief:fiefpassword@localhost:5432/fief Warning This variable will always take precedence over the single parameters: if you define DATABASE_URL , it'll use this variable to connect to your database, even if other parameters are defined.","title":"Use a connection string"},{"location":"self-hosting/setup-database/#create-main-workspace-and-admin-user","text":"Once your database is configured, don't forget to create the main workspace and admin user, as described in the Quickstart section.","title":"Create main workspace and admin user"},{"location":"self-hosting/setup-email-provider/","text":"Setup email provider \u00b6 As you surely now, users management imply a lot of transactional emails, like welcome emails or reset password emails. To be able to send them, Fief needs an email provider. Currently, Fief only supports Postmark , one of the leading email delivery service on the market, but we may support more in the future. There are two environment variables to configure the email provider: EMAIL_PROVIDER , to set the type of provider and EMAIL_PROVIDER_PARAMS , a configuration dictionary containing required configuration keys. NULL provider \u00b6 The NULL provider is the default one if you don't set any. It means that no transactional email will be sent . EMAIL_PROVIDER = NULL Postmark provider \u00b6 Postmark provider will send transactional emails using Postmark . Parameter Description server_token Your Postmark Server API token EMAIL_PROVIDER = POSTMARK EMAIL_PROVIDER_PARAMS = {\"server_token\": \"XXX-XXX\"} Tip You can read about different ways of setting environment variables in the dedicated section .","title":"Setup email provider"},{"location":"self-hosting/setup-email-provider/#setup-email-provider","text":"As you surely now, users management imply a lot of transactional emails, like welcome emails or reset password emails. To be able to send them, Fief needs an email provider. Currently, Fief only supports Postmark , one of the leading email delivery service on the market, but we may support more in the future. There are two environment variables to configure the email provider: EMAIL_PROVIDER , to set the type of provider and EMAIL_PROVIDER_PARAMS , a configuration dictionary containing required configuration keys.","title":"Setup email provider"},{"location":"self-hosting/setup-email-provider/#null-provider","text":"The NULL provider is the default one if you don't set any. It means that no transactional email will be sent . EMAIL_PROVIDER = NULL","title":"NULL provider"},{"location":"self-hosting/setup-email-provider/#postmark-provider","text":"Postmark provider will send transactional emails using Postmark . Parameter Description server_token Your Postmark Server API token EMAIL_PROVIDER = POSTMARK EMAIL_PROVIDER_PARAMS = {\"server_token\": \"XXX-XXX\"} Tip You can read about different ways of setting environment variables in the dedicated section .","title":"Postmark provider"}]}